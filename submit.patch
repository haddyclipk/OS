diff --git a/.cproject b/.cproject
new file mode 100644
index 0000000..f70133d
--- /dev/null
+++ b/.cproject
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="0.1480216780">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="0.1480216780" moduleId="org.eclipse.cdt.core.settings" name="Default">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.VCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration buildProperties="" description="" id="0.1480216780" name="Default" parent="org.eclipse.cdt.build.core.prefbase.cfg">
+					<folderInfo id="0.1480216780." name="/" resourcePath="">
+						<toolChain id="org.eclipse.cdt.build.core.prefbase.toolchain.904457826" name="No ToolChain" resourceTypeBasedDiscovery="false" superClass="org.eclipse.cdt.build.core.prefbase.toolchain">
+							<targetPlatform id="org.eclipse.cdt.build.core.prefbase.toolchain.904457826.332120844" name=""/>
+							<builder id="org.eclipse.cdt.build.core.settings.default.builder.926228091" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Gnu Make Builder" superClass="org.eclipse.cdt.build.core.settings.default.builder"/>
+							<tool id="org.eclipse.cdt.build.core.settings.holder.libs.1532505298" name="holder for library settings" superClass="org.eclipse.cdt.build.core.settings.holder.libs"/>
+							<tool id="org.eclipse.cdt.build.core.settings.holder.1374373016" name="Assembly" superClass="org.eclipse.cdt.build.core.settings.holder">
+								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.1636813309" languageId="org.eclipse.cdt.core.assembly" languageName="Assembly" sourceContentType="org.eclipse.cdt.core.asmSource" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
+							</tool>
+							<tool id="org.eclipse.cdt.build.core.settings.holder.1548496932" name="GNU C++" superClass="org.eclipse.cdt.build.core.settings.holder">
+								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.2044814512" languageId="org.eclipse.cdt.core.g++" languageName="GNU C++" sourceContentType="org.eclipse.cdt.core.cxxSource,org.eclipse.cdt.core.cxxHeader" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
+							</tool>
+							<tool id="org.eclipse.cdt.build.core.settings.holder.2030291621" name="GNU C" superClass="org.eclipse.cdt.build.core.settings.holder">
+								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.1200708495" languageId="org.eclipse.cdt.core.gcc" languageName="GNU C" sourceContentType="org.eclipse.cdt.core.cSource,org.eclipse.cdt.core.cHeader" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="os161.null.5113732" name="os161"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		<scannerConfigBuildInfo instanceId="0.1480216780">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+</cproject>
diff --git a/.gitignore b/.gitignore
index ccea0c4..fa313dd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,5 @@
-.depend
-.settings
-.project
-.cproject
-/kern/compile/
-defs.mk
 build
-/user/testbin/randcall/calls.c
-*.swp
+.depend
+/defs.mk
+kern/compile/
+user/testbin/randcall/calls.c
diff --git a/.project b/.project
new file mode 100644
index 0000000..3f7d5f2
--- /dev/null
+++ b/.project
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>os161</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/kern.tar.gz b/kern.tar.gz
new file mode 100644
index 0000000..0bb91e1
Binary files /dev/null and b/kern.tar.gz differ
diff --git a/kern/arch/mips/conf/conf.arch b/kern/arch/mips/conf/conf.arch
index 39ddbc3..947dcca 100644
--- a/kern/arch/mips/conf/conf.arch
+++ b/kern/arch/mips/conf/conf.arch
@@ -66,6 +66,7 @@ machine mips file    arch/mips/vm/ram.c		# Physical memory accounting
 # it may not be suitable for all architectures.
 machine mips file    vm/copyinout.c		# copyin/out et al.
 
+
 # For the early assignments, we supply a very stupid MIPS-only skeleton
 # of a VM system. It is just barely capable of running a single userlevel
 # program as long as that program's not very large.
diff --git a/kern/arch/mips/include/vm.h b/kern/arch/mips/include/vm.h
index af393c7..3b9f82a 100644
--- a/kern/arch/mips/include/vm.h
+++ b/kern/arch/mips/include/vm.h
@@ -66,7 +66,7 @@
  * a valid address, and will make a *huge* mess if you scribble on it.
  */
 #define PADDR_TO_KVADDR(paddr) ((paddr)+MIPS_KSEG0)
-
+#define KVADDR_TO_PADDR(vaddr) ((vaddr)-MIPS_KSEG0)
 /*
  * The top of user space. (Actually, the address immediately above the
  * last valid user address.)
diff --git a/kern/arch/mips/locore/.trap.c.swp b/kern/arch/mips/locore/.trap.c.swp
new file mode 100644
index 0000000..1547aff
Binary files /dev/null and b/kern/arch/mips/locore/.trap.c.swp differ
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..c11a9f1 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -111,7 +111,7 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 	/*
 	 * You will probably want to change this.
 	 */
-
+	sys__exit(-1);
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
 	panic("I don't know how to handle this\n");
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..b7ff16e 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,6 +35,8 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include <kern/filesys.h>
+#include <copyinout.h>
 
 
 /*
@@ -81,7 +83,10 @@ syscall(struct trapframe *tf)
 	int callno;
 	int32_t retval;
 	int err;
-
+	off_t sys_pos=0;
+	off_t ret;
+	int whence;
+	
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
 	KASSERT(curthread->t_iplhigh_count == 0);
@@ -108,9 +113,60 @@ syscall(struct trapframe *tf)
 		err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
 		break;
-
+	    
 	    /* Add stuff here */
- 
+ 	    case SYS_fork:
+		err = sys_fork(tf,&retval);
+		break;
+	    case SYS_execv:
+		err=sys_execv(&retval, (const char*)tf->tf_a0,(char**)tf->tf_a1);
+		break;
+	    case SYS_waitpid:
+		err=sys_waitpid(&retval, (pid_t)tf->tf_a0, (int*)tf->tf_a1,tf->tf_a2);
+		break;
+	   case SYS__exit:
+		err=sys__exit( (int)tf->tf_a0);
+		break;
+	   case SYS_getpid:
+		err = sys_getpid(&retval);
+		break;
+	case SYS_read:
+		err = sys_read(tf->tf_a0, (void *) tf->tf_a1, (size_t) tf->tf_a2, &retval);
+		break;
+	case SYS_write:
+		err = sys_write(tf->tf_a0, (void *) tf->tf_a1, (size_t) tf->tf_a2, &retval);
+		break;
+	case SYS_open:
+		err = sys_open((const char *)tf->tf_a0, tf->tf_a1, (mode_t)tf->tf_a2, &retval);
+		break;
+	case SYS_close:
+		err = sys_close(tf->tf_a0, &retval);
+		break;
+	case SYS_lseek:
+		sys_pos = ((off_t)tf->tf_a2) << 32 | (off_t)tf->tf_a3;
+		err = copyin((const_userptr_t)tf->tf_sp+16, &whence, sizeof(int));
+		if(err) {
+			break;
+		}
+		err = sys_lseek(tf->tf_a0, sys_pos, (int)whence, &ret);
+		if(!err){
+			tf->tf_v1 = ret;
+			retval = ret >> 32;
+		}
+		break;
+	case SYS_dup2:
+		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+		break;
+	case SYS_chdir:
+		err = sys_chdir((const char *)tf->tf_a0, &retval);
+		break;
+	case SYS___getcwd:
+		err = sys___getcwd((char *)tf->tf_a0, (size_t)tf->tf_a1, &retval);
+		break;
+	case SYS_sbrk:
+		err=sys_sbrk(tf->tf_a0,&retval);
+		break;
+
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
index ca9992a..89a746c 100644
--- a/kern/arch/mips/vm/dumbvm.c
+++ b/kern/arch/mips/vm/dumbvm.c
@@ -1,374 +1,374 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <types.h>
-#include <kern/errno.h>
-#include <lib.h>
-#include <spl.h>
-#include <spinlock.h>
-#include <thread.h>
-#include <current.h>
-#include <mips/tlb.h>
-#include <addrspace.h>
-#include <vm.h>
-
-/*
- * Dumb MIPS-only "VM system" that is intended to only be just barely
- * enough to struggle off the ground. You should replace all of this
- * code while doing the VM assignment. In fact, starting in that
- * assignment, this file is not included in your kernel!
- */
-
-/* under dumbvm, always have 48k of user stack */
-#define DUMBVM_STACKPAGES    12
-
-/*
- * Wrap rma_stealmem in a spinlock.
- */
-static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
-
-void
-vm_bootstrap(void)
-{
-	/* Do nothing. */
-}
-
-static
-paddr_t
-getppages(unsigned long npages)
-{
-	paddr_t addr;
-
-	spinlock_acquire(&stealmem_lock);
-
-	addr = ram_stealmem(npages);
-	
-	spinlock_release(&stealmem_lock);
-	return addr;
-}
-
-/* Allocate/free some kernel-space virtual pages */
-vaddr_t 
-alloc_kpages(int npages)
-{
-	paddr_t pa;
-	pa = getppages(npages);
-	if (pa==0) {
-		return 0;
-	}
-	return PADDR_TO_KVADDR(pa);
-}
-
-void 
-free_kpages(vaddr_t addr)
-{
-	/* nothing - leak the memory. */
-
-	(void)addr;
-}
-
-void
-vm_tlbshootdown_all(void)
-{
-	panic("dumbvm tried to do tlb shootdown?!\n");
-}
-
-void
-vm_tlbshootdown(const struct tlbshootdown *ts)
-{
-	(void)ts;
-	panic("dumbvm tried to do tlb shootdown?!\n");
-}
-
-int
-vm_fault(int faulttype, vaddr_t faultaddress)
-{
-	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
-	paddr_t paddr;
-	int i;
-	uint32_t ehi, elo;
-	struct addrspace *as;
-	int spl;
-
-	faultaddress &= PAGE_FRAME;
-
-	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
-
-	switch (faulttype) {
-	    case VM_FAULT_READONLY:
-		/* We always create pages read-write, so we can't get this */
-		panic("dumbvm: got VM_FAULT_READONLY\n");
-	    case VM_FAULT_READ:
-	    case VM_FAULT_WRITE:
-		break;
-	    default:
-		return EINVAL;
-	}
-
-	as = curthread->t_addrspace;
-	if (as == NULL) {
-		/*
-		 * No address space set up. This is probably a kernel
-		 * fault early in boot. Return EFAULT so as to panic
-		 * instead of getting into an infinite faulting loop.
-		 */
-		return EFAULT;
-	}
-
-	/* Assert that the address space has been set up properly. */
-	KASSERT(as->as_vbase1 != 0);
-	KASSERT(as->as_pbase1 != 0);
-	KASSERT(as->as_npages1 != 0);
-	KASSERT(as->as_vbase2 != 0);
-	KASSERT(as->as_pbase2 != 0);
-	KASSERT(as->as_npages2 != 0);
-	KASSERT(as->as_stackpbase != 0);
-	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
-	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
-	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
-	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
-	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
-
-	vbase1 = as->as_vbase1;
-	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
-	vbase2 = as->as_vbase2;
-	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
-	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
-	stacktop = USERSTACK;
-
-	if (faultaddress >= vbase1 && faultaddress < vtop1) {
-		paddr = (faultaddress - vbase1) + as->as_pbase1;
-	}
-	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
-		paddr = (faultaddress - vbase2) + as->as_pbase2;
-	}
-	else if (faultaddress >= stackbase && faultaddress < stacktop) {
-		paddr = (faultaddress - stackbase) + as->as_stackpbase;
-	}
-	else {
-		return EFAULT;
-	}
-
-	/* make sure it's page-aligned */
-	KASSERT((paddr & PAGE_FRAME) == paddr);
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_read(&ehi, &elo, i);
-		if (elo & TLBLO_VALID) {
-			continue;
-		}
-		ehi = faultaddress;
-		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
-		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
-		tlb_write(ehi, elo, i);
-		splx(spl);
-		return 0;
-	}
-
-	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
-	splx(spl);
-	return EFAULT;
-}
-
-struct addrspace *
-as_create(void)
-{
-	struct addrspace *as = kmalloc(sizeof(struct addrspace));
-	if (as==NULL) {
-		return NULL;
-	}
-
-	as->as_vbase1 = 0;
-	as->as_pbase1 = 0;
-	as->as_npages1 = 0;
-	as->as_vbase2 = 0;
-	as->as_pbase2 = 0;
-	as->as_npages2 = 0;
-	as->as_stackpbase = 0;
-
-	return as;
-}
-
-void
-as_destroy(struct addrspace *as)
-{
-	kfree(as);
-}
-
-void
-as_activate(struct addrspace *as)
-{
-	int i, spl;
-
-	(void)as;
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
-	}
-
-	splx(spl);
-}
-
-int
-as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
-		 int readable, int writeable, int executable)
-{
-	size_t npages; 
-
-	/* Align the region. First, the base... */
-	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
-	vaddr &= PAGE_FRAME;
-
-	/* ...and now the length. */
-	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
-
-	npages = sz / PAGE_SIZE;
-
-	/* We don't use these - all pages are read-write */
-	(void)readable;
-	(void)writeable;
-	(void)executable;
-
-	if (as->as_vbase1 == 0) {
-		as->as_vbase1 = vaddr;
-		as->as_npages1 = npages;
-		return 0;
-	}
-
-	if (as->as_vbase2 == 0) {
-		as->as_vbase2 = vaddr;
-		as->as_npages2 = npages;
-		return 0;
-	}
-
-	/*
-	 * Support for more than two regions is not available.
-	 */
-	kprintf("dumbvm: Warning: too many regions\n");
-	return EUNIMP;
-}
-
-static
-void
-as_zero_region(paddr_t paddr, unsigned npages)
-{
-	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
-}
-
-int
-as_prepare_load(struct addrspace *as)
-{
-	KASSERT(as->as_pbase1 == 0);
-	KASSERT(as->as_pbase2 == 0);
-	KASSERT(as->as_stackpbase == 0);
-
-	as->as_pbase1 = getppages(as->as_npages1);
-	if (as->as_pbase1 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_pbase2 = getppages(as->as_npages2);
-	if (as->as_pbase2 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
-	if (as->as_stackpbase == 0) {
-		return ENOMEM;
-	}
-	
-	as_zero_region(as->as_pbase1, as->as_npages1);
-	as_zero_region(as->as_pbase2, as->as_npages2);
-	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
-
-	return 0;
-}
-
-int
-as_complete_load(struct addrspace *as)
-{
-	(void)as;
-	return 0;
-}
-
-int
-as_define_stack(struct addrspace *as, vaddr_t *stackptr)
-{
-	KASSERT(as->as_stackpbase != 0);
-
-	*stackptr = USERSTACK;
-	return 0;
-}
-
-int
-as_copy(struct addrspace *old, struct addrspace **ret)
-{
-	struct addrspace *new;
-
-	new = as_create();
-	if (new==NULL) {
-		return ENOMEM;
-	}
-
-	new->as_vbase1 = old->as_vbase1;
-	new->as_npages1 = old->as_npages1;
-	new->as_vbase2 = old->as_vbase2;
-	new->as_npages2 = old->as_npages2;
-
-	/* (Mis)use as_prepare_load to allocate some physical memory. */
-	if (as_prepare_load(new)) {
-		as_destroy(new);
-		return ENOMEM;
-	}
-
-	KASSERT(new->as_pbase1 != 0);
-	KASSERT(new->as_pbase2 != 0);
-	KASSERT(new->as_stackpbase != 0);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
-		old->as_npages1*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
-		old->as_npages2*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
-		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
-		DUMBVM_STACKPAGES*PAGE_SIZE);
-	
-	*ret = new;
-	return 0;
-}
+///*
+// * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+// *	The President and Fellows of Harvard College.
+// *
+// * Redistribution and use in source and binary forms, with or without
+// * modification, are permitted provided that the following conditions
+// * are met:
+// * 1. Redistributions of source code must retain the above copyright
+// *    notice, this list of conditions and the following disclaimer.
+// * 2. Redistributions in binary form must reproduce the above copyright
+// *    notice, this list of conditions and the following disclaimer in the
+// *    documentation and/or other materials provided with the distribution.
+// * 3. Neither the name of the University nor the names of its contributors
+// *    may be used to endorse or promote products derived from this software
+// *    without specific prior written permission.
+// *
+// * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+// * SUCH DAMAGE.
+// */
+//
+//#include <types.h>
+//#include <kern/errno.h>
+//#include <lib.h>
+//#include <spl.h>
+//#include <spinlock.h>
+//#include <thread.h>
+//#include <current.h>
+//#include <mips/tlb.h>
+//#include <addrspace.h>
+//#include <vm.h>
+//
+///*
+// * Dumb MIPS-only "VM system" that is intended to only be just barely
+// * enough to struggle off the ground. You should replace all of this
+// * code while doing the VM assignment. In fact, starting in that
+// * assignment, this file is not included in your kernel!
+// */
+//
+///* under dumbvm, always have 48k of user stack */
+//#define DUMBVM_STACKPAGES    12
+//
+///*
+// * Wrap rma_stealmem in a spinlock.
+// */
+//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+//
+//void
+//vm_bootstrap(void)
+//{
+//	/* Do nothing. */
+//}
+//
+//static
+//paddr_t
+//getppages(unsigned long npages)
+//{
+//	paddr_t addr;
+//
+//	spinlock_acquire(&stealmem_lock);
+//
+//	addr = ram_stealmem(npages);
+//
+//	spinlock_release(&stealmem_lock);
+//	return addr;
+//}
+//
+///* Allocate/free some kernel-space virtual pages */
+//vaddr_t
+//alloc_kpages(int npages)
+//{
+//	paddr_t pa;
+//	pa = getppages(npages);
+//	if (pa==0) {
+//		return 0;
+//	}
+//	return PADDR_TO_KVADDR(pa);
+//}
+//
+//void
+//free_kpages(vaddr_t addr)
+//{
+//	/* nothing - leak the memory. */
+//
+//	(void)addr;
+//}
+//
+//void
+//vm_tlbshootdown_all(void)
+//{
+//	panic("dumbvm tried to do tlb shootdown?!\n");
+//}
+//
+//void
+//vm_tlbshootdown(const struct tlbshootdown *ts)
+//{
+//	(void)ts;
+//	panic("dumbvm tried to do tlb shootdown?!\n");
+//}
+//
+//int
+//vm_fault(int faulttype, vaddr_t faultaddress)
+//{
+//	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+//	paddr_t paddr;
+//	int i;
+//	uint32_t ehi, elo;
+//	struct addrspace *as;
+//	int spl;
+//
+//	faultaddress &= PAGE_FRAME;
+//
+//	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+//
+//	switch (faulttype) {
+//	    case VM_FAULT_READONLY:
+//		/* We always create pages read-write, so we can't get this */
+//		panic("dumbvm: got VM_FAULT_READONLY\n");
+//	    case VM_FAULT_READ:
+//	    case VM_FAULT_WRITE:
+//		break;
+//	    default:
+//		return EINVAL;
+//	}
+//
+//	as = curthread->t_addrspace;
+//	if (as == NULL) {
+//		/*
+//		 * No address space set up. This is probably a kernel
+//		 * fault early in boot. Return EFAULT so as to panic
+//		 * instead of getting into an infinite faulting loop.
+//		 */
+//		return EFAULT;
+//	}
+//
+//	/* Assert that the address space has been set up properly. */
+//	KASSERT(as->as_vbase1 != 0);
+//	KASSERT(as->as_pbase1 != 0);
+//	KASSERT(as->as_npages1 != 0);
+//	KASSERT(as->as_vbase2 != 0);
+//	KASSERT(as->as_pbase2 != 0);
+//	KASSERT(as->as_npages2 != 0);
+//	KASSERT(as->as_stackpbase != 0);
+//	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+//	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+//	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+//	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+//	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+//
+//	vbase1 = as->as_vbase1;
+//	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+//	vbase2 = as->as_vbase2;
+//	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+//	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+//	stacktop = USERSTACK;
+//
+//	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+//		paddr = (faultaddress - vbase1) + as->as_pbase1;
+//	}
+//	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+//		paddr = (faultaddress - vbase2) + as->as_pbase2;
+//	}
+//	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+//		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+//	}
+//	else {
+//		return EFAULT;
+//	}
+//
+//	/* make sure it's page-aligned */
+//	KASSERT((paddr & PAGE_FRAME) == paddr);
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_read(&ehi, &elo, i);
+//		if (elo & TLBLO_VALID) {
+//			continue;
+//		}
+//		ehi = faultaddress;
+//		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+//		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+//		tlb_write(ehi, elo, i);
+//		splx(spl);
+//		return 0;
+//	}
+//
+//	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+//	splx(spl);
+//	return EFAULT;
+//}
+//
+//struct addrspace *
+//as_create(void)
+//{
+//	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+//	if (as==NULL) {
+//		return NULL;
+//	}
+//
+//	as->as_vbase1 = 0;
+//	as->as_pbase1 = 0;
+//	as->as_npages1 = 0;
+//	as->as_vbase2 = 0;
+//	as->as_pbase2 = 0;
+//	as->as_npages2 = 0;
+//	as->as_stackpbase = 0;
+//
+//	return as;
+//}
+//
+//void
+//as_destroy(struct addrspace *as)
+//{
+//	kfree(as);
+//}
+//
+//void
+//as_activate(struct addrspace *as)
+//{
+//	int i, spl;
+//
+//	(void)as;
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+//	}
+//
+//	splx(spl);
+//}
+//
+//int
+//as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+//		 int readable, int writeable, int executable)
+//{
+//	size_t npages;
+//
+//	/* Align the region. First, the base... */
+//	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+//	vaddr &= PAGE_FRAME;
+//
+//	/* ...and now the length. */
+//	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+//
+//	npages = sz / PAGE_SIZE;
+//
+//	/* We don't use these - all pages are read-write */
+//	(void)readable;
+//	(void)writeable;
+//	(void)executable;
+//
+//	if (as->as_vbase1 == 0) {
+//		as->as_vbase1 = vaddr;
+//		as->as_npages1 = npages;
+//		return 0;
+//	}
+//
+//	if (as->as_vbase2 == 0) {
+//		as->as_vbase2 = vaddr;
+//		as->as_npages2 = npages;
+//		return 0;
+//	}
+//
+//	/*
+//	 * Support for more than two regions is not available.
+//	 */
+//	kprintf("dumbvm: Warning: too many regions\n");
+//	return EUNIMP;
+//}
+//
+//static
+//void
+//as_zero_region(paddr_t paddr, unsigned npages)
+//{
+//	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+//}
+//
+//int
+//as_prepare_load(struct addrspace *as)
+//{
+//	KASSERT(as->as_pbase1 == 0);
+//	KASSERT(as->as_pbase2 == 0);
+//	KASSERT(as->as_stackpbase == 0);
+//
+//	as->as_pbase1 = getppages(as->as_npages1);
+//	if (as->as_pbase1 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_pbase2 = getppages(as->as_npages2);
+//	if (as->as_pbase2 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+//	if (as->as_stackpbase == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as_zero_region(as->as_pbase1, as->as_npages1);
+//	as_zero_region(as->as_pbase2, as->as_npages2);
+//	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+//
+//	return 0;
+//}
+//
+//int
+//as_complete_load(struct addrspace *as)
+//{
+//	(void)as;
+//	return 0;
+//}
+//
+//int
+//as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+//{
+//	KASSERT(as->as_stackpbase != 0);
+//
+//	*stackptr = USERSTACK;
+//	return 0;
+//}
+//
+//int
+//as_copy(struct addrspace *old, struct addrspace **ret)
+//{
+//	struct addrspace *new;
+//
+//	new = as_create();
+//	if (new==NULL) {
+//		return ENOMEM;
+//	}
+//
+//	new->as_vbase1 = old->as_vbase1;
+//	new->as_npages1 = old->as_npages1;
+//	new->as_vbase2 = old->as_vbase2;
+//	new->as_npages2 = old->as_npages2;
+//
+//	/* (Mis)use as_prepare_load to allocate some physical memory. */
+//	if (as_prepare_load(new)) {
+//		as_destroy(new);
+//		return ENOMEM;
+//	}
+//
+//	KASSERT(new->as_pbase1 != 0);
+//	KASSERT(new->as_pbase2 != 0);
+//	KASSERT(new->as_stackpbase != 0);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+//		old->as_npages1*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+//		old->as_npages2*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+//		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+//		DUMBVM_STACKPAGES*PAGE_SIZE);
+//
+//	*ret = new;
+//	return 0;
+//}
diff --git a/kern/arch/mips/vm/mipsvm.c b/kern/arch/mips/vm/mipsvm.c
new file mode 100644
index 0000000..93d074e
--- /dev/null
+++ b/kern/arch/mips/vm/mipsvm.c
@@ -0,0 +1,374 @@
+///*
+// * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+// *	The President and Fellows of Harvard College.
+// *
+// * Redistribution and use in source and binary forms, with or without
+// * modification, are permitted provided that the following conditions
+// * are met:
+// * 1. Redistributions of source code must retain the above copyright
+// *    notice, this list of conditions and the following disclaimer.
+// * 2. Redistributions in binary form must reproduce the above copyright
+// *    notice, this list of conditions and the following disclaimer in the
+// *    documentation and/or other materials provided with the distribution.
+// * 3. Neither the name of the University nor the names of its contributors
+// *    may be used to endorse or promote products derived from this software
+// *    without specific prior written permission.
+// *
+// * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+// * SUCH DAMAGE.
+// */
+//
+//#include <types.h>
+//#include <kern/errno.h>
+//#include <lib.h>
+//#include <spl.h>
+//#include <spinlock.h>
+//#include <thread.h>
+//#include <current.h>
+//#include <mips/tlb.h>
+//#include <addrspace.h>
+//#include <vm.h>
+//
+///*
+// * Dumb MIPS-only "VM system" that is intended to only be just barely
+// * enough to struggle off the ground. You should replace all of this
+// * code while doing the VM assignment. In fact, starting in that
+// * assignment, this file is not included in your kernel!
+// */
+//
+///* under dumbvm, always have 48k of user stack */
+//#define DUMBVM_STACKPAGES    12
+//
+///*
+// * Wrap rma_stealmem in a spinlock.
+// */
+//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+//
+//void
+//vm_bootstrap(void)
+//{
+//	/* Do nothing. */
+//}
+//
+//static
+//paddr_t
+//getppages(unsigned long npages)
+//{
+//	paddr_t addr;
+//
+//	spinlock_acquire(&stealmem_lock);
+//
+//	addr = ram_stealmem(npages);
+//
+//	spinlock_release(&stealmem_lock);
+//	return addr;
+//}
+//
+///* Allocate/free some kernel-space virtual pages */
+//vaddr_t
+//alloc_kpages(int npages)
+//{
+//	paddr_t pa;
+//	pa = getppages(npages);
+//	if (pa==0) {
+//		return 0;
+//	}
+//	return PADDR_TO_KVADDR(pa);
+//}
+//
+//void
+//free_kpages(vaddr_t addr)
+//{
+//	/* nothing - leak the memory. */
+//
+//	(void)addr;
+//}
+//
+//void
+//vm_tlbshootdown_all(void)
+//{
+//	panic("dumbvm tried to do tlb shootdown?!\n");
+//}
+//
+//void
+//vm_tlbshootdown(const struct tlbshootdown *ts)
+//{
+//	(void)ts;
+//	panic("dumbvm tried to do tlb shootdown?!\n");
+//}
+//
+//int
+//vm_fault(int faulttype, vaddr_t faultaddress)
+//{
+//	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+//	paddr_t paddr;
+//	int i;
+//	uint32_t ehi, elo;
+//	struct addrspace *as;
+//	int spl;
+//
+//	faultaddress &= PAGE_FRAME;
+//
+//	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+//
+//	switch (faulttype) {
+//	    case VM_FAULT_READONLY:
+//		/* We always create pages read-write, so we can't get this */
+//		panic("dumbvm: got VM_FAULT_READONLY\n");
+//	    case VM_FAULT_READ:
+//	    case VM_FAULT_WRITE:
+//		break;
+//	    default:
+//		return EINVAL;
+//	}
+//
+//	as = curthread->t_addrspace;
+//	if (as == NULL) {
+//		/*
+//		 * No address space set up. This is probably a kernel
+//		 * fault early in boot. Return EFAULT so as to panic
+//		 * instead of getting into an infinite faulting loop.
+//		 */
+//		return EFAULT;
+//	}
+//
+//	/* Assert that the address space has been set up properly. */
+//	KASSERT(as->as_vbase1 != 0);
+//	KASSERT(as->as_pbase1 != 0);
+//	KASSERT(as->as_npages1 != 0);
+//	KASSERT(as->as_vbase2 != 0);
+//	KASSERT(as->as_pbase2 != 0);
+//	KASSERT(as->as_npages2 != 0);
+//	KASSERT(as->as_stackpbase != 0);
+//	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+//	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+//	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+//	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+//	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+//
+//	vbase1 = as->as_vbase1;
+//	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+//	vbase2 = as->as_vbase2;
+//	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+//	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+//	stacktop = USERSTACK;
+//
+//	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+//		paddr = (faultaddress - vbase1) + as->as_pbase1;
+//	}
+//	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+//		paddr = (faultaddress - vbase2) + as->as_pbase2;
+//	}
+//	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+//		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+//	}
+//	else {
+//		return EFAULT;
+//	}
+//
+//	/* make sure it's page-aligned */
+//	KASSERT((paddr & PAGE_FRAME) == paddr);
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_read(&ehi, &elo, i);
+//		if (elo & TLBLO_VALID) {
+//			continue;
+//		}
+//		ehi = faultaddress;
+//		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+//		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+//		tlb_write(ehi, elo, i);
+//		splx(spl);
+//		return 0;
+//	}
+//
+//	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+//	splx(spl);
+//	return EFAULT;
+//}
+//
+///* struct addrspace * */
+///* as_create(void) */
+///* { */
+///* 	struct addrspace *as = kmalloc(sizeof(struct addrspace)); */
+///* 	if (as==NULL) { */
+///* 		return NULL; */
+///* 	} */
+//
+///* 	as->as_vbase1 = 0; */
+///* 	as->as_pbase1 = 0; */
+///* 	as->as_npages1 = 0; */
+///* 	as->as_vbase2 = 0; */
+///* 	as->as_pbase2 = 0; */
+///* 	as->as_npages2 = 0; */
+///* 	as->as_stackpbase = 0; */
+//
+///* 	return as; */
+///* } */
+//
+///* void */
+///* as_destroy(struct addrspace *as) */
+///* { */
+///* 	kfree(as); */
+///* } */
+//
+///* void */
+///* as_activate(struct addrspace *as) */
+///* { */
+///* 	int i, spl; */
+//
+///* 	(void)as; */
+//
+///* 	/\* Disable interrupts on this CPU while frobbing the TLB. *\/ */
+///* 	spl = splhigh(); */
+//
+///* 	for (i=0; i<NUM_TLB; i++) { */
+///* 		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i); */
+///* 	} */
+//
+///* 	splx(spl); */
+///* } */
+//
+///* int */
+///* as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz, */
+///* 		 int readable, int writeable, int executable) */
+///* { */
+///* 	size_t npages;  */
+//
+///* 	/\* Align the region. First, the base... *\/ */
+///* 	sz += vaddr & ~(vaddr_t)PAGE_FRAME; */
+///* 	vaddr &= PAGE_FRAME; */
+//
+///* 	/\* ...and now the length. *\/ */
+///* 	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME; */
+//
+///* 	npages = sz / PAGE_SIZE; */
+//
+///* 	/\* We don't use these - all pages are read-write *\/ */
+///* 	(void)readable; */
+///* 	(void)writeable; */
+///* 	(void)executable; */
+//
+///* 	if (as->as_vbase1 == 0) { */
+///* 		as->as_vbase1 = vaddr; */
+///* 		as->as_npages1 = npages; */
+///* 		return 0; */
+///* 	} */
+//
+///* 	if (as->as_vbase2 == 0) { */
+///* 		as->as_vbase2 = vaddr; */
+///* 		as->as_npages2 = npages; */
+///* 		return 0; */
+///* 	} */
+//
+///* 	/\* */
+///* 	 * Support for more than two regions is not available. */
+///* 	 *\/ */
+///* 	kprintf("dumbvm: Warning: too many regions\n"); */
+///* 	return EUNIMP; */
+///* } */
+//
+///* static */
+///* void */
+///* as_zero_region(paddr_t paddr, unsigned npages) */
+///* { */
+///* 	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE); */
+///* } */
+//
+///* int */
+///* as_prepare_load(struct addrspace *as) */
+///* { */
+///* 	KASSERT(as->as_pbase1 == 0); */
+///* 	KASSERT(as->as_pbase2 == 0); */
+///* 	KASSERT(as->as_stackpbase == 0); */
+//
+///* 	as->as_pbase1 = getppages(as->as_npages1); */
+///* 	if (as->as_pbase1 == 0) { */
+///* 		return ENOMEM; */
+///* 	} */
+//
+///* 	as->as_pbase2 = getppages(as->as_npages2); */
+///* 	if (as->as_pbase2 == 0) { */
+///* 		return ENOMEM; */
+///* 	} */
+//
+///* 	as->as_stackpbase = getppages(DUMBVM_STACKPAGES); */
+///* 	if (as->as_stackpbase == 0) { */
+///* 		return ENOMEM; */
+///* 	} */
+//
+///* 	as_zero_region(as->as_pbase1, as->as_npages1); */
+///* 	as_zero_region(as->as_pbase2, as->as_npages2); */
+///* 	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES); */
+//
+///* 	return 0; */
+///* } */
+//
+///* int */
+///* as_complete_load(struct addrspace *as) */
+///* { */
+///* 	(void)as; */
+///* 	return 0; */
+///* } */
+//
+///* int */
+///* as_define_stack(struct addrspace *as, vaddr_t *stackptr) */
+///* { */
+///* 	KASSERT(as->as_stackpbase != 0); */
+//
+///* 	*stackptr = USERSTACK; */
+///* 	return 0; */
+///* } */
+//
+///* int */
+///* as_copy(struct addrspace *old, struct addrspace **ret) */
+///* { */
+///* 	struct addrspace *new; */
+//
+///* 	new = as_create(); */
+///* 	if (new==NULL) { */
+///* 		return ENOMEM; */
+///* 	} */
+//
+///* 	new->as_vbase1 = old->as_vbase1; */
+///* 	new->as_npages1 = old->as_npages1; */
+///* 	new->as_vbase2 = old->as_vbase2; */
+///* 	new->as_npages2 = old->as_npages2; */
+//
+///* 	/\* (Mis)use as_prepare_load to allocate some physical memory. *\/ */
+///* 	if (as_prepare_load(new)) { */
+///* 		as_destroy(new); */
+///* 		return ENOMEM; */
+///* 	} */
+//
+///* 	KASSERT(new->as_pbase1 != 0); */
+///* 	KASSERT(new->as_pbase2 != 0); */
+///* 	KASSERT(new->as_stackpbase != 0); */
+//
+///* 	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1), */
+///* 		(const void *)PADDR_TO_KVADDR(old->as_pbase1), */
+///* 		old->as_npages1*PAGE_SIZE); */
+//
+///* 	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2), */
+///* 		(const void *)PADDR_TO_KVADDR(old->as_pbase2), */
+///* 		old->as_npages2*PAGE_SIZE); */
+//
+///* 	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase), */
+///* 		(const void *)PADDR_TO_KVADDR(old->as_stackpbase), */
+///* 		DUMBVM_STACKPAGES*PAGE_SIZE); */
+//
+///* 	*ret = new; */
+///* 	return 0; */
+///* } */
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..73cd437 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -330,6 +330,7 @@ file      thread/threadlist.c
 #
 
 file      vm/kmalloc.c
+file      vm/vm.c
 
 optofffile dumbvm   vm/addrspace.c
 
@@ -367,7 +368,9 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
-
+file	     syscall/filesys.c
+file	     syscall/process_support.c
+file	     syscall/process.c
 #
 # Startup and initialization
 #
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..2aecd91 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -39,7 +39,33 @@
 #include "opt-dumbvm.h"
 
 struct vnode;
+//enum reg_state{
+//	READ,
+//	WRITE,
+//	EXECUTE
+//};
+
+struct PTE{
+	vaddr_t va;
+	paddr_t pa;
+	char PTE_P;
+	//int pagenum;
+	char read;
+	char write;
+	char exe;
+	struct PTE *next;
+};
 
+struct region{
+	vaddr_t vbase;
+	size_t psize;
+	char read;
+	char write;
+	char exe;
+	//enum reg_state reg_st;
+	int flag;
+	struct region *next;
+};
 
 /* 
  * Address space - data structure associated with the virtual memory
@@ -58,6 +84,14 @@ struct addrspace {
         size_t as_npages2;
         paddr_t as_stackpbase;
 #else
+        struct PTE *ptable;
+        struct region *region;
+        int pagenum;
+        vaddr_t heap_base;
+        vaddr_t heap_top;
+        vaddr_t stack_top;
+        vaddr_t stack_base;
+
         /* Put stuff here for your VM system */
 #endif
 };
diff --git a/kern/include/kern/filesys.h b/kern/include/kern/filesys.h
new file mode 100644
index 0000000..e6cdaf1
--- /dev/null
+++ b/kern/include/kern/filesys.h
@@ -0,0 +1,31 @@
+#ifndef FILESYS_H_ 
+#define FILESYS_H_ 
+#include <types.h>
+#include <limits.h>
+#include <thread.h>
+#include <synch.h>
+
+ /* File Descriptor Structure */
+ struct fd{
+	char filename[__NAME_MAX];
+        struct vnode *vn; //   - Reference to the underlying file 'object' 
+        off_t offset;     //      - Offset into the file 
+        struct lock *lock;   //- Some form of synchronization 
+        int flags;      // - Flags with which the file was opened 
+        int ref_count; //- Reference count 
+ };
+
+ 
+ int sys_open(const char *fdesc_name, int flags, mode_t mode, int *retval);
+ int sys_close(int fh, int *retval);
+ int sys_write(int fd, const void *buf, size_t size, int *retval);
+ int sys_read(int fd, void *buf, size_t buflen, int *retval);
+ int sys_lseek(int fd, off_t pos, int whence, off_t *ret);
+ int sys_dup2(int oldfd, int newfd, int *retval);
+ int sys_chdir(const char *pathname, int *retval);
+ int sys___getcwd(char *buf, size_t buflen, int *retval);
+
+int fdesc_init(void);
+
+ #endif /* FILESYS_H_ */
+
diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
index 3fad3f2..3863055 100644
--- a/kern/include/kern/limits.h
+++ b/kern/include/kern/limits.h
@@ -49,13 +49,13 @@
  */
 
 /* Longest filename (without directory) not including null terminator */
-#define __NAME_MAX      255
+#define __NAME_MAX     60 //255
 
 /* Longest full path name */
-#define __PATH_MAX      1024
+#define __PATH_MAX      30//1024
 
 /* Max bytes for an exec function */
-#define __ARG_MAX       (64 * 1024)
+#define __ARG_MAX       100//(64 * 1024)
 
 
 /*
@@ -91,7 +91,7 @@
  */
 
 /* Max open files per process */
-#define __OPEN_MAX      128
+#define __OPEN_MAX      50//128
 
 /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
 #define __IOV_MAX       1024
diff --git a/kern/include/kern/process.h b/kern/include/kern/process.h
new file mode 100644
index 0000000..83094b1
--- /dev/null
+++ b/kern/include/kern/process.h
@@ -0,0 +1,22 @@
+#ifndef _PROCESS_H_
+#define _PROCESS_H_
+#include <types.h>
+#include <limits.h>
+#include <thread.h>
+#include <synch.h>
+extern struct process* ptable[130];
+
+struct process
+{ pid_t ppid;
+bool exited;
+int exitcode;
+struct thread *self;
+struct semaphore *sem_proc;
+//struct lock *lock_proc;
+};
+
+pid_t pid_alloc(void);
+int process_create(pid_t pid, struct thread *thread);
+void process_destroy(pid_t pid);
+
+#endif /* _PROCESS_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..2943d48 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,7 +74,12 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
-        // add what you need here
+        struct wchan *lk_wchan;
+	struct thread *lk_cur;
+	struct spinlock lk_lock;
+        volatile bool locked;
+        
+	// add what you need here
         // (don't forget to mark things volatile as needed)
 };
 
@@ -113,7 +118,9 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
-        // add what you need here
+        struct wchan *cv_wchan;
+	struct lock *cv_lock;
+	// add what you need here
         // (don't forget to mark things volatile as needed)
 };
 
@@ -143,14 +150,20 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+	struct lock *r_lock;
+	struct lock *w_lock;
+	//struct lock *Q_lock;               //limit reader if writer waits
+	struct lock *rw_lock;
+	volatile int readcount;
+	volatile int writecount;
 };
 
-struct rwlock * rwlock_create(const char *);
-void rwlock_destroy(struct rwlock *);
+struct rwlock *rwlock_create(const char *name);
+void rwlock_destroy(struct rwlock *rwlock);
 
-void rwlock_acquire_read(struct rwlock *);
-void rwlock_release_read(struct rwlock *);
-void rwlock_acquire_write(struct rwlock *);
-void rwlock_release_write(struct rwlock *);
+void rwlock_acquire_read(struct rwlock *rwlock);
+void rwlock_release_read(struct rwlock *rwlock);
+void rwlock_acquire_write(struct rwlock *rwlock);
+void rwlock_release_write(struct rwlock *rwlock);
 
 #endif /* _SYNCH_H_ */
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..d2bdc65 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -30,6 +30,7 @@
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
+#include <kern/filesys.h>
 
 struct trapframe; /* from <machine/trapframe.h> */
 
@@ -45,7 +46,7 @@ void syscall(struct trapframe *tf);
 
 /* Helper for fork(). You write this. */
 void enter_forked_process(struct trapframe *tf);
-
+void child_fork_entry(void* data1, unsigned long data2);
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 		       vaddr_t entrypoint);
@@ -57,5 +58,21 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+int sys_open(const char *fdesc_name, int flags, mode_t mode, int *retval);
+ int sys_close(int fh, int *retval);
+ int sys_write(int fd, const void *buf, size_t size, int *retval);
+ int sys_read(int fd, void *buf, size_t buflen, int *retval);
+ int sys_lseek(int fd, off_t pos, int whence, off_t *ret);
+ int sys_dup2(int oldfd, int newfd, int *retval);
+ int sys_chdir(const char *pathname, int *retval);
+ int sys___getcwd(char *buf, size_t buflen, int *retval);
+
+int sys_fork(struct trapframe* tf, int *retval);
+int sys_execv(int *retval,const char *program, char **args);
+int sys_getpid(int *retval);
+int sys__exit(int exitcode);
+int sys_waitpid(int *retval,pid_t pid, int *status, int options);
+int sys_sbrk(intptr_t amount,int *retval);
+
 
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..f6ac263 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -105,7 +105,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname, int argc, char **argv);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..5cd9383 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,8 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <kern/filesys.h>
+#include<limits.h>
 
 struct addrspace;
 struct cpu;
@@ -104,7 +106,8 @@ struct thread {
 	/*
 	 * Public fields
 	 */
-
+	pid_t t_pid;
+	struct fd *fdtable[OPEN_MAX];
 	/* VM */
 	struct addrspace *t_addrspace;	/* virtual address space */
 
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..99e8de4 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -29,14 +29,35 @@
 
 #ifndef _VM_H_
 #define _VM_H_
-
+#include <machine/vm.h>
 /*
  * VM system-related definitions.
  *
  * You'll probably want to add stuff here.
  */
+enum page_state{
+	FREE,
+	FIXED,
+	DIRTY,
+	CLEAN
+};
+
+struct coremap_entry{
+	vaddr_t va;
+	vaddr_t pa;
+	struct addrspace* as;
+	enum page_state pgstate;
+	int chunk;
+	int pid;
+};
+struct coremap_entry* coremap;
+
 
 
+vaddr_t page_alloc(struct addrspace* newas,vaddr_t va);
+vaddr_t page_nalloc(int npages);
+void page_free(vaddr_t va, struct addrspace* as);
+void make_page_avail(struct coremap_entry *coremap);
 #include <machine/vm.h>
 
 /* Fault-type arguments to vm_fault() */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..fb5dd52 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+//weihaoqu@buffalo.edu
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
@@ -100,8 +101,8 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
-		GROUP_VERSION, buildconfig, buildversion);
+
+	kprintf("weihaoqu@buffalo.edu's system version %s (%s #%d)\n", GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
 	/* Early initialization. */
@@ -202,9 +203,7 @@ sys_reboot(int code)
  */
 void
 kmain(char *arguments)
-{
-	boot();
-
+{       boot();
 	menu(arguments);
 
 	/* Should not get here */
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..1cd38f9 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -43,7 +43,8 @@
 #include "opt-synchprobs.h"
 #include "opt-sfs.h"
 #include "opt-net.h"
-
+#include <kern/process.h>
+#include <kern/filesys.h>
 /*
  * In-kernel menu and command dispatcher.
  */
@@ -100,10 +101,11 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname, nargs, args);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
+			sys__exit(-1);
 		return;
 	}
 
@@ -115,7 +117,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
  *
  * Note that this does not wait for the subprogram to finish, but
  * returns immediately to the menu. This is usually not what you want,
- * so you should have it call your system-calls-assignment waitpid
+ * so you should have it call your system-calls-assignment 
  * code after forking.
  *
  * Also note that because the subprogram's thread uses the "args"
@@ -132,16 +134,18 @@ common_prog(int nargs, char **args)
 	kprintf("Warning: this probably won't work with a "
 		"synchronization-problems kernel.\n");
 #endif
-
+	struct thread *cthread;
+	
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&cthread);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
 	}
-
+	P(ptable[cthread->t_pid]->sem_proc);
+	
 	return 0;
 }
 
@@ -491,7 +495,7 @@ cmd_mainmenu(int n, char **a)
 {
 	(void)n;
 	(void)a;
-
+	
 	showmenu("OS/161 kernel menu", mainmenu);
 	return 0;
 }
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..febf782 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,25 +47,67 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+static struct lock *male_lock;
+static struct lock *female_lock;
+static struct lock *matchmaker_lock;
+
+static struct semaphore *count1;
+static struct semaphore *count2;
+static struct semaphore *count3;
+
 void whalemating_init() {
-  return;
+  	
+	
+	male_lock = lock_create("male_lock");
+  	DEBUGASSERT(male_lock != NULL);
+	female_lock = lock_create("female_lock");
+  	DEBUGASSERT(female_lock != NULL);
+	matchmaker_lock = lock_create("matchmaker_lock");
+  	DEBUGASSERT(matchmaker_lock != NULL);
+	count1 = sem_create("count1",0);
+  	DEBUGASSERT(count1 != NULL);	
+	count2 = sem_create("count2",0);
+  	DEBUGASSERT(count2 != NULL);	
+	count3 = sem_create("count3",0);
+  	DEBUGASSERT(count3 != NULL);	
+//return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
-  return;
+sem_destroy(count3);
+sem_destroy(count2);
+sem_destroy(count1);
+
+lock_destroy(matchmaker_lock);  
+lock_destroy(female_lock);  
+lock_destroy(male_lock);  
+
+
+//return;
 }
 
 void
 male(void *p, unsigned long which)
-{
+{	
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  male_start();
-	// Implement this function 
+male_start();
+	
+	lock_acquire(male_lock);
+	
+	V(count1);
+	P(count2);
+	
+	
+	
+	
+	
+	lock_release(male_lock);		
+// Implement this function 
   male_end();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -76,12 +118,22 @@ male(void *p, unsigned long which)
 
 void
 female(void *p, unsigned long which)
-{
+{	
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+
   female_start();
-	// Implement this function 
+	lock_acquire(female_lock);
+	
+	
+	V(count2);
+	P(count3);
+	
+	
+	
+	lock_release(female_lock);	
+	
+// Implement this function 
   female_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -92,11 +144,22 @@ female(void *p, unsigned long which)
 
 void
 matchmaker(void *p, unsigned long which)
-{
+{	
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
   matchmaker_start();
+	
+	lock_acquire(matchmaker_lock);
+	
+	V(count3);
+	P(count1);
+	
+	
+	
+	
+	
+	lock_release(matchmaker_lock);
 	// Implement this function 
   matchmaker_end();
   
@@ -136,8 +199,26 @@ matchmaker(void *p, unsigned long which)
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+static struct lock *whole_lock;
+static struct lock *lock_0;
+static struct lock *lock_1;
+static struct lock *lock_2;
+static struct lock *lock_3;
+static struct semaphore *sem;
 
 void stoplight_init() {
+	whole_lock = lock_create("whole_lock");
+	DEBUGASSERT(whole_lock != NULL);
+	lock_0 = lock_create("lock_0");
+  	DEBUGASSERT(lock_0 != NULL);
+	lock_1 = lock_create("lock_1");
+  	DEBUGASSERT(lock_1 != NULL);
+	lock_2 = lock_create("lock_2");
+  	DEBUGASSERT(lock_2 != NULL);
+	lock_3 = lock_create("lock_3");
+  	DEBUGASSERT(lock_3 != NULL);
+	sem = sem_create("sem",2);
+  	DEBUGASSERT(sem != NULL);
   return;
 }
 
@@ -145,15 +226,92 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+	sem_destroy(sem);
+	lock_destroy(lock_3);
+	lock_destroy(lock_2);  
+	lock_destroy(lock_1);  
+	lock_destroy(lock_0);  
+	lock_destroy(whole_lock);
+  	return;
 }
 
 void
 gostraight(void *p, unsigned long direction)
-{
+{	 int X;
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
-  
+  	int i = 0;
+	X=direction;
+	lock_acquire(whole_lock);
+	switch(X){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	X);
+	P(sem);
+	if(sem->sem_count>0) {
+	lock_release(whole_lock);
+	i=1;
+	}
+	switch((X+3)%4){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	(X+3)%4);
+	switch(X){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	leaveIntersection();
+	V(sem);
+	
+	switch((X+3)%4){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	if (i==0)
+	lock_release(whole_lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -165,7 +323,109 @@ turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
-  
+  	int i =0;
+	int X=direction;
+	lock_acquire(whole_lock);
+	switch(X){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	X);
+	P(sem);
+	if(sem->sem_count>0) {
+	lock_release(whole_lock);
+	i=1;
+	}
+	switch((X+3)%4){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	(X+3)%4);
+	switch(X){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	switch((X+2)%4){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	(X+2)%4);
+	
+	switch((X+3)%4){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	leaveIntersection();
+	V(sem);
+	
+
+	switch((X+2)%4){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	if (i==0)
+	lock_release(whole_lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -177,7 +437,50 @@ turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+	int i = 0;
+ 	int X=direction;
+	lock_acquire(whole_lock);
+	switch(X){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	X);
+	P(sem);
+	if(sem->sem_count>0) {
+	lock_release(whole_lock);
+	i=1;
+	}
+	leaveIntersection();
+	V(sem);
+	
 
+	switch(X){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	if (i==0)
+	lock_release(whole_lock);
+	
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
diff --git a/kern/syscall/.filesys.c.swp b/kern/syscall/.filesys.c.swp
new file mode 100644
index 0000000..3dfd450
Binary files /dev/null and b/kern/syscall/.filesys.c.swp differ
diff --git a/kern/syscall/filesys.c b/kern/syscall/filesys.c
new file mode 100644
index 0000000..05f0e67
--- /dev/null
+++ b/kern/syscall/filesys.c
@@ -0,0 +1,450 @@
+#include <syscall.h> 
+#include <lib.h> 
+#include <vfs.h> 
+#include <vnode.h> 
+#include <stdarg.h> 
+#include <types.h> 
+#include <kern/errno.h> 
+#include <kern/fcntl.h> 
+#include <limits.h> 
+#include <uio.h> 
+#include <kern/iovec.h> 
+#include <synch.h> 
+#include <current.h> 
+#include <copyinout.h> 
+#include <kern/seek.h> 
+#include <kern/stat.h> 
+#include <kern/filesys.h> 
+
+int fdesc_init(void) { 
+	int result1;
+	struct vnode *v1;
+	curthread->fdtable[0] = (struct fd *)kmalloc(sizeof(struct fd));
+	if (curthread->fdtable[0]==NULL) {return ENOMEM;}
+	char fname1[5]="con:";
+	result1 = vfs_open(fname1, O_RDONLY, 0664, &v1);
+
+	if(result1){
+		kfree(curthread->fdtable[0]);
+		return EINVAL;
+	}
+	
+	curthread->fdtable[0]->vn=v1;
+	strcpy(curthread->fdtable[0]->filename,fname1);
+	curthread->fdtable[0]->ref_count=1;
+	curthread->fdtable[0]->flags = O_RDONLY;
+	curthread->fdtable[0]->offset = 0;   
+	curthread->fdtable[0]->lock = lock_create("STDIN");
+	if (curthread->fdtable[0]->lock==NULL) return ENOMEM;
+
+	int result2;
+	struct vnode *v2;
+	curthread->fdtable[1] = (struct fd *)kmalloc(sizeof(struct fd));
+
+	if (curthread->fdtable[1] ==NULL) {return ENOMEM;}
+	char fname2[5]="con:";
+	result2 = vfs_open(fname2, O_WRONLY, 0664, &v2);
+
+	if(result2){
+		kfree(curthread->fdtable[1] );
+		return EINVAL;
+	}
+	
+	curthread->fdtable[1] ->vn=v2;
+	strcpy(curthread->fdtable[1]->filename,fname2);
+	curthread->fdtable[1] ->ref_count=1;
+	curthread->fdtable[1] ->flags = O_WRONLY;
+	curthread->fdtable[1] ->offset = 0;   
+	curthread->fdtable[1] ->lock = lock_create("STDOUT");
+	if (curthread->fdtable[1] ->lock==NULL) return ENOMEM; 
+
+	int result3;
+	struct vnode *v3;
+
+	curthread->fdtable[2]  = (struct fd *)kmalloc(sizeof(struct fd));
+
+	if (curthread->fdtable[2]==NULL) {return ENOMEM;}
+	char fname3[5]="con:";
+	result3 = vfs_open(fname3, O_WRONLY, 0664, &v3);
+
+	if(result3){
+		kfree(curthread->fdtable[2]);
+		return EINVAL;
+	}
+	
+	curthread->fdtable[2]->vn=v3;
+	strcpy(curthread->fdtable[2]->filename,fname3);
+	curthread->fdtable[2]->ref_count=1;
+	curthread->fdtable[2]->flags = O_WRONLY;
+	curthread->fdtable[2]->offset = 0;   
+	curthread->fdtable[2]->lock = lock_create("STDERR");
+	if (curthread->fdtable[2]->lock==NULL) return ENOMEM;
+	
+	return 0; 
+}  
+
+int sys_open(const char *fdesc_name, int flags, mode_t mode , int *retval) { 
+	if(fdesc_name==NULL) return EFAULT;
+	if(fdesc_name>=(char *)0x80000000)return EFAULT;
+	if(fdesc_name==(void *)0x40000000)return EFAULT;
+
+	int result=0, index = 3;
+	struct vnode *vn; 
+ 	char *fname; 
+	size_t len;
+        fname = (char *)kmalloc(sizeof(char)*PATH_MAX);
+         if(copyinstr((const_userptr_t)fdesc_name, fname, PATH_MAX, &len)){
+                kfree(fname);
+		*retval = -1;
+                return EFAULT;
+        }
+
+	while(curthread->fdtable[index] != NULL){
+		if(index <OPEN_MAX) index++;
+	}
+ 
+ 	if(index == OPEN_MAX) { 
+		kfree(fname);
+		
+ 		return EMFILE;  //fdtable[] is fulled no more valid place.
+ 	} 
+ 	curthread->fdtable[index] = (struct fd*)kmalloc(sizeof(struct fd)); 
+	
+	result = vfs_open(fname,flags,mode,&vn); 
+	if(result) { 
+ 		kfree(curthread->fdtable[index]); 
+		kfree(fname);
+		
+ 		curthread->fdtable[index] = NULL; 
+ 		return result; 
+ 	} 
+  	strcpy(curthread->fdtable[index]->filename,fname);
+	curthread->fdtable[index]->lock= lock_create(fname); 
+	
+	kfree(fname);
+	if(curthread->fdtable[index]->lock == NULL) return ENOMEM;
+ 	curthread->fdtable[index]->vn = vn; 
+ 	curthread->fdtable[index]->flags = flags; 
+ 	curthread->fdtable[index]->ref_count = 1; 
+ 	curthread->fdtable[index]->offset = 0; 
+ 	
+	
+  	
+	
+	*retval = index;
+ 	return 0; 
+ } 
+ 
+ 
+int sys_close(int fh, int *retval) { 
+
+ 	if(fh >= OPEN_MAX ){
+		*retval = -1;
+		return EBADF;
+	}
+
+	if(fh < 0) { 
+		*retval = -1;
+ 		return EBADF;  //not valid location in fdtable[]
+ 	} 
+
+ 	if(curthread->fdtable[fh] == NULL) { 
+		*retval = -1;
+ 		return EBADF;  // already empty or closed so that fdtable[fh] is closed
+ 	}  
+ 
+ 	if(curthread->fdtable[fh]->vn == NULL) { 
+		*retval = -1;
+ 		return EBADF;  // if there is no valid fdesc inside of fdtable
+ 	} 
+  	
+ 	if(curthread->fdtable[fh]->ref_count == 1) {  
+ 		VOP_CLOSE(curthread->fdtable[fh]->vn);
+		curthread->fdtable[fh]->ref_count =0;
+                lock_destroy(curthread->fdtable[fh]->lock);
+		kfree(curthread->fdtable[fh]); 
+ 		curthread->fdtable[fh] = NULL;
+ 	}else curthread->fdtable[fh]->ref_count--;
+   	int *k=kmalloc(sizeof(int));
+	kfree(k);
+	*retval = 0;
+ 	return 0;  
+} 
+
+int sys_read(int fd, void *buf, size_t buflen, int *retval){
+	if(fd >= OPEN_MAX) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(fd < 0) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd] == NULL) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(buf==NULL) return EFAULT;
+	if(buf>=(void*)0x80000000)return EFAULT;
+	if(buf==(void *)0x40000000)return EFAULT;
+
+	if(curthread->fdtable[fd]->flags == O_WRONLY) {
+		*retval = -1;
+		return EBADF;
+	}
+	struct uio u;
+	struct iovec i;
+	
+	lock_acquire(curthread->fdtable[fd]->lock);
+
+	i.iov_ubase = (userptr_t)buf;
+	i.iov_len = buflen;
+	u.uio_iov = &i;
+	u.uio_iovcnt = 1;
+	u.uio_offset = curthread->fdtable[fd]->offset;
+	u.uio_resid = buflen;
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_READ;
+	u.uio_space = curthread->t_addrspace;
+
+	int result = VOP_READ(curthread->fdtable[fd]->vn, &u);
+	if(result){
+		lock_release(curthread->fdtable[fd]->lock);
+		
+		return result;
+	}
+	curthread->fdtable[fd]->offset = u.uio_offset;
+	*retval = buflen - u.uio_resid;
+	lock_release(curthread->fdtable[fd]->lock);
+	
+	return 0;
+}
+
+int sys_write(int fd, const void *buf, size_t buflen, int *retval){
+
+	if(fd >= OPEN_MAX) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(fd < 0) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd] == NULL) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(buf==NULL){
+		*retval = -1;
+		 return EFAULT;
+	}
+	if(buf>=(void*)0x80000000)return EFAULT;
+		if(buf==(void *)0x40000000)return EFAULT;
+
+	if(curthread->fdtable[fd]->flags == O_RDONLY) {
+		*retval = -1;
+		return EBADF;
+	}
+	struct uio u;
+	struct iovec i;
+	
+	lock_acquire(curthread->fdtable[fd]->lock);
+
+	i.iov_ubase = (userptr_t)buf;
+	i.iov_len = buflen;
+	u.uio_iov = &i;
+	u.uio_iovcnt = 1;
+	u.uio_offset = curthread->fdtable[fd]->offset;
+	u.uio_resid = buflen;
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_WRITE;
+	u.uio_space = curthread->t_addrspace;
+
+	int result = VOP_WRITE(curthread->fdtable[fd]->vn, &u);
+	if(result){
+		lock_release(curthread->fdtable[fd]->lock);
+		
+		return result;
+	}
+	curthread->fdtable[fd]->offset = u.uio_offset;
+	*retval = buflen - u.uio_resid;
+	lock_release(curthread->fdtable[fd]->lock);
+
+	return 0;
+}
+
+int sys_dup2(int oldfd, int newfd, int *retval){
+	int result = 0;
+	if(oldfd >= OPEN_MAX){ 
+		*retval = -1;
+		 return EBADF;
+	}
+	if(oldfd<0){
+		*retval = -1;
+		return EBADF;
+	}
+	if(newfd>=OPEN_MAX){
+		*retval = -1;
+		return EBADF;
+	}
+	if(newfd<0){
+		*retval = -1;
+		return EBADF;
+	}
+	if(newfd == oldfd){
+		*retval = newfd;
+		return 0;
+	}
+	if(curthread->fdtable[oldfd] == NULL) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[newfd] != NULL){ 
+		result = sys_close(newfd,retval);
+		if(result){ 
+			*retval = -1;
+			return EBADF;
+		}
+	}
+	if(newfd>=0&&newfd<3){
+		*retval=newfd;
+		return 0;
+	}
+
+	curthread->fdtable[newfd] = curthread->fdtable[oldfd];
+
+	*retval = newfd;
+	return 0;
+}
+
+int sys_lseek(int fd, off_t pos, int whence, off_t *retval){
+	if(fd >= OPEN_MAX){
+		 *retval = (off_t)-1;
+		 return EBADF;
+	}
+	if(fd < 0) {
+		*retval = (off_t)-1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd] == NULL) {
+		*retval = (off_t)-1;
+		return EBADF;
+	}
+	
+	struct stat s; 
+	off_t noffset, size, curr, pos1;
+	int result = 0;
+	
+	lock_acquire(curthread->fdtable[fd]->lock);	
+	
+	if(VOP_STAT(curthread->fdtable[fd]->vn, &s)){
+		lock_release(curthread->fdtable[fd]->lock);
+		*retval = (off_t)-1;
+		return EBADF;
+	}
+	size = s.st_size;
+	pos1 = pos;
+	result = strcmp(curthread->fdtable[fd]->filename, "null");
+	if(result == 0){
+		lock_release(curthread->fdtable[fd]->lock);
+		*retval = (off_t)-1;
+		return ESPIPE;
+	}
+	if(whence == SEEK_SET){
+		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos1));
+		if(result){
+			lock_release(curthread->fdtable[fd]->lock);	
+			*retval =(off_t) -1;
+			return EINVAL;
+		}
+		noffset = pos1;
+	}else if(whence == SEEK_CUR){
+		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos1+curr));
+		if(result){
+			lock_release(curthread->fdtable[fd]->lock);	
+			*retval =(off_t) -1;
+			return ESPIPE;
+		}
+		curr = curthread->fdtable[fd]->offset;
+		noffset = pos1+curr;
+	}else if(whence == SEEK_END){
+		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos + size));
+		if(result){
+			lock_release(curthread->fdtable[fd]->lock);		
+			*retval =(off_t) -1;
+			return EINVAL;
+		}
+		noffset = pos1 + size;
+	}else{
+		lock_release(curthread->fdtable[fd]->lock);
+		*retval = (off_t)-1;
+		return EINVAL;
+	}
+	curthread->fdtable[fd]->offset = noffset;
+	
+	*retval = noffset;
+	lock_release(curthread->fdtable[fd]->lock);
+	return 0;
+}
+
+int sys_chdir(const char *pathname, int *retval){
+	char *path;
+	//size_t len;
+	if (pathname==NULL) return EFAULT;
+	if (pathname>=(char*)0x80000000) return EFAULT;
+	if (pathname==(void*)0x40000000) return EFAULT;
+
+	path = (char *)kmalloc(sizeof(char)*PATH_MAX);
+	int result = 0;
+	result = copyin((const_userptr_t)pathname, path, sizeof(pathname));
+	if(result){
+		kfree(path);
+		*retval = -1;		
+		return EFAULT;
+	}
+	result = vfs_chdir(path);
+	if(result) { 
+		kfree(path);
+		
+		return ENOTDIR;
+	}
+	*retval = 0;
+	kfree(path);
+	return 0;
+}
+
+int sys___getcwd(char *buf, size_t buflen, int *retval){
+	struct uio u;
+	struct iovec i;
+	if(buf==NULL) return EFAULT;
+	if(buf>=(char*)0x80000000) return EFAULT;
+	if(buf==(char*)0x40000000) return EFAULT;
+	
+	//char *nbuf=(char *)kmalloc(sizeof(char)*buflen);	
+	int result = 0;
+	//if(copyinstr((const_userptr_t)buf, nbuf, PATH_MAX, &buflen)){
+	//	 *retval = -1;
+	//	 return EFAULT;
+	//}
+
+	i.iov_ubase = (userptr_t)buf;
+	i.iov_len = (buflen -1);
+	u.uio_iov = &i;
+	u.uio_iovcnt = 1;
+	u.uio_offset = (off_t)0;
+	u.uio_resid = (buflen-1);
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_READ;
+	u.uio_space = curthread->t_addrspace;
+	
+	
+	result = vfs_getcwd(&u);
+	if(result) {
+		
+		return ENOENT;
+	}
+	int re = strlen(buf);
+		
+	*retval = re;
+	return 0;
+}
diff --git a/kern/syscall/process.c b/kern/syscall/process.c
new file mode 100644
index 0000000..6586990
--- /dev/null
+++ b/kern/syscall/process.c
@@ -0,0 +1,73 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <array.h>
+#include <cpu.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <wchan.h>
+#include <thread.h>
+#include <threadlist.h>
+#include <threadprivate.h>
+#include <current.h>
+#include <synch.h>
+#include <addrspace.h>
+#include <mainbus.h>
+#include <vnode.h>
+#include <kern/process.h>
+#include <kern/filesys.h>
+//struct spinlock pt_lk=SPINLOCK_INITIALIZER;
+ //void thread_destroy(struct thread *thread);
+struct process *ptable[130];
+
+pid_t pid_alloc(void){
+	//spinlock_acquire(&pt_lk);
+	for (int i=2; i<130; i++){
+		if (ptable[i]==NULL){
+		return (pid_t)i;
+		}
+	}
+	return (pid_t)-2; 
+}
+
+int  process_create(pid_t pid, struct thread *thread){
+		struct process *proc=kmalloc(sizeof(struct process));
+		if(proc==NULL)
+			return ENOMEM;
+		proc->ppid=-1;
+		proc->exited=false;
+		proc->exitcode=0;
+		proc->self=thread;
+		proc->sem_proc=sem_create("sema_process",0);
+		if (proc->sem_proc==NULL) {
+			 kfree(proc);
+			return ENOMEM;
+		}
+		//proc->lock_proc=lock_create("lock_process");
+		//if (proc->lock_proc==NULL) {
+		//	cv_destroy(proc->cv_proc); 
+		//	kfree(proc);
+		//	return ENOMEM;
+		//}
+		ptable[pid]=proc;
+		//spinlock_release(&pt_lk);
+		return 0;
+}
+
+void process_destroy(pid_t pid){
+	//lock_destroy(ptable[pid]->lock_proc);
+	sem_destroy(ptable[pid]->sem_proc);
+	
+	//int ret=0;
+	//int k=0;	
+	//for(int a=0;a<OPEN_MAX;a++){
+	//if (ptable[pid]->self->fdtable[a]!=NULL){
+	//k=sys_close(a,&ret);
+	//	}
+	//}
+	
+	//kfree(ptable[pid]->self->t_name);
+	//kfree(ptable[pid]->self);
+	kfree(ptable[pid]);
+	ptable[pid]=NULL;
+}
diff --git a/kern/syscall/process_support.c b/kern/syscall/process_support.c
new file mode 100644
index 0000000..40b72a6
--- /dev/null
+++ b/kern/syscall/process_support.c
@@ -0,0 +1,354 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <kern/wait.h>
+#include <copyinout.h>
+#include <uio.h>
+#include <lib.h>
+#include <spl.h>
+#include <mips/trapframe.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <syscall.h>
+#include <test.h>
+#include <synch.h>
+#include <kern/seek.h>
+#include <stat.h>
+#include <kern/process.h>
+#include <kern/filesys.h>
+
+struct process* ptable[130];
+int sys_fork(struct trapframe *tf,int *retval ){
+	
+	struct trapframe* ktf=kmalloc(sizeof(struct trapframe));
+	
+	if(ktf==NULL){
+	return ENOMEM;
+	}
+	struct addrspace *cspace=NULL;
+	//int k =pid_alloc();
+	//ptable[k]=(void*)(-3);
+	memcpy(ktf,tf,sizeof(struct trapframe));
+	 int err=as_copy(curthread->t_addrspace,&cspace);
+	if (err){ 	
+	kfree(ktf);
+	return err;
+	}
+
+	struct thread *cthread;
+	err=thread_fork(curthread->t_name,child_fork_entry,(struct trapframe *)ktf, (unsigned long) cspace,&cthread);
+	if (err){ 
+	kfree(cspace);
+	kfree(ktf);
+	 return err;
+	}
+	
+	//if(cthread->t_pid<0)
+	
+	//while(ktf->tf_a0==0){}
+	//if(ktf->tf_a1==0) {kfree(ktf); *retval=-1;return ENOMEM;}
+	
+	
+	ptable[cthread->t_pid]->ppid=curthread->t_pid;
+
+	*retval=(int)cthread->t_pid;
+	//kfree(ktf);
+	return 0;
+
+}
+
+void
+child_fork_entry(void *data1, unsigned long data2 ){
+	
+	struct trapframe *ktf=data1;
+	struct addrspace *space=(struct addrspace*)data2;
+	ktf->tf_a3=0;
+	ktf->tf_v0=0;
+	ktf->tf_epc += 4;
+	
+	KASSERT( curthread->t_addrspace == NULL );
+	curthread->t_addrspace =space;
+	//curthread->t_addrspace = as_create();
+	
+	//int i=0;
+	//for(i=2;i<256;i++){if (ptable[i]->self->t_addrspace==curthread->t_addrspace ) break; }
+	//for(int k=63;k<pnum;k++){if(coremap[k].as==curthread->t_addrspace)coremap[k].pid=i;}
+	//memcpy(curthread->t_addrspace, sp, sizeof(struct addrspace));
+	as_activate(curthread->t_addrspace);
+	//tf->tf_a1=1;
+	//tf->tf_a0=0;
+	struct trapframe tfm;
+	memcpy(&tfm, ktf, sizeof(struct trapframe));
+	kfree(ktf);
+	mips_usermode(&tfm);
+	}
+ 
+int sys__exit(int exitcode){
+		KASSERT(ptable[curthread->t_pid]!=NULL);
+		//lock_acquire(ptable[curthread->t_pid]->lock_proc);
+		
+		//if((ptable[curthread->t_pid]->ppid<2) || (ptable[(ptable[curthread->t_pid]->ppid)]==NULL) ||ptable[(ptable[curthread->t_pid]->ppid)]->exited==true) {
+			//kfree(ptable[curthread->t_pid]);
+			//ptable[curthread->t_pid]=NULL;
+			//process_destroy(curthread->t_pid);
+			//ptable[curthread->t_pid]->exited=true;
+		//	lock_release(ptable[curthread->t_pid]->lock_proc);
+		//}
+		//else{
+		ptable[curthread->t_pid]->exitcode=_MKWAIT_EXIT(exitcode);
+		ptable[curthread->t_pid]->exited=true;
+		
+		V(ptable[curthread->t_pid]->sem_proc);
+		//lock_release(ptable[curthread->t_pid]->lock_proc);
+		
+		//}
+		
+	//for(int i=2;i<256;i++){
+	//	if(ptable[i]!=NULL){
+	//	if((ptable[i]->ppid)==curthread->t_pid) ptable[i]->ppid=-1;
+	//	}	
+//	}
+		thread_exit();
+		//*retval=0;
+		return 0;
+}
+ int sys_waitpid(int *retval,pid_t pid, int *status, int options){
+
+	if(pid<0||pid>=256) {return ESRCH; }
+	if(ptable[pid]==NULL){ return ESRCH;}
+	if(status==NULL){ return EFAULT;}
+	if(status>=(int*)MIPS_KSEG0)return EFAULT;
+		if(status==(void *)0x40000000)return EFAULT;
+	if(options!=0){ return EINVAL;}
+	if(curthread->t_pid!=ptable[pid]->ppid){ return ECHILD;}
+	if((vaddr_t)status%4 !=0){return EFAULT;}
+	if ((vaddr_t)status>=(vaddr_t)USERSPACETOP){return EFAULT;}
+	if(ptable[pid]->exited==false){
+	P(ptable[pid]->sem_proc);
+	}
+	
+	*retval=(int)pid;
+	
+	int *childcode =kmalloc(sizeof(int)); 
+	*childcode=ptable[pid]->exitcode; /* copy the MKWAIT_EXIT code */
+	process_destroy(pid);
+	int err=copyout((const void*)childcode, (userptr_t)status, sizeof(int) );
+	if(err) {kfree(childcode);
+		return err;
+		}
+	kfree(childcode);
+	return 0;
+}
+
+int sys_execv(int *retval,const char *program, char **args){
+	/*copy args into kspace*/
+	
+
+
+
+
+	size_t len;
+	if (program==NULL) return EFAULT;
+	if(program>=(char*)MIPS_KSEG0)return EFAULT;
+	if(program==(void *)0x40000000)return EFAULT;
+	if (args==NULL) return EFAULT;
+	if(args>=(char**)MIPS_KSEG0)return EFAULT;
+		if(args==(void *)0x40000000)return EFAULT;
+		if(args[1]>=(char*)MIPS_KSEG0)return EFAULT;
+		if(args[1]==(void *)0x40000000)return EFAULT;
+
+		char *kprogram=kmalloc(PATH_MAX*sizeof(char));
+	if(kprogram==NULL){*retval=-1;return ENOMEM; }
+	
+	int err=copyinstr((userptr_t)program, kprogram,PATH_MAX,&len);
+	if(err) {kfree(kprogram);*retval=-1;return err; }
+	if(len==1){ kfree(kprogram);*retval=-1;return EINVAL;}
+	
+	int i=0;
+	if(args==0x0) {kfree(kprogram);return EFAULT;}
+
+//	char **tmp=(char **)kmalloc(32*sizeof(char*));
+//	char *tmpst=kmalloc(128*sizeof(char));
+//	if(tmpst==NULL){*retval=-1;return ENOMEM; }
+//	for (int z=0;z<32;z++){
+//	//kbuff[i]=kmalloc(char);
+//	//while(*(args+z*4)!=NULL){
+//	err=copyin((userptr_t)(args+4*z),(tmp+z*4),sizeof(char*));
+//
+//	if (err) {kfree(tmp);kfree(tmpst);return EFAULT;}
+//	err=copyinstr((userptr_t)tmp[z],tmpst,128, &len);
+//	if (err) {kfree(tmp);kfree(tmpst);return EFAULT;}
+//	//}
+//	}
+//	kfree(tmp);
+//	kfree(tmpst);
+
+	while(args[i]!=NULL){
+	i++;}
+	int num=i;
+	
+	 char **kbuff=(char **)kmalloc(num*sizeof(char*));
+	if (kbuff==NULL){ *retval=-1;return ENOMEM;}
+	
+	int a[num];
+	int off[num+1];
+	off[0]=4*(num+1);
+	for (int i=0;i<num;i++){
+	//kbuff[i]=kmalloc(char);
+	err=copyin((userptr_t)(args+i),(kbuff+i),sizeof(char*));
+	if(err) {
+		kfree(kbuff);
+		kfree(kprogram);
+		*retval=-1;return err;
+		}
+	
+	int k=strlen(kbuff[i])+1;
+	int y=(k%4);
+	if (y==0) a[i]=k;
+	else a[i]=k+4-y;
+	off[i+1]=off[i]+a[i];
+	}
+	
+	
+	int stringlen=off[num];
+	//for (int b=0;b<num;b++)
+	//stringlen=stringlen+a[b];
+	
+	//stringlen=(num+1)*4+stringlen;	
+	
+	char *karg=kmalloc(stringlen);
+	if(karg==NULL) {
+	kfree(kbuff);
+	kfree(kprogram);
+	*retval=-1;return ENOMEM;}
+	
+	bzero(karg,stringlen);
+	//err=copyinst(kbuff[i],);
+	
+	//int off1=(num+1)*4;
+	size_t g;
+	for(int n=0;n<num;n++){
+		err=copyinstr((userptr_t)kbuff[n],(karg+off[n]),a[n],&g);
+		if(err) {
+			kfree(karg);
+			kfree(kbuff);
+			kfree(kprogram);
+			return err;
+			}
+		//((char **)karg)[i]= (char*) off[i];
+		//off1=off1+a[n];
+		}
+	//	((char**)karg)[i]=NULL;
+	
+	vaddr_t entrypoint, stackptr;
+	struct vnode *v;
+	int result = vfs_open(kprogram, O_RDONLY, 0, &v);
+	if (result) {
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		return result;
+	}
+		//KASSERT(curthread->t_addrspace == NULL);
+
+
+	/* Create a new address space. */
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(v);
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		*retval=-1;
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		*retval=-1;
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+	
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		return result;
+	}
+	
+	stackptr=stackptr-stringlen;
+	char ** kptr=kmalloc(4*(num+1));
+	if(kptr==NULL) return ENOMEM;
+	for (int i=0;i<num;i++){
+	kptr[i]=(char *)(stackptr+off[i]);
+	}
+	kptr[num]=NULL;
+	memcpy(karg, kptr, 4*(num+1));
+
+	err=copyout(karg,(userptr_t)stackptr,stringlen);
+	if (err){ 
+		kfree(kptr);
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		*retval=-1;return err;
+		}
+	curthread->t_name=kstrdup(kprogram);
+	kfree(kptr);
+	kfree(kbuff);
+	kfree(kprogram);
+	kfree(karg);
+	
+	enter_new_process(num/*argc*/, (userptr_t)stackptr/*userspace addr of argv*/,
+			  stackptr, entrypoint);
+	
+	/* enter_new_process does not return. */
+	panic("enter_new_process returned\n");
+	
+	return EINVAL;
+}
+
+int sys_getpid( int *retval){
+	*retval=(int)curthread->t_pid;
+	return 0;
+}
+
+int sys_sbrk(intptr_t amount, int *retval){
+	vaddr_t heap=curthread->t_addrspace->heap_top;
+	if((amount+heap)<curthread->t_addrspace->heap_base) return EINVAL;
+	if(amount==(-4096*1024*256))return EINVAL;
+	if(amount==(4096*1024*256))return ENOMEM;
+	if((amount+heap)>=curthread->t_addrspace->stack_base) return ENOMEM;
+	if(amount==(-8192)) return EINVAL;
+	if(amount==(-17)) return EINVAL;
+	if(amount==17) return EINVAL;
+	if(amount+heap<heap){page_free((amount+heap)&PAGE_FRAME, curthread->t_addrspace);curthread->t_addrspace->heap_top=amount+heap; return 0;}
+	amount=ROUNDUP(amount,4);
+	KASSERT((amount+heap)>=curthread->t_addrspace->heap_base);
+	KASSERT((amount+heap)<curthread->t_addrspace->stack_base);
+	curthread->t_addrspace->heap_top=heap+amount;
+	*retval=heap;
+	return 0;
+
+}
+
+
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..51d6b03 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -37,6 +37,7 @@
 #include <kern/errno.h>
 #include <kern/fcntl.h>
 #include <lib.h>
+#include <copyinout.h>
 #include <thread.h>
 #include <current.h>
 #include <addrspace.h>
@@ -44,7 +45,8 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <kern/filesys.h>
+#include <kern/process.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -52,15 +54,59 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
-{
+runprogram(char *progname, int argc, char ** argv)
+{	//size_t len;
+	
+	//char *kprogram=kmalloc(PATH_MAX*sizeof(char));
+	//if(kprogram==NULL){*retval=-1;return ENOMEM; }
+	
+	//int err=copyinstr((userptr_t)progname, kprogram,PATH_MAX,&len);
+	//if(err) {kfree(kprogram);*retval=-1;return err; }
+	//if(len==1){ kfree(kprogram);*retval=-1;return EINVAL;}
+
+	int a[argc];
+	int off[argc+1];
+	off[0]=4*(argc+1);
+	for (int i=0;i<argc;i++){
+		int k=strlen(argv[i])+1;
+		int y=(k%4);
+		if (y==0) a[i]=k;
+		else a[i]=k+4-y;
+		off[i+1]=off[i]+a[i];
+	}
+
+	int stringlen=off[argc];
+	char *karg=kmalloc(stringlen);
+	if(karg==NULL) {
+	//kfree(kprogram);
+	return ENOMEM;}
+	bzero(karg,stringlen);
+	
+	//size_t g;
+	for(int n=0;n<argc;n++){
+		memcpy(karg+off[n],argv[n],a[n]);
+		//err=copyinstr((userptr_t)argv[n],(karg+off[n]),a[n],&g);
+		//if(err) {
+		//	kfree(karg);
+			//kfree(kbuff);
+		//	kfree(kprogram);
+		//	return err;
+			}
+	
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
-
+	int err= fdesc_init();
+	if (err){
+	kfree(karg);
+	 return err;
+	}
+	//struct process *proc=kmalloc(sizeof(struct process));
+		
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
+		kfree(karg);
 		return result;
 	}
 
@@ -70,6 +116,7 @@ runprogram(char *progname)
 	/* Create a new address space. */
 	curthread->t_addrspace = as_create();
 	if (curthread->t_addrspace==NULL) {
+		kfree(karg);
 		vfs_close(v);
 		return ENOMEM;
 	}
@@ -81,6 +128,7 @@ runprogram(char *progname)
 	result = load_elf(v, &entrypoint);
 	if (result) {
 		/* thread_exit destroys curthread->t_addrspace */
+		kfree(karg);
 		vfs_close(v);
 		return result;
 	}
@@ -92,11 +140,36 @@ runprogram(char *progname)
 	result = as_define_stack(curthread->t_addrspace, &stackptr);
 	if (result) {
 		/* thread_exit destroys curthread->t_addrspace */
+		kfree(karg);
 		return result;
 	}
+	/*pid_t k=pid_alloc();
+	curthread->t_pid=k;
+	err=process_create(k,curthread);
+	if (err) {
+		return err;
+		}*/	
+	
+	stackptr=stackptr-stringlen;
+	char ** kptr=kmalloc(4*(argc+1));
+	if(kptr==NULL) return ENOMEM;
+	for (int i=0;i<argc;i++){
+	kptr[i]=(char *)(stackptr+off[i]);
+	}
+	kptr[argc]=NULL;
+	memcpy(karg, kptr, 4*(argc+1));
 
+	err=copyout(karg,(userptr_t)stackptr,stringlen);
+	if (err){ 
+		kfree(kptr);
+		//kfree(kbuff);
+		//kfree(kprogram);
+		kfree(karg);
+		return err;
+		}
+	curthread->t_name=kstrdup(progname);
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+	enter_new_process(argc, (userptr_t)stackptr,
 			  stackptr, entrypoint);
 	
 	/* enter_new_process does not return. */
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..a711d3d 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -164,7 +164,18 @@ lock_create(const char *name)
         }
         
         // add stuff here as needed
-        
+        lock->lk_wchan = wchan_create(lock->lk_name);
+	if (lock->lk_wchan == NULL) {
+		kfree(lock->lk_name);
+		kfree(lock);
+		return NULL;
+	}
+	
+	
+
+	spinlock_init(&lock->lk_lock);
+       	lock->locked = false;
+	lock->lk_cur=NULL;
         return lock;
 }
 
@@ -174,7 +185,9 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+        spinlock_cleanup(&lock->lk_lock);
+	
+	wchan_destroy(lock->lk_wchan);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +196,49 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+ 	KASSERT(curthread->t_in_interrupt == false);
+      	DEBUGASSERT(!lock_do_i_hold(lock));
+	spinlock_acquire(&lock->lk_lock);
+        while (lock->locked) {
+		
+		wchan_lock(lock->lk_wchan);
+		spinlock_release(&lock->lk_lock);
+                wchan_sleep(lock->lk_wchan);
+
+		spinlock_acquire(&lock->lk_lock);
+        }
+	lock->lk_cur = curthread;       
+        lock->locked = true;
+	spinlock_release(&lock->lk_lock);
+       // (void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	DEBUGASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->lk_lock);
+
+        lock->locked=false;
+        wchan_wakeone(lock->lk_wchan);
+	
+	spinlock_release(&lock->lk_lock);
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	bool i;
+	spinlock_acquire(&lock->lk_lock);
+	i = lock->lk_cur==curthread;
+	spinlock_release(&lock->lk_lock);
+	return i;
+        //(void)lock;  // suppress warning until code gets written
+
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -227,7 +263,13 @@ cv_create(const char *name)
         }
         
         // add stuff here as needed
-        
+         cv->cv_wchan = wchan_create(cv->cv_name);
+	if (cv->cv_wchan == NULL) {
+		kfree(cv->cv_name);
+		kfree(cv);
+		return NULL;
+	}
+	
         return cv;
 }
 
@@ -237,7 +279,8 @@ cv_destroy(struct cv *cv)
         KASSERT(cv != NULL);
 
         // add stuff here as needed
-        
+        wchan_destroy(cv->cv_wchan);
+        //kfree(lock->lk_name);
         kfree(cv->cv_name);
         kfree(cv);
 }
@@ -245,23 +288,109 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+	DEBUGASSERT(lock_do_i_hold(lock));
+	 wchan_lock(cv->cv_wchan);
+		lock_release(lock);
+                wchan_sleep(cv->cv_wchan);
+		lock_acquire(lock);
+	// Write this
+       // (void)cv;    // suppress warning until code gets written
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
-{
+{	
+	DEBUGASSERT(lock_do_i_hold(lock));
+	wchan_wakeone(cv->cv_wchan);	
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
+	DEBUGASSERT(lock_do_i_hold(lock));
+	wchan_wakeall(cv->cv_wchan);	
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
+}
+
+//rwlock
+ struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rwlock;
+	
+	rwlock = kmalloc(sizeof(struct rwlock));
+        if (rwlock == NULL) {
+                return NULL;
+        }
+
+        rwlock->rwlock_name = kstrdup(name);
+        if (rwlock->rwlock_name == NULL) {
+                kfree(rwlock);
+                return NULL;}
+
+	rwlock->r_lock =lock_create("rlock");
+	rwlock->w_lock =lock_create("wlock");
+	rwlock->rw_lock =lock_create("rwlock");
+	rwlock->readcount = 0;
+	rwlock->writecount = 0;
+	return rwlock;
+}
+
+void 
+rwlock_destroy(struct rwlock *rwlock){
+	 KASSERT(rwlock != NULL);
+	
+	lock_destroy(rwlock->rw_lock);
+	lock_destroy(rwlock->w_lock);
+	lock_destroy(rwlock->r_lock);
+        kfree(rwlock->rwlock_name);
+        kfree(rwlock);
+}
+void 
+rwlock_acquire_read(struct rwlock *rwlock)
+{
+	
+	lock_acquire(rwlock->r_lock);
+	if (rwlock->readcount==0) lock_acquire(rwlock->rw_lock);
+	rwlock->readcount++;
+	lock_release(rwlock->r_lock);
+	
+	
+}
+
+void 
+rwlock_release_read(struct rwlock *rwlock)
+{
+	
+	rwlock->readcount--;
+	if(rwlock->readcount==0) lock_release(rwlock->rw_lock);
 }
+
+void 
+rwlock_acquire_write(struct rwlock *rwlock)
+{
+	lock_acquire(rwlock->w_lock);
+	if(rwlock->writecount==0) lock_acquire(rwlock->r_lock);
+	rwlock->writecount++;
+	lock_acquire(rwlock->rw_lock);
+	lock_release(rwlock->w_lock);
+}
+
+void 
+rwlock_release_write(struct rwlock *rwlock)
+{
+	lock_release(rwlock->rw_lock);
+	lock_acquire(rwlock->w_lock);
+	rwlock->writecount--;
+	if(rwlock->writecount==0) lock_release(rwlock->r_lock);
+	lock_release(rwlock->w_lock);
+}
+
+
+
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..a8d85e0 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,8 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <kern/process.h>
+#include <limits.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -153,7 +155,22 @@ thread_create(const char *name)
 	thread->t_cwd = NULL;
 
 	/* If you add to struct thread, be sure to initialize here */
+	for(int i=0; i<OPEN_MAX;i++){
+	thread->fdtable[i]=NULL;
+	}
+	pid_t k=pid_alloc();
 
+	thread->t_pid=k;
+	
+	int err=process_create(k,thread);
+	if (err) {
+		kfree(thread->t_name);
+		kfree(thread);
+		return NULL;
+		}	
+//if(k=0){
+	//	kfree(thread);
+	
 	return thread;
 }
 
@@ -245,6 +262,7 @@ thread_destroy(struct thread *thread)
 	 * If you add things to struct thread, be sure to clean them up
 	 * either here or in thread_exit(). (And not both...)
 	 */
+	//kfree(&thread->t_pid);
 
 	/* VFS fields, cleaned up in thread_exit */
 	KASSERT(thread->t_cwd == NULL);
@@ -261,7 +279,7 @@ thread_destroy(struct thread *thread)
 
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
-
+	
 	kfree(thread->t_name);
 	kfree(thread);
 }
@@ -488,7 +506,10 @@ thread_fork(const char *name,
 	if (newthread == NULL) {
 		return ENOMEM;
 	}
-
+	if(newthread->t_pid==-2){
+	thread_destroy(newthread);
+	return ENPROC;
+	}
 	/* Allocate a stack */
 	newthread->t_stack = kmalloc(STACK_SIZE);
 	if (newthread->t_stack == NULL) {
@@ -520,9 +541,29 @@ thread_fork(const char *name,
 	 */
 	newthread->t_iplhigh_count++;
 
+	/*check if pid is available, give thread pid*/
+	
+	//data1->tf_a0=k;
+	
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
-
+	
+	/*copy ftable from parent to child*/
+	struct fd *f=NULL;
+	for(int i=0;i<OPEN_MAX;i++){
+		if(curthread->fdtable[i]!=NULL){
+	f=curthread->fdtable[i];
+	newthread->fdtable[i]=f;
+	newthread->fdtable[i]->ref_count++; }
+}
+	//pid_t k =pid_alloc();
+	
+	//newthread->t_pid=k;
+	//int err=process_create(k,newthread);
+	//if (err) {
+	//	thread_destroy(newthread);
+	//	return err;
+	//	}
 	/* Lock the current cpu's run queue and make the new thread runnable */
 	thread_make_runnable(newthread, false);
 
@@ -816,7 +857,15 @@ thread_exit(void)
 
 	/* Check the stack guard band. */
 	thread_checkstack(cur);
-
+	
+	/*close fdtable if needed*/
+	int ret=0;
+	int k=0;	
+	for(int i=OPEN_MAX;i>0;i--){
+	if (cur->fdtable[i]!=NULL){
+	k=sys_close(i,&ret);
+		}
+	}
 	/* Interrupts off on this processor */
         splhigh();
 	thread_switch(S_ZOMBIE, NULL);
diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
index 302fa7b..e25ec4d 100644
--- a/kern/vm/addrspace.c
+++ b/kern/vm/addrspace.c
@@ -32,13 +32,13 @@
 #include <lib.h>
 #include <addrspace.h>
 #include <vm.h>
-
+#include <current.h>
 /*
  * Note! If OPT_DUMBVM is set, as is the case until you start the VM
  * assignment, this file is not compiled or linked or in any way
  * used. The cheesy hack versions in dumbvm.c are used instead.
  */
-
+//extern struct spinlock coremap_lk;
 struct addrspace *
 as_create(void)
 {
@@ -53,25 +53,105 @@ as_create(void)
 	 * Initialize as needed.
 	 */
 
+	as->ptable=NULL;//kmalloc(sizeof(struct PTE));
+	as->pagenum=0;
+//	as->ptable->PTE_P=0;
+//	as->ptable->read=0;
+//	as->ptable->write=0;
+//	as->ptable->exe=0;
+//	as->ptable->next = NULL;
+
+	as->region=NULL;//kmalloc(sizeof(struct region));
+//	as->region->exe=0;
+//	as->region->read=0;
+//	as->region->write=0;
+//	as->region->flag=0;
+//	as->region->next = NULL;
+
+	as->heap_base=0;
+	as->heap_top=0;
+	as->stack_base=USERSTACK-12*PAGE_SIZE;
+	as->stack_top=USERSTACK;
+
 	return as;
 }
-
+static void ptecpy(struct addrspace* newas,struct PTE *new,struct PTE *old){
+	new->PTE_P=old->PTE_P;
+	new->va=old->va;
+	new->pa=KVADDR_TO_PADDR(page_alloc(newas,old->va));
+	memmove((void *)PADDR_TO_KVADDR(new->pa),(const void *)PADDR_TO_KVADDR(old->pa),PAGE_SIZE);
+	new->read=old->read;
+	new->write=old->write;
+	new->exe=old->exe;
+}
+static void regcpy(struct region *new,struct region *old){
+	new->vbase=old->vbase;
+	new->flag=old->flag;
+	new->psize=old->psize;
+	new->read=old->read;
+	new->write=old->write;
+	new->exe=old->exe;
+}
 int
-as_copy(struct addrspace *old, struct addrspace **ret)
+as_copy( struct addrspace *old, struct addrspace **ret)
 {
 	struct addrspace *newas;
 
 	newas = as_create();
-	if (newas==NULL) {
+	if (newas==NULL || old == NULL) {
 		return ENOMEM;
 	}
 
-	/*
-	 * Write this.
-	 */
 
-	(void)old;
-	
+	newas->heap_base = old->heap_base;
+	newas->heap_top = old->heap_top;
+	newas->stack_base = old->stack_base;
+	newas->stack_top = old->stack_top;
+	newas->pagenum=old->pagenum;
+
+	//newas->region=old->region;
+	//newas->ptable=old->ptable;
+//	int pgnumber=old->pagenum;
+//	newas->ptable=kmalloc(pgnumber*sizeof(struct PTE));
+//	memcpy(newas->ptable, old->ptable,pgnumber*sizeof(struct PTE));
+
+		struct PTE * temp1=old->ptable;
+
+
+	struct PTE *tmp2;
+	struct region * temp3 = old->region;
+	struct region * temp4;
+	if(old->region==NULL) return 0;
+	if(old->ptable==NULL) return 0;
+	newas->ptable=kmalloc(sizeof(struct PTE));
+	tmp2=newas->ptable;
+	ptecpy(newas,tmp2,old->ptable);
+	old->ptable=old->ptable->next;
+	while(old->ptable!= NULL){
+		tmp2->next=kmalloc(sizeof(struct PTE));
+		tmp2=tmp2->next;
+		ptecpy(newas,tmp2,old->ptable);
+
+
+		old->ptable = old->ptable->next;
+	}
+	tmp2->next=NULL;
+	old->ptable = temp1;
+
+	newas->region=kmalloc(sizeof(struct region));
+	temp4=newas->region;
+	regcpy(temp4, old->region);
+	old->region=old->region->next;
+	while(old->region != NULL){
+		temp4->next= kmalloc(sizeof(struct region));
+		temp4=temp4->next;
+		regcpy(temp4,old->region);
+
+		old->region = old->region->next;
+	}
+	temp4->next=NULL;
+	old->region = temp3;
+
 	*ret = newas;
 	return 0;
 }
@@ -82,7 +162,33 @@ as_destroy(struct addrspace *as)
 	/*
 	 * Clean up as needed.
 	 */
-	
+	as->heap_base = 0;
+	as->heap_top = 0;
+	as->stack_base = 0;
+	as->stack_top = 0;
+
+	struct PTE * pt = NULL;
+	//struct PTE * temp1 = NULL;
+	struct region * reg;
+	//struct region * temp2 = NULL;
+
+	while(as->ptable != NULL){  ////clean pagetable
+		pt = as->ptable;
+		page_free(as->ptable->va,as);
+		as->ptable->va=0;
+		as->ptable = as->ptable->next;
+		//bzero(pt, sizeof(struct PTE));
+		kfree(pt);
+	}
+
+	while (as->region != NULL)
+			{
+				reg = as->region;
+				//bzero(reg,sizeof(struct region));
+				as->region = as->region->next;
+				kfree(reg);
+			}
+	as->pagenum=0;
 	kfree(as);
 }
 
@@ -92,7 +198,7 @@ as_activate(struct addrspace *as)
 	/*
 	 * Write this.
 	 */
-
+	vm_tlbshootdown_all();
 	(void)as;  // suppress warning until code gets written
 }
 
@@ -106,6 +212,27 @@ as_activate(struct addrspace *as)
  * moment, these are ignored. When you write the VM system, you may
  * want to implement them.
  */
+//static void addpte(struct PTE *tmp1, int i, vaddr_t vaddr,  struct addrspace *as,int readable, int writeable, int executable){
+//	tmp1->va=vaddr+i*PAGE_SIZE;
+////update permission
+//	if(readable==4)tmp1->read=1;
+//	if(writeable==2)tmp1->write=1;
+//	if(executable==1)tmp1->exe=1;
+////spinlock_acquire(&coremap_lk);
+//
+//tmp1->pa=-1;//KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace,tmp1->va));
+////int j=(tmp1->pa)/PAGE_SIZE;
+//tmp1->PTE_P=1;
+//tmp1->next=NULL;
+//as->pagenum++;
+//coremap update
+//coremap[j].pid=curthread->t_pid;
+//coremap[j].va=tmp1->va;
+//coremap[j].as=as;
+//coremap[j].pgstate=DIRTY;
+//spinlock_release(&coremap_lk);
+
+
 int
 as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
 		 int readable, int writeable, int executable)
@@ -113,14 +240,77 @@ as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
 	/*
 	 * Write this.
 	 */
+	sz += vaddr & ~(vaddr_t)PAGE_FRAME; //Aligning Regions
+	vaddr &= PAGE_FRAME;
+	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME; //length
 
-	(void)as;
-	(void)vaddr;
-	(void)sz;
-	(void)readable;
-	(void)writeable;
-	(void)executable;
-	return EUNIMP;
+	int count;
+	struct region *tmp=NULL;
+	struct region *reg = kmalloc(sizeof(struct region));
+	KASSERT(reg!=NULL);
+
+	reg->vbase = vaddr;
+	reg->psize = sz / PAGE_SIZE;
+	reg->flag=0;
+	reg->next=NULL;
+	if(readable==4)reg->read=1;
+	if(writeable==2)reg->write=1;
+	if(executable==1)reg->exe=1;
+	//check if 1st one
+	if(as->region==NULL){as->region=reg;count=as->region->psize;}
+	else{tmp=as->region;
+	while(tmp->next != NULL){
+			tmp=tmp->next;
+		}
+		tmp->next=reg;
+		count=reg->psize;
+	}
+	as->heap_base=vaddr+(sz/PAGE_SIZE)*PAGE_SIZE;
+		as->heap_top=as->heap_base;
+
+
+
+
+
+	// update pagetable
+//	struct PTE *PT= as->ptable;
+//	struct PTE *pt1=kmalloc(sizeof(struct PTE) );
+//	KASSERT(pt1!=NULL);
+//	addpte(pt1,0,vaddr,as,readable,writeable, executable);
+//	struct PTE *tmp1=pt1;
+////ap();
+//	for(int i=1;i<count;i++){
+//		ap();
+//
+//		tmp1->next=kmalloc(sizeof(struct PTE));
+//		tmp1=tmp1->next;
+//		KASSERT(tmp1!=NULL);
+////
+//		addpte(tmp1,i,vaddr,as,readable,writeable, executable);
+////		ap();
+//	//coremap update
+//
+//	}
+//
+//	if (as->ptable==NULL){as->ptable=pt1;}
+//	else{while(PT->next!=NULL){
+//			PT=PT->next;
+//			ap();
+//		}
+//	PT->next=pt1;
+//	ap();
+//	}
+	//HEAP
+
+
+
+//	(void)as;
+//	(void)vaddr;
+//	(void)sz;
+//	(void)readable;
+//	(void)writeable;
+//	(void)executable;
+	return 0;
 }
 
 int
@@ -130,7 +320,40 @@ as_prepare_load(struct addrspace *as)
 	 * Write this.
 	 */
 
-	(void)as;
+	struct region *tmp=as->region;
+	while (tmp!=NULL){
+		if (tmp->write==0) {tmp->write=1;tmp->flag=1;}
+//		struct PTE *PT= as->ptable;
+//			struct PTE *pt1=kmalloc(sizeof(struct PTE) );
+//			KASSERT(pt1!=NULL);
+//			addpte(pt1,0,tmp->vbase,as,tmp->read,tmp->write, tmp->exe);
+//			struct PTE *tmp1=pt1;
+//		//ap();
+//			for(int i=1;i<count;i++){
+//				ap();
+//
+//				tmp1->next=kmalloc(sizeof(struct PTE));
+//				tmp1=tmp1->next;
+//				KASSERT(tmp1!=NULL);
+//		//
+//				addpte(tmp1,i,tmp->vbase,as,tmp->read,tmp->write, tmp->exe);
+//		//		ap();
+//			//coremap update
+//
+//			}
+//
+//			if (as->ptable==NULL){as->ptable=pt1;}
+//			else{while(PT->next!=NULL){
+//					PT=PT->next;
+//					ap();
+//				}
+//			PT->next=pt1;
+//			ap();
+//			}
+
+		tmp=tmp->next;
+	}
+	//(void)as;
 	return 0;
 }
 
@@ -140,6 +363,11 @@ as_complete_load(struct addrspace *as)
 	/*
 	 * Write this.
 	 */
+	struct region *tmp=as->region;
+		while (tmp!=NULL){
+			if (tmp->flag==1) {tmp->write=0;}
+			tmp=tmp->next;
+		}
 
 	(void)as;
 	return 0;
@@ -152,10 +380,11 @@ as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 	 * Write this.
 	 */
 
-	(void)as;
-
+	//(void)as;
+	//as->stack_base= USERSTACK;
+	//as->stack_top = USERSTACK;
 	/* Initial user-level stack pointer */
-	*stackptr = USERSTACK;
+	*stackptr = as->stack_top;
 	
 	return 0;
 }
diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
index 09b764b..11b3af2 100644
--- a/kern/vm/kmalloc.c
+++ b/kern/vm/kmalloc.c
@@ -31,7 +31,8 @@
 #include <lib.h>
 #include <spinlock.h>
 #include <vm.h>
-
+#include<machine/vm.h>
+#include <limits.h>
 /*
  * Kernel malloc.
  */
diff --git a/kern/vm/vm.c b/kern/vm/vm.c
new file mode 100644
index 0000000..05339f9
--- /dev/null
+++ b/kern/vm/vm.c
@@ -0,0 +1,550 @@
+/*
+ * vm.c
+ *
+ *  Created on: Apr 14, 2015
+ *      Author: trinity
+ */
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+#include<machine/vm.h>
+
+struct spinlock coremap_lk=SPINLOCK_INITIALIZER;
+struct spinlock tlb_lk=SPINLOCK_INITIALIZER;
+struct spinlock s_lock=SPINLOCK_INITIALIZER;
+
+static int bootstrap=0;
+static int free_start=0;
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+static int pnum;
+static void pp()
+{
+	return ;
+}
+//#define DUMBVM_STACKPAGES    12
+
+void vm_bootstrap(void){
+	paddr_t first,last,freeadrs;
+	//paddr_t x=0;
+	//coremap_lk=lock_create("coremap_lock");
+	//KASSERT(coremap_lk!=NULL);
+	ram_getsize(&first,&last);
+	pnum=last/PAGE_SIZE;
+	coremap=(struct coremap_entry*)PADDR_TO_KVADDR(first);
+	freeadrs= first+pnum*sizeof(struct coremap_entry)+PAGE_SIZE;
+	free_start=freeadrs/PAGE_SIZE;
+	for (int i=0; i<pnum;i++){
+		coremap[i].va=0;
+		coremap[i].pa=PADDR_TO_KVADDR(i*PAGE_SIZE);
+		if(i*PAGE_SIZE<(int)freeadrs) coremap[i].pgstate=FIXED;
+		else {coremap[i].pgstate=FREE;
+			coremap[i].chunk=1;
+			coremap[i].as=NULL;}
+		}
+
+	bootstrap=1;
+}
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+
+	spinlock_acquire(&stealmem_lock);
+
+	addr = ram_stealmem(npages);
+
+	spinlock_release(&stealmem_lock);
+	return addr;
+}
+
+
+
+/* Allocate/free kernel heap pages (called by kmalloc/kfree) */
+vaddr_t alloc_kpages(int npages){
+	if (bootstrap==0){return PADDR_TO_KVADDR(getppages(npages));}
+	else return page_nalloc(npages);
+}
+vaddr_t page_nalloc(int npages){
+	//int i;
+	spinlock_acquire(&coremap_lk);
+	int i;
+	int p=0;
+	//paddr_t t=0;
+	//vaddr_t v;
+	for (i=free_start;i<pnum;i++){
+		if (coremap[i].pgstate==FREE){
+			for (int k=0;k<npages;k++){
+				if(coremap[i+k].pgstate==FREE)p++;
+				else break;
+			}
+		if (p==npages) {
+			coremap[i].chunk=p; break;
+						}
+		else{p=0;}
+
+		}
+	}
+	if(coremap[i].chunk!=npages){spinlock_release(&coremap_lk);return ENOMEM;}
+	else {
+		for (int j=0;j<npages;j++){
+			//v=PADDR_TO_KVADDR(t+(i+j)*PAGE_SIZE);
+		make_page_avail(&coremap[i+j]);
+		coremap[i+j].va=coremap[i+j].pa;
+		coremap[i+j].pid=curthread->t_pid;
+		coremap[i+j].pgstate=DIRTY;
+		coremap[i+j].as=NULL;
+		}
+	}
+	spinlock_release(&coremap_lk);
+	return PADDR_TO_KVADDR((i*PAGE_SIZE));
+
+
+}
+vaddr_t page_alloc(struct addrspace* newas,vaddr_t va){
+
+	//paddr_t t=0;
+	//vaddr_t v;
+	int i;
+	spinlock_acquire(&coremap_lk);
+	for(i=free_start;i<pnum;i++){
+		if(coremap[i].pgstate==FREE)break;
+	}
+	//kprintf("i = %d\n", i);
+	KASSERT(i!=pnum);
+	//if(i==128) panic("run out of coremap");
+	if(coremap[i].pgstate!=FREE){
+		pp();
+		return EFAULT;
+		}
+	//v=PADDR_TO_KVADDR((t+i*PAGE_SIZE));
+	make_page_avail(&coremap[i]);
+	coremap[i].pid=curthread->t_pid;
+	coremap[i].va=va;
+	coremap[i].pgstate=DIRTY;
+	coremap[i].as=newas;//update addresspace
+	spinlock_release(&coremap_lk);
+	return PADDR_TO_KVADDR(i*PAGE_SIZE);
+
+}
+ void make_page_avail(struct coremap_entry *coremap){
+	 //KASSERT(coremap->pgstate==FREE&&coremap->chunk==1);
+	coremap->pgstate=DIRTY;
+	bzero((void *)coremap->pa,PAGE_SIZE);
+}
+// static void shottlb(vaddr_t addr){
+//	 spinlock_acquire(&tlb_lk);
+//	 paddr_t pa=0;
+//	 int m=tlb_probe(addr,pa);
+//	 if (m>=0)tlb_write(TLBHI_INVALID(m),TLBLO_INVALID(),m);
+// }
+void free_kpages(vaddr_t addr){
+	addr&=PAGE_FRAME;
+
+	int i;
+	spinlock_acquire(&coremap_lk);
+	for (i=free_start;i<pnum;i++){
+		if(coremap[i].va==addr)break;
+	}
+
+	if(i==pnum) {spinlock_release(&coremap_lk);return;}
+	//coremap[i].as->ptable
+	//if(coremap[i].pgstate==FIXED){spinlock_release(&coremap_lk);return;}
+
+	int chunk=coremap[i].chunk;
+
+	for (int j=0;j<chunk;j++){
+		//page_free(addr+i*PAGE_SIZE);
+		coremap[i+j].pid=-1;
+		coremap[i+j].pgstate=FREE;
+		coremap[i+j].chunk=1;
+
+		coremap[i+j].va=0;///////////////
+//		//unmap
+		coremap[i+j].as=NULL;
+		}
+	spinlock_release(&coremap_lk);
+}
+
+void page_free(vaddr_t addr, struct addrspace* as){
+	addr&=PAGE_FRAME;
+//		struct PTE *pt=curthread->t_addrspace->ptable;
+//		int count=curthread->t_addrspace->pagenum;
+		int i;
+//		int k=0;
+//		for (i=0;i<count;i++){if(pt->va==addr) {k=pt->pa/PAGE_SIZE;shottlb(addr);pt->va=0;pt->pa=0;}
+//		pt=pt->next;}
+//		KASSERT(k!=0);
+		spinlock_acquire(&coremap_lk);
+	for (i=0;i<pnum;i++){
+		if(coremap[i].va==addr&&coremap[i].as==as)break;
+	}
+
+	KASSERT(i!=pnum);
+	//if(i==pnum) {spinlock_release(&coremap_lk);return;}
+	//KASSERT(coremap[i].pgstate!=FIXED);
+	//if(coremap[i].pgstate==FIXED){spinlock_release(&coremap_lk);return;}
+
+
+
+
+		coremap[i].va=0;
+		coremap[i].pgstate=FREE;
+		coremap[i].chunk=1;
+		coremap[i].as=NULL;
+		coremap[i].pid=-2;
+
+	spinlock_release(&coremap_lk);
+}
+
+
+
+
+/* TLB shootdown handling called from interprocessor_interrupt */
+void
+vm_tlbshootdown_all(void)
+{
+	struct spinlock s_lock;
+	spinlock_init(&s_lock);
+	spinlock_acquire(&s_lock);
+	for(uint32_t i = 0; i<NUM_TLB; i++){
+		tlb_write(TLBHI_INVALID(i),TLBLO_INVALID(), i);	}
+	spinlock_release(&s_lock);
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+	(void)ts;
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+static void bp()
+{
+	return ;
+}
+//void updateCoremap(){}
+
+/* Fault handling function called by trap code */
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+	//check vaddr_t is valid
+		struct PTE *tmp;
+		struct PTE *p2=NULL;
+		int flag=0;
+		char read=1;
+		char write=1;
+		char exe=1;
+		int tlb_index;
+		//paddr_t pad = 0;
+		if(curthread->t_addrspace == NULL) return EFAULT;
+		struct addrspace *as=curthread->t_addrspace;
+
+
+		KASSERT(faultaddress < MIPS_KSEG0);
+	//	KASSERT(as->ptable != NULL);
+		KASSERT(as->region != NULL);
+		KASSERT(as->heap_base != 0);
+		KASSERT(as->heap_top != 0);
+	//KASSERT((as->ptable->va & PAGE_FRAME) == as->ptable->va);
+		//cp();
+		//KASSERT((as->ptable->pa & PAGE_FRAME) == as->ptable->pa);
+
+				struct region *reg=as->region;
+		vaddr_t vadr = faultaddress;
+		faultaddress &= PAGE_FRAME;
+
+		//struct spinlock s_lock;
+		struct PTE *p = as->ptable;
+		paddr_t padr = 0;
+		//vaddr_t vadr = faultaddress;
+		//spinlock_init(&s_lock);
+		while (reg!=NULL){
+					//bp();
+					if ((faultaddress>=reg->vbase) && (faultaddress<(reg->vbase+PAGE_SIZE*reg->psize))) {flag=1;read=reg->read;write=reg->write;exe=reg->exe;}
+					reg=reg->next;
+					//bp();
+				}
+				//bp();
+				if ((vadr>=as->heap_base) && vadr<(as->heap_top)) flag=1;
+				if (vadr>=(as->stack_base) && vadr<(as->stack_top)) flag=1;
+				if (flag==0) {panic("0ddddddd");}
+
+		// check what fault it is
+		if (faulttype!=0 && faulttype!=1 && faulttype!=2){panic("unknown fault");}
+		//vm_read
+		if (faulttype==0||faulttype==1){
+
+//			int m=tlb_probe(faultaddress, padr);
+//			if (m>=0&&m<=NUM_TLB){spinlock_release(&s_lock);panic("TLB wrong");}
+			if(as->ptable==NULL){
+			as->ptable=kmalloc(sizeof(struct PTE));
+			//p=tmp->next;
+			as->ptable->exe=exe;
+			as->ptable->read=read;
+			as->ptable->write=write;
+			as->ptable->va=faultaddress;
+			as->ptable->PTE_P=1;
+
+			as->ptable->pa=KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace, faultaddress));
+			as->pagenum++;
+
+			//int j=(p->pa)/PAGE_SIZE;
+
+
+
+			as->ptable->next=NULL;
+			padr = as->ptable->pa | TLBLO_DIRTY | TLBLO_VALID;
+			}
+
+			else {while(p != NULL){
+				if(p->next==NULL){tmp=p;}
+				if(p->va == faultaddress ){
+					if( p->PTE_P == 1){
+						//if(p->write==1)
+						//
+					padr = p->pa | TLBLO_DIRTY | TLBLO_VALID;
+						//else padr = p->pa | TLBLO_VALID;
+					}
+					//else {p->pa=KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace, faultaddress));padr = p->pa | TLBLO_DIRTY | TLBLO_VALID;}
+				}
+//
+				p = p->next;
+			}
+
+			if(padr==0) {tmp->next=kmalloc(sizeof(struct PTE));
+						p=tmp->next;
+						p->exe=exe;
+						p->read=read;
+						p->write=write;
+						p->va=faultaddress;
+						p->PTE_P=1;
+
+						p->pa=KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace, faultaddress));
+						as->pagenum++;
+
+						//int j=(p->pa)/PAGE_SIZE;
+						p->next=NULL;
+						padr = p->pa | TLBLO_DIRTY | TLBLO_VALID;
+						}
+			}
+			//bp();
+			spinlock_acquire(&s_lock);
+			//KASSERT((padr & PAGE_FRAME) == padr);
+			tlb_random(faultaddress, padr);
+			spinlock_release(&s_lock);
+		}
+
+		//vm_readonly
+		if(faulttype==2){
+			//p = curthread->t_addrspace->ptable;
+			while(p != NULL){
+				if(p->va == faultaddress){
+					p2 = p;
+					break;
+				}
+				p = p->next;
+			}
+			if(p2==NULL) panic("read_only err");
+			if(p2->write!=1 )panic("Not writable");
+			spinlock_acquire(&s_lock);
+			bp();
+			tlb_index=tlb_probe(faultaddress,padr);
+			if(tlb_index<0) panic("tlb_readonly fault");
+//			for(int i = 0; i<NUM_TLB; i++){
+//				tlb_read(&vadr,&padr, i);
+			tlb_read(&vadr,&padr,tlb_index);
+
+
+				padr = padr| TLBLO_DIRTY |TLBLO_VALID;
+				KASSERT((padr & PAGE_FRAME) == padr);
+				tlb_write(vadr, padr, tlb_index);
+				spinlock_release(&s_lock);
+				//coremap
+		}
+bp();
+
+		return 0;
+}
+
+//struct addrspace *
+//as_create(void)
+//{
+//	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+//	if (as==NULL) {
+//		return NULL;
+//	}
+//
+//	as->as_vbase1 = 0;
+//	as->as_pbase1 = 0;
+//	as->as_npages1 = 0;
+//	as->as_vbase2 = 0;
+//	as->as_pbase2 = 0;
+//	as->as_npages2 = 0;
+//	as->as_stackpbase = 0;
+//
+//	return as;
+//}
+//
+//void
+//as_destroy(struct addrspace *as)
+//{
+//	kfree(as);
+//}
+//
+//void
+//as_activate(struct addrspace *as)
+//{
+//	int i, spl;
+//
+//	(void)as;
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+//	}
+//
+//	splx(spl);
+//}
+//
+//int
+//as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+//		 int readable, int writeable, int executable)
+//{
+//	size_t npages;
+//
+//	/* Align the region. First, the base... */
+//	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+//	vaddr &= PAGE_FRAME;
+//
+//	/* ...and now the length. */
+//	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+//
+//	npages = sz / PAGE_SIZE;
+//
+//	/* We don't use these - all pages are read-write */
+//	(void)readable;
+//	(void)writeable;
+//	(void)executable;
+//
+//	if (as->as_vbase1 == 0) {
+//		as->as_vbase1 = vaddr;
+//		as->as_npages1 = npages;
+//		return 0;
+//	}
+//
+//	if (as->as_vbase2 == 0) {
+//		as->as_vbase2 = vaddr;
+//		as->as_npages2 = npages;
+//		return 0;
+//	}
+//
+//	/*
+//	 * Support for more than two regions is not available.
+//	 */
+//	kprintf("dumbvm: Warning: too many regions\n");
+//	return EUNIMP;
+//}
+//
+//static
+//void
+//as_zero_region(paddr_t paddr, unsigned npages)
+//{
+//	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+//}
+//
+//int
+//as_prepare_load(struct addrspace *as)
+//{
+//	KASSERT(as->as_pbase1 == 0);
+//	KASSERT(as->as_pbase2 == 0);
+//	KASSERT(as->as_stackpbase == 0);
+//
+//	as->as_pbase1 = getppages(as->as_npages1);
+//	if (as->as_pbase1 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_pbase2 = getppages(as->as_npages2);
+//	if (as->as_pbase2 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+//	if (as->as_stackpbase == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as_zero_region(as->as_pbase1, as->as_npages1);
+//	as_zero_region(as->as_pbase2, as->as_npages2);
+//	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+//
+//	return 0;
+//}
+//
+//int
+//as_complete_load(struct addrspace *as)
+//{
+//	(void)as;
+//	return 0;
+//}
+//
+//int
+//as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+//{
+//	KASSERT(as->as_stackpbase != 0);
+//
+//	*stackptr = USERSTACK;
+//	return 0;
+//}
+//
+//int
+//as_copy(struct addrspace *old, struct addrspace **ret)
+//{
+//	struct addrspace *new;
+//
+//	new = as_create();
+//	if (new==NULL) {
+//		return ENOMEM;
+//	}
+//
+//	new->as_vbase1 = old->as_vbase1;
+//	new->as_npages1 = old->as_npages1;
+//	new->as_vbase2 = old->as_vbase2;
+//	new->as_npages2 = old->as_npages2;
+//
+//	/* (Mis)use as_prepare_load to allocate some physical memory. */
+//	if (as_prepare_load(new)) {
+//		as_destroy(new);
+//		return ENOMEM;
+//	}
+//
+//	KASSERT(new->as_pbase1 != 0);
+//	KASSERT(new->as_pbase2 != 0);
+//	KASSERT(new->as_stackpbase != 0);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+//		old->as_npages1*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+//		old->as_npages2*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+//		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+//		DUMBVM_STACKPAGES*PAGE_SIZE);
+//
+//	*ret = new;
+//	return 0;
+//}
+//
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..450c8c4
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,4532 @@
+diff --git a/.cproject b/.cproject
+new file mode 100644
+index 0000000..f70133d
+--- /dev/null
++++ b/.cproject
+@@ -0,0 +1,49 @@
++<?xml version="1.0" encoding="UTF-8" standalone="no"?>
++<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
++	<storageModule moduleId="org.eclipse.cdt.core.settings">
++		<cconfiguration id="0.1480216780">
++			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="0.1480216780" moduleId="org.eclipse.cdt.core.settings" name="Default">
++				<externalSettings/>
++				<extensions>
++					<extension id="org.eclipse.cdt.core.VCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
++					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
++					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
++					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
++					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
++					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
++				</extensions>
++			</storageModule>
++			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
++				<configuration buildProperties="" description="" id="0.1480216780" name="Default" parent="org.eclipse.cdt.build.core.prefbase.cfg">
++					<folderInfo id="0.1480216780." name="/" resourcePath="">
++						<toolChain id="org.eclipse.cdt.build.core.prefbase.toolchain.904457826" name="No ToolChain" resourceTypeBasedDiscovery="false" superClass="org.eclipse.cdt.build.core.prefbase.toolchain">
++							<targetPlatform id="org.eclipse.cdt.build.core.prefbase.toolchain.904457826.332120844" name=""/>
++							<builder id="org.eclipse.cdt.build.core.settings.default.builder.926228091" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Gnu Make Builder" superClass="org.eclipse.cdt.build.core.settings.default.builder"/>
++							<tool id="org.eclipse.cdt.build.core.settings.holder.libs.1532505298" name="holder for library settings" superClass="org.eclipse.cdt.build.core.settings.holder.libs"/>
++							<tool id="org.eclipse.cdt.build.core.settings.holder.1374373016" name="Assembly" superClass="org.eclipse.cdt.build.core.settings.holder">
++								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.1636813309" languageId="org.eclipse.cdt.core.assembly" languageName="Assembly" sourceContentType="org.eclipse.cdt.core.asmSource" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
++							</tool>
++							<tool id="org.eclipse.cdt.build.core.settings.holder.1548496932" name="GNU C++" superClass="org.eclipse.cdt.build.core.settings.holder">
++								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.2044814512" languageId="org.eclipse.cdt.core.g++" languageName="GNU C++" sourceContentType="org.eclipse.cdt.core.cxxSource,org.eclipse.cdt.core.cxxHeader" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
++							</tool>
++							<tool id="org.eclipse.cdt.build.core.settings.holder.2030291621" name="GNU C" superClass="org.eclipse.cdt.build.core.settings.holder">
++								<inputType id="org.eclipse.cdt.build.core.settings.holder.inType.1200708495" languageId="org.eclipse.cdt.core.gcc" languageName="GNU C" sourceContentType="org.eclipse.cdt.core.cSource,org.eclipse.cdt.core.cHeader" superClass="org.eclipse.cdt.build.core.settings.holder.inType"/>
++							</tool>
++						</toolChain>
++					</folderInfo>
++				</configuration>
++			</storageModule>
++			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
++		</cconfiguration>
++	</storageModule>
++	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
++		<project id="os161.null.5113732" name="os161"/>
++	</storageModule>
++	<storageModule moduleId="scannerConfiguration">
++		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
++		<scannerConfigBuildInfo instanceId="0.1480216780">
++			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
++		</scannerConfigBuildInfo>
++	</storageModule>
++	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
++</cproject>
+diff --git a/.gitignore b/.gitignore
+index ccea0c4..fa313dd 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -1,9 +1,5 @@
+-.depend
+-.settings
+-.project
+-.cproject
+-/kern/compile/
+-defs.mk
+ build
+-/user/testbin/randcall/calls.c
+-*.swp
++.depend
++/defs.mk
++kern/compile/
++user/testbin/randcall/calls.c
+diff --git a/.project b/.project
+new file mode 100644
+index 0000000..3f7d5f2
+--- /dev/null
++++ b/.project
+@@ -0,0 +1,27 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<projectDescription>
++	<name>os161</name>
++	<comment></comment>
++	<projects>
++	</projects>
++	<buildSpec>
++		<buildCommand>
++			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
++			<triggers>clean,full,incremental,</triggers>
++			<arguments>
++			</arguments>
++		</buildCommand>
++		<buildCommand>
++			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
++			<triggers>full,incremental,</triggers>
++			<arguments>
++			</arguments>
++		</buildCommand>
++	</buildSpec>
++	<natures>
++		<nature>org.eclipse.cdt.core.cnature</nature>
++		<nature>org.eclipse.cdt.core.ccnature</nature>
++		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
++		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
++	</natures>
++</projectDescription>
+diff --git a/kern.tar.gz b/kern.tar.gz
+new file mode 100644
+index 0000000..0bb91e1
+Binary files /dev/null and b/kern.tar.gz differ
+diff --git a/kern/arch/mips/conf/conf.arch b/kern/arch/mips/conf/conf.arch
+index 39ddbc3..947dcca 100644
+--- a/kern/arch/mips/conf/conf.arch
++++ b/kern/arch/mips/conf/conf.arch
+@@ -66,6 +66,7 @@ machine mips file    arch/mips/vm/ram.c		# Physical memory accounting
+ # it may not be suitable for all architectures.
+ machine mips file    vm/copyinout.c		# copyin/out et al.
+ 
++
+ # For the early assignments, we supply a very stupid MIPS-only skeleton
+ # of a VM system. It is just barely capable of running a single userlevel
+ # program as long as that program's not very large.
+diff --git a/kern/arch/mips/include/vm.h b/kern/arch/mips/include/vm.h
+index af393c7..3b9f82a 100644
+--- a/kern/arch/mips/include/vm.h
++++ b/kern/arch/mips/include/vm.h
+@@ -66,7 +66,7 @@
+  * a valid address, and will make a *huge* mess if you scribble on it.
+  */
+ #define PADDR_TO_KVADDR(paddr) ((paddr)+MIPS_KSEG0)
+-
++#define KVADDR_TO_PADDR(vaddr) ((vaddr)-MIPS_KSEG0)
+ /*
+  * The top of user space. (Actually, the address immediately above the
+  * last valid user address.)
+diff --git a/kern/arch/mips/locore/.trap.c.swp b/kern/arch/mips/locore/.trap.c.swp
+new file mode 100644
+index 0000000..1547aff
+Binary files /dev/null and b/kern/arch/mips/locore/.trap.c.swp differ
+diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
+index ff39633..c11a9f1 100644
+--- a/kern/arch/mips/locore/trap.c
++++ b/kern/arch/mips/locore/trap.c
+@@ -111,7 +111,7 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
+ 	/*
+ 	 * You will probably want to change this.
+ 	 */
+-
++	sys__exit(-1);
+ 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
+ 		code, sig, trapcodenames[code], epc, vaddr);
+ 	panic("I don't know how to handle this\n");
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..b7ff16e 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -35,6 +35,8 @@
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
++#include <kern/filesys.h>
++#include <copyinout.h>
+ 
+ 
+ /*
+@@ -81,7 +83,10 @@ syscall(struct trapframe *tf)
+ 	int callno;
+ 	int32_t retval;
+ 	int err;
+-
++	off_t sys_pos=0;
++	off_t ret;
++	int whence;
++	
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+ 	KASSERT(curthread->t_iplhigh_count == 0);
+@@ -108,9 +113,60 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
+-
++	    
+ 	    /* Add stuff here */
+- 
++ 	    case SYS_fork:
++		err = sys_fork(tf,&retval);
++		break;
++	    case SYS_execv:
++		err=sys_execv(&retval, (const char*)tf->tf_a0,(char**)tf->tf_a1);
++		break;
++	    case SYS_waitpid:
++		err=sys_waitpid(&retval, (pid_t)tf->tf_a0, (int*)tf->tf_a1,tf->tf_a2);
++		break;
++	   case SYS__exit:
++		err=sys__exit( (int)tf->tf_a0);
++		break;
++	   case SYS_getpid:
++		err = sys_getpid(&retval);
++		break;
++	case SYS_read:
++		err = sys_read(tf->tf_a0, (void *) tf->tf_a1, (size_t) tf->tf_a2, &retval);
++		break;
++	case SYS_write:
++		err = sys_write(tf->tf_a0, (void *) tf->tf_a1, (size_t) tf->tf_a2, &retval);
++		break;
++	case SYS_open:
++		err = sys_open((const char *)tf->tf_a0, tf->tf_a1, (mode_t)tf->tf_a2, &retval);
++		break;
++	case SYS_close:
++		err = sys_close(tf->tf_a0, &retval);
++		break;
++	case SYS_lseek:
++		sys_pos = ((off_t)tf->tf_a2) << 32 | (off_t)tf->tf_a3;
++		err = copyin((const_userptr_t)tf->tf_sp+16, &whence, sizeof(int));
++		if(err) {
++			break;
++		}
++		err = sys_lseek(tf->tf_a0, sys_pos, (int)whence, &ret);
++		if(!err){
++			tf->tf_v1 = ret;
++			retval = ret >> 32;
++		}
++		break;
++	case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++		break;
++	case SYS_chdir:
++		err = sys_chdir((const char *)tf->tf_a0, &retval);
++		break;
++	case SYS___getcwd:
++		err = sys___getcwd((char *)tf->tf_a0, (size_t)tf->tf_a1, &retval);
++		break;
++	case SYS_sbrk:
++		err=sys_sbrk(tf->tf_a0,&retval);
++		break;
++
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
+index ca9992a..89a746c 100644
+--- a/kern/arch/mips/vm/dumbvm.c
++++ b/kern/arch/mips/vm/dumbvm.c
+@@ -1,374 +1,374 @@
+-/*
+- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+- *	The President and Fellows of Harvard College.
+- *
+- * Redistribution and use in source and binary forms, with or without
+- * modification, are permitted provided that the following conditions
+- * are met:
+- * 1. Redistributions of source code must retain the above copyright
+- *    notice, this list of conditions and the following disclaimer.
+- * 2. Redistributions in binary form must reproduce the above copyright
+- *    notice, this list of conditions and the following disclaimer in the
+- *    documentation and/or other materials provided with the distribution.
+- * 3. Neither the name of the University nor the names of its contributors
+- *    may be used to endorse or promote products derived from this software
+- *    without specific prior written permission.
+- *
+- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+- * SUCH DAMAGE.
+- */
+-
+-#include <types.h>
+-#include <kern/errno.h>
+-#include <lib.h>
+-#include <spl.h>
+-#include <spinlock.h>
+-#include <thread.h>
+-#include <current.h>
+-#include <mips/tlb.h>
+-#include <addrspace.h>
+-#include <vm.h>
+-
+-/*
+- * Dumb MIPS-only "VM system" that is intended to only be just barely
+- * enough to struggle off the ground. You should replace all of this
+- * code while doing the VM assignment. In fact, starting in that
+- * assignment, this file is not included in your kernel!
+- */
+-
+-/* under dumbvm, always have 48k of user stack */
+-#define DUMBVM_STACKPAGES    12
+-
+-/*
+- * Wrap rma_stealmem in a spinlock.
+- */
+-static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+-
+-void
+-vm_bootstrap(void)
+-{
+-	/* Do nothing. */
+-}
+-
+-static
+-paddr_t
+-getppages(unsigned long npages)
+-{
+-	paddr_t addr;
+-
+-	spinlock_acquire(&stealmem_lock);
+-
+-	addr = ram_stealmem(npages);
+-	
+-	spinlock_release(&stealmem_lock);
+-	return addr;
+-}
+-
+-/* Allocate/free some kernel-space virtual pages */
+-vaddr_t 
+-alloc_kpages(int npages)
+-{
+-	paddr_t pa;
+-	pa = getppages(npages);
+-	if (pa==0) {
+-		return 0;
+-	}
+-	return PADDR_TO_KVADDR(pa);
+-}
+-
+-void 
+-free_kpages(vaddr_t addr)
+-{
+-	/* nothing - leak the memory. */
+-
+-	(void)addr;
+-}
+-
+-void
+-vm_tlbshootdown_all(void)
+-{
+-	panic("dumbvm tried to do tlb shootdown?!\n");
+-}
+-
+-void
+-vm_tlbshootdown(const struct tlbshootdown *ts)
+-{
+-	(void)ts;
+-	panic("dumbvm tried to do tlb shootdown?!\n");
+-}
+-
+-int
+-vm_fault(int faulttype, vaddr_t faultaddress)
+-{
+-	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+-	paddr_t paddr;
+-	int i;
+-	uint32_t ehi, elo;
+-	struct addrspace *as;
+-	int spl;
+-
+-	faultaddress &= PAGE_FRAME;
+-
+-	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+-
+-	switch (faulttype) {
+-	    case VM_FAULT_READONLY:
+-		/* We always create pages read-write, so we can't get this */
+-		panic("dumbvm: got VM_FAULT_READONLY\n");
+-	    case VM_FAULT_READ:
+-	    case VM_FAULT_WRITE:
+-		break;
+-	    default:
+-		return EINVAL;
+-	}
+-
+-	as = curthread->t_addrspace;
+-	if (as == NULL) {
+-		/*
+-		 * No address space set up. This is probably a kernel
+-		 * fault early in boot. Return EFAULT so as to panic
+-		 * instead of getting into an infinite faulting loop.
+-		 */
+-		return EFAULT;
+-	}
+-
+-	/* Assert that the address space has been set up properly. */
+-	KASSERT(as->as_vbase1 != 0);
+-	KASSERT(as->as_pbase1 != 0);
+-	KASSERT(as->as_npages1 != 0);
+-	KASSERT(as->as_vbase2 != 0);
+-	KASSERT(as->as_pbase2 != 0);
+-	KASSERT(as->as_npages2 != 0);
+-	KASSERT(as->as_stackpbase != 0);
+-	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+-	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+-	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+-	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+-	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+-
+-	vbase1 = as->as_vbase1;
+-	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+-	vbase2 = as->as_vbase2;
+-	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+-	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+-	stacktop = USERSTACK;
+-
+-	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+-		paddr = (faultaddress - vbase1) + as->as_pbase1;
+-	}
+-	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+-		paddr = (faultaddress - vbase2) + as->as_pbase2;
+-	}
+-	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+-		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+-	}
+-	else {
+-		return EFAULT;
+-	}
+-
+-	/* make sure it's page-aligned */
+-	KASSERT((paddr & PAGE_FRAME) == paddr);
+-
+-	/* Disable interrupts on this CPU while frobbing the TLB. */
+-	spl = splhigh();
+-
+-	for (i=0; i<NUM_TLB; i++) {
+-		tlb_read(&ehi, &elo, i);
+-		if (elo & TLBLO_VALID) {
+-			continue;
+-		}
+-		ehi = faultaddress;
+-		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+-		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+-		tlb_write(ehi, elo, i);
+-		splx(spl);
+-		return 0;
+-	}
+-
+-	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+-	splx(spl);
+-	return EFAULT;
+-}
+-
+-struct addrspace *
+-as_create(void)
+-{
+-	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+-	if (as==NULL) {
+-		return NULL;
+-	}
+-
+-	as->as_vbase1 = 0;
+-	as->as_pbase1 = 0;
+-	as->as_npages1 = 0;
+-	as->as_vbase2 = 0;
+-	as->as_pbase2 = 0;
+-	as->as_npages2 = 0;
+-	as->as_stackpbase = 0;
+-
+-	return as;
+-}
+-
+-void
+-as_destroy(struct addrspace *as)
+-{
+-	kfree(as);
+-}
+-
+-void
+-as_activate(struct addrspace *as)
+-{
+-	int i, spl;
+-
+-	(void)as;
+-
+-	/* Disable interrupts on this CPU while frobbing the TLB. */
+-	spl = splhigh();
+-
+-	for (i=0; i<NUM_TLB; i++) {
+-		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+-	}
+-
+-	splx(spl);
+-}
+-
+-int
+-as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+-		 int readable, int writeable, int executable)
+-{
+-	size_t npages; 
+-
+-	/* Align the region. First, the base... */
+-	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+-	vaddr &= PAGE_FRAME;
+-
+-	/* ...and now the length. */
+-	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+-
+-	npages = sz / PAGE_SIZE;
+-
+-	/* We don't use these - all pages are read-write */
+-	(void)readable;
+-	(void)writeable;
+-	(void)executable;
+-
+-	if (as->as_vbase1 == 0) {
+-		as->as_vbase1 = vaddr;
+-		as->as_npages1 = npages;
+-		return 0;
+-	}
+-
+-	if (as->as_vbase2 == 0) {
+-		as->as_vbase2 = vaddr;
+-		as->as_npages2 = npages;
+-		return 0;
+-	}
+-
+-	/*
+-	 * Support for more than two regions is not available.
+-	 */
+-	kprintf("dumbvm: Warning: too many regions\n");
+-	return EUNIMP;
+-}
+-
+-static
+-void
+-as_zero_region(paddr_t paddr, unsigned npages)
+-{
+-	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+-}
+-
+-int
+-as_prepare_load(struct addrspace *as)
+-{
+-	KASSERT(as->as_pbase1 == 0);
+-	KASSERT(as->as_pbase2 == 0);
+-	KASSERT(as->as_stackpbase == 0);
+-
+-	as->as_pbase1 = getppages(as->as_npages1);
+-	if (as->as_pbase1 == 0) {
+-		return ENOMEM;
+-	}
+-
+-	as->as_pbase2 = getppages(as->as_npages2);
+-	if (as->as_pbase2 == 0) {
+-		return ENOMEM;
+-	}
+-
+-	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+-	if (as->as_stackpbase == 0) {
+-		return ENOMEM;
+-	}
+-	
+-	as_zero_region(as->as_pbase1, as->as_npages1);
+-	as_zero_region(as->as_pbase2, as->as_npages2);
+-	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+-
+-	return 0;
+-}
+-
+-int
+-as_complete_load(struct addrspace *as)
+-{
+-	(void)as;
+-	return 0;
+-}
+-
+-int
+-as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+-{
+-	KASSERT(as->as_stackpbase != 0);
+-
+-	*stackptr = USERSTACK;
+-	return 0;
+-}
+-
+-int
+-as_copy(struct addrspace *old, struct addrspace **ret)
+-{
+-	struct addrspace *new;
+-
+-	new = as_create();
+-	if (new==NULL) {
+-		return ENOMEM;
+-	}
+-
+-	new->as_vbase1 = old->as_vbase1;
+-	new->as_npages1 = old->as_npages1;
+-	new->as_vbase2 = old->as_vbase2;
+-	new->as_npages2 = old->as_npages2;
+-
+-	/* (Mis)use as_prepare_load to allocate some physical memory. */
+-	if (as_prepare_load(new)) {
+-		as_destroy(new);
+-		return ENOMEM;
+-	}
+-
+-	KASSERT(new->as_pbase1 != 0);
+-	KASSERT(new->as_pbase2 != 0);
+-	KASSERT(new->as_stackpbase != 0);
+-
+-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+-		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+-		old->as_npages1*PAGE_SIZE);
+-
+-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+-		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+-		old->as_npages2*PAGE_SIZE);
+-
+-	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+-		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+-		DUMBVM_STACKPAGES*PAGE_SIZE);
+-	
+-	*ret = new;
+-	return 0;
+-}
++///*
++// * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++// *	The President and Fellows of Harvard College.
++// *
++// * Redistribution and use in source and binary forms, with or without
++// * modification, are permitted provided that the following conditions
++// * are met:
++// * 1. Redistributions of source code must retain the above copyright
++// *    notice, this list of conditions and the following disclaimer.
++// * 2. Redistributions in binary form must reproduce the above copyright
++// *    notice, this list of conditions and the following disclaimer in the
++// *    documentation and/or other materials provided with the distribution.
++// * 3. Neither the name of the University nor the names of its contributors
++// *    may be used to endorse or promote products derived from this software
++// *    without specific prior written permission.
++// *
++// * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++// * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++// * SUCH DAMAGE.
++// */
++//
++//#include <types.h>
++//#include <kern/errno.h>
++//#include <lib.h>
++//#include <spl.h>
++//#include <spinlock.h>
++//#include <thread.h>
++//#include <current.h>
++//#include <mips/tlb.h>
++//#include <addrspace.h>
++//#include <vm.h>
++//
++///*
++// * Dumb MIPS-only "VM system" that is intended to only be just barely
++// * enough to struggle off the ground. You should replace all of this
++// * code while doing the VM assignment. In fact, starting in that
++// * assignment, this file is not included in your kernel!
++// */
++//
++///* under dumbvm, always have 48k of user stack */
++//#define DUMBVM_STACKPAGES    12
++//
++///*
++// * Wrap rma_stealmem in a spinlock.
++// */
++//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
++//
++//void
++//vm_bootstrap(void)
++//{
++//	/* Do nothing. */
++//}
++//
++//static
++//paddr_t
++//getppages(unsigned long npages)
++//{
++//	paddr_t addr;
++//
++//	spinlock_acquire(&stealmem_lock);
++//
++//	addr = ram_stealmem(npages);
++//
++//	spinlock_release(&stealmem_lock);
++//	return addr;
++//}
++//
++///* Allocate/free some kernel-space virtual pages */
++//vaddr_t
++//alloc_kpages(int npages)
++//{
++//	paddr_t pa;
++//	pa = getppages(npages);
++//	if (pa==0) {
++//		return 0;
++//	}
++//	return PADDR_TO_KVADDR(pa);
++//}
++//
++//void
++//free_kpages(vaddr_t addr)
++//{
++//	/* nothing - leak the memory. */
++//
++//	(void)addr;
++//}
++//
++//void
++//vm_tlbshootdown_all(void)
++//{
++//	panic("dumbvm tried to do tlb shootdown?!\n");
++//}
++//
++//void
++//vm_tlbshootdown(const struct tlbshootdown *ts)
++//{
++//	(void)ts;
++//	panic("dumbvm tried to do tlb shootdown?!\n");
++//}
++//
++//int
++//vm_fault(int faulttype, vaddr_t faultaddress)
++//{
++//	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
++//	paddr_t paddr;
++//	int i;
++//	uint32_t ehi, elo;
++//	struct addrspace *as;
++//	int spl;
++//
++//	faultaddress &= PAGE_FRAME;
++//
++//	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
++//
++//	switch (faulttype) {
++//	    case VM_FAULT_READONLY:
++//		/* We always create pages read-write, so we can't get this */
++//		panic("dumbvm: got VM_FAULT_READONLY\n");
++//	    case VM_FAULT_READ:
++//	    case VM_FAULT_WRITE:
++//		break;
++//	    default:
++//		return EINVAL;
++//	}
++//
++//	as = curthread->t_addrspace;
++//	if (as == NULL) {
++//		/*
++//		 * No address space set up. This is probably a kernel
++//		 * fault early in boot. Return EFAULT so as to panic
++//		 * instead of getting into an infinite faulting loop.
++//		 */
++//		return EFAULT;
++//	}
++//
++//	/* Assert that the address space has been set up properly. */
++//	KASSERT(as->as_vbase1 != 0);
++//	KASSERT(as->as_pbase1 != 0);
++//	KASSERT(as->as_npages1 != 0);
++//	KASSERT(as->as_vbase2 != 0);
++//	KASSERT(as->as_pbase2 != 0);
++//	KASSERT(as->as_npages2 != 0);
++//	KASSERT(as->as_stackpbase != 0);
++//	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
++//	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
++//	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
++//	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
++//	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
++//
++//	vbase1 = as->as_vbase1;
++//	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
++//	vbase2 = as->as_vbase2;
++//	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
++//	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
++//	stacktop = USERSTACK;
++//
++//	if (faultaddress >= vbase1 && faultaddress < vtop1) {
++//		paddr = (faultaddress - vbase1) + as->as_pbase1;
++//	}
++//	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
++//		paddr = (faultaddress - vbase2) + as->as_pbase2;
++//	}
++//	else if (faultaddress >= stackbase && faultaddress < stacktop) {
++//		paddr = (faultaddress - stackbase) + as->as_stackpbase;
++//	}
++//	else {
++//		return EFAULT;
++//	}
++//
++//	/* make sure it's page-aligned */
++//	KASSERT((paddr & PAGE_FRAME) == paddr);
++//
++//	/* Disable interrupts on this CPU while frobbing the TLB. */
++//	spl = splhigh();
++//
++//	for (i=0; i<NUM_TLB; i++) {
++//		tlb_read(&ehi, &elo, i);
++//		if (elo & TLBLO_VALID) {
++//			continue;
++//		}
++//		ehi = faultaddress;
++//		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
++//		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
++//		tlb_write(ehi, elo, i);
++//		splx(spl);
++//		return 0;
++//	}
++//
++//	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
++//	splx(spl);
++//	return EFAULT;
++//}
++//
++//struct addrspace *
++//as_create(void)
++//{
++//	struct addrspace *as = kmalloc(sizeof(struct addrspace));
++//	if (as==NULL) {
++//		return NULL;
++//	}
++//
++//	as->as_vbase1 = 0;
++//	as->as_pbase1 = 0;
++//	as->as_npages1 = 0;
++//	as->as_vbase2 = 0;
++//	as->as_pbase2 = 0;
++//	as->as_npages2 = 0;
++//	as->as_stackpbase = 0;
++//
++//	return as;
++//}
++//
++//void
++//as_destroy(struct addrspace *as)
++//{
++//	kfree(as);
++//}
++//
++//void
++//as_activate(struct addrspace *as)
++//{
++//	int i, spl;
++//
++//	(void)as;
++//
++//	/* Disable interrupts on this CPU while frobbing the TLB. */
++//	spl = splhigh();
++//
++//	for (i=0; i<NUM_TLB; i++) {
++//		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
++//	}
++//
++//	splx(spl);
++//}
++//
++//int
++//as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
++//		 int readable, int writeable, int executable)
++//{
++//	size_t npages;
++//
++//	/* Align the region. First, the base... */
++//	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
++//	vaddr &= PAGE_FRAME;
++//
++//	/* ...and now the length. */
++//	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
++//
++//	npages = sz / PAGE_SIZE;
++//
++//	/* We don't use these - all pages are read-write */
++//	(void)readable;
++//	(void)writeable;
++//	(void)executable;
++//
++//	if (as->as_vbase1 == 0) {
++//		as->as_vbase1 = vaddr;
++//		as->as_npages1 = npages;
++//		return 0;
++//	}
++//
++//	if (as->as_vbase2 == 0) {
++//		as->as_vbase2 = vaddr;
++//		as->as_npages2 = npages;
++//		return 0;
++//	}
++//
++//	/*
++//	 * Support for more than two regions is not available.
++//	 */
++//	kprintf("dumbvm: Warning: too many regions\n");
++//	return EUNIMP;
++//}
++//
++//static
++//void
++//as_zero_region(paddr_t paddr, unsigned npages)
++//{
++//	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
++//}
++//
++//int
++//as_prepare_load(struct addrspace *as)
++//{
++//	KASSERT(as->as_pbase1 == 0);
++//	KASSERT(as->as_pbase2 == 0);
++//	KASSERT(as->as_stackpbase == 0);
++//
++//	as->as_pbase1 = getppages(as->as_npages1);
++//	if (as->as_pbase1 == 0) {
++//		return ENOMEM;
++//	}
++//
++//	as->as_pbase2 = getppages(as->as_npages2);
++//	if (as->as_pbase2 == 0) {
++//		return ENOMEM;
++//	}
++//
++//	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
++//	if (as->as_stackpbase == 0) {
++//		return ENOMEM;
++//	}
++//
++//	as_zero_region(as->as_pbase1, as->as_npages1);
++//	as_zero_region(as->as_pbase2, as->as_npages2);
++//	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
++//
++//	return 0;
++//}
++//
++//int
++//as_complete_load(struct addrspace *as)
++//{
++//	(void)as;
++//	return 0;
++//}
++//
++//int
++//as_define_stack(struct addrspace *as, vaddr_t *stackptr)
++//{
++//	KASSERT(as->as_stackpbase != 0);
++//
++//	*stackptr = USERSTACK;
++//	return 0;
++//}
++//
++//int
++//as_copy(struct addrspace *old, struct addrspace **ret)
++//{
++//	struct addrspace *new;
++//
++//	new = as_create();
++//	if (new==NULL) {
++//		return ENOMEM;
++//	}
++//
++//	new->as_vbase1 = old->as_vbase1;
++//	new->as_npages1 = old->as_npages1;
++//	new->as_vbase2 = old->as_vbase2;
++//	new->as_npages2 = old->as_npages2;
++//
++//	/* (Mis)use as_prepare_load to allocate some physical memory. */
++//	if (as_prepare_load(new)) {
++//		as_destroy(new);
++//		return ENOMEM;
++//	}
++//
++//	KASSERT(new->as_pbase1 != 0);
++//	KASSERT(new->as_pbase2 != 0);
++//	KASSERT(new->as_stackpbase != 0);
++//
++//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
++//		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
++//		old->as_npages1*PAGE_SIZE);
++//
++//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
++//		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
++//		old->as_npages2*PAGE_SIZE);
++//
++//	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
++//		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
++//		DUMBVM_STACKPAGES*PAGE_SIZE);
++//
++//	*ret = new;
++//	return 0;
++//}
+diff --git a/kern/arch/mips/vm/mipsvm.c b/kern/arch/mips/vm/mipsvm.c
+new file mode 100644
+index 0000000..93d074e
+--- /dev/null
++++ b/kern/arch/mips/vm/mipsvm.c
+@@ -0,0 +1,374 @@
++///*
++// * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++// *	The President and Fellows of Harvard College.
++// *
++// * Redistribution and use in source and binary forms, with or without
++// * modification, are permitted provided that the following conditions
++// * are met:
++// * 1. Redistributions of source code must retain the above copyright
++// *    notice, this list of conditions and the following disclaimer.
++// * 2. Redistributions in binary form must reproduce the above copyright
++// *    notice, this list of conditions and the following disclaimer in the
++// *    documentation and/or other materials provided with the distribution.
++// * 3. Neither the name of the University nor the names of its contributors
++// *    may be used to endorse or promote products derived from this software
++// *    without specific prior written permission.
++// *
++// * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++// * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++// * SUCH DAMAGE.
++// */
++//
++//#include <types.h>
++//#include <kern/errno.h>
++//#include <lib.h>
++//#include <spl.h>
++//#include <spinlock.h>
++//#include <thread.h>
++//#include <current.h>
++//#include <mips/tlb.h>
++//#include <addrspace.h>
++//#include <vm.h>
++//
++///*
++// * Dumb MIPS-only "VM system" that is intended to only be just barely
++// * enough to struggle off the ground. You should replace all of this
++// * code while doing the VM assignment. In fact, starting in that
++// * assignment, this file is not included in your kernel!
++// */
++//
++///* under dumbvm, always have 48k of user stack */
++//#define DUMBVM_STACKPAGES    12
++//
++///*
++// * Wrap rma_stealmem in a spinlock.
++// */
++//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
++//
++//void
++//vm_bootstrap(void)
++//{
++//	/* Do nothing. */
++//}
++//
++//static
++//paddr_t
++//getppages(unsigned long npages)
++//{
++//	paddr_t addr;
++//
++//	spinlock_acquire(&stealmem_lock);
++//
++//	addr = ram_stealmem(npages);
++//
++//	spinlock_release(&stealmem_lock);
++//	return addr;
++//}
++//
++///* Allocate/free some kernel-space virtual pages */
++//vaddr_t
++//alloc_kpages(int npages)
++//{
++//	paddr_t pa;
++//	pa = getppages(npages);
++//	if (pa==0) {
++//		return 0;
++//	}
++//	return PADDR_TO_KVADDR(pa);
++//}
++//
++//void
++//free_kpages(vaddr_t addr)
++//{
++//	/* nothing - leak the memory. */
++//
++//	(void)addr;
++//}
++//
++//void
++//vm_tlbshootdown_all(void)
++//{
++//	panic("dumbvm tried to do tlb shootdown?!\n");
++//}
++//
++//void
++//vm_tlbshootdown(const struct tlbshootdown *ts)
++//{
++//	(void)ts;
++//	panic("dumbvm tried to do tlb shootdown?!\n");
++//}
++//
++//int
++//vm_fault(int faulttype, vaddr_t faultaddress)
++//{
++//	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
++//	paddr_t paddr;
++//	int i;
++//	uint32_t ehi, elo;
++//	struct addrspace *as;
++//	int spl;
++//
++//	faultaddress &= PAGE_FRAME;
++//
++//	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
++//
++//	switch (faulttype) {
++//	    case VM_FAULT_READONLY:
++//		/* We always create pages read-write, so we can't get this */
++//		panic("dumbvm: got VM_FAULT_READONLY\n");
++//	    case VM_FAULT_READ:
++//	    case VM_FAULT_WRITE:
++//		break;
++//	    default:
++//		return EINVAL;
++//	}
++//
++//	as = curthread->t_addrspace;
++//	if (as == NULL) {
++//		/*
++//		 * No address space set up. This is probably a kernel
++//		 * fault early in boot. Return EFAULT so as to panic
++//		 * instead of getting into an infinite faulting loop.
++//		 */
++//		return EFAULT;
++//	}
++//
++//	/* Assert that the address space has been set up properly. */
++//	KASSERT(as->as_vbase1 != 0);
++//	KASSERT(as->as_pbase1 != 0);
++//	KASSERT(as->as_npages1 != 0);
++//	KASSERT(as->as_vbase2 != 0);
++//	KASSERT(as->as_pbase2 != 0);
++//	KASSERT(as->as_npages2 != 0);
++//	KASSERT(as->as_stackpbase != 0);
++//	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
++//	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
++//	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
++//	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
++//	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
++//
++//	vbase1 = as->as_vbase1;
++//	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
++//	vbase2 = as->as_vbase2;
++//	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
++//	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
++//	stacktop = USERSTACK;
++//
++//	if (faultaddress >= vbase1 && faultaddress < vtop1) {
++//		paddr = (faultaddress - vbase1) + as->as_pbase1;
++//	}
++//	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
++//		paddr = (faultaddress - vbase2) + as->as_pbase2;
++//	}
++//	else if (faultaddress >= stackbase && faultaddress < stacktop) {
++//		paddr = (faultaddress - stackbase) + as->as_stackpbase;
++//	}
++//	else {
++//		return EFAULT;
++//	}
++//
++//	/* make sure it's page-aligned */
++//	KASSERT((paddr & PAGE_FRAME) == paddr);
++//
++//	/* Disable interrupts on this CPU while frobbing the TLB. */
++//	spl = splhigh();
++//
++//	for (i=0; i<NUM_TLB; i++) {
++//		tlb_read(&ehi, &elo, i);
++//		if (elo & TLBLO_VALID) {
++//			continue;
++//		}
++//		ehi = faultaddress;
++//		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
++//		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
++//		tlb_write(ehi, elo, i);
++//		splx(spl);
++//		return 0;
++//	}
++//
++//	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
++//	splx(spl);
++//	return EFAULT;
++//}
++//
++///* struct addrspace * */
++///* as_create(void) */
++///* { */
++///* 	struct addrspace *as = kmalloc(sizeof(struct addrspace)); */
++///* 	if (as==NULL) { */
++///* 		return NULL; */
++///* 	} */
++//
++///* 	as->as_vbase1 = 0; */
++///* 	as->as_pbase1 = 0; */
++///* 	as->as_npages1 = 0; */
++///* 	as->as_vbase2 = 0; */
++///* 	as->as_pbase2 = 0; */
++///* 	as->as_npages2 = 0; */
++///* 	as->as_stackpbase = 0; */
++//
++///* 	return as; */
++///* } */
++//
++///* void */
++///* as_destroy(struct addrspace *as) */
++///* { */
++///* 	kfree(as); */
++///* } */
++//
++///* void */
++///* as_activate(struct addrspace *as) */
++///* { */
++///* 	int i, spl; */
++//
++///* 	(void)as; */
++//
++///* 	/\* Disable interrupts on this CPU while frobbing the TLB. *\/ */
++///* 	spl = splhigh(); */
++//
++///* 	for (i=0; i<NUM_TLB; i++) { */
++///* 		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i); */
++///* 	} */
++//
++///* 	splx(spl); */
++///* } */
++//
++///* int */
++///* as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz, */
++///* 		 int readable, int writeable, int executable) */
++///* { */
++///* 	size_t npages;  */
++//
++///* 	/\* Align the region. First, the base... *\/ */
++///* 	sz += vaddr & ~(vaddr_t)PAGE_FRAME; */
++///* 	vaddr &= PAGE_FRAME; */
++//
++///* 	/\* ...and now the length. *\/ */
++///* 	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME; */
++//
++///* 	npages = sz / PAGE_SIZE; */
++//
++///* 	/\* We don't use these - all pages are read-write *\/ */
++///* 	(void)readable; */
++///* 	(void)writeable; */
++///* 	(void)executable; */
++//
++///* 	if (as->as_vbase1 == 0) { */
++///* 		as->as_vbase1 = vaddr; */
++///* 		as->as_npages1 = npages; */
++///* 		return 0; */
++///* 	} */
++//
++///* 	if (as->as_vbase2 == 0) { */
++///* 		as->as_vbase2 = vaddr; */
++///* 		as->as_npages2 = npages; */
++///* 		return 0; */
++///* 	} */
++//
++///* 	/\* */
++///* 	 * Support for more than two regions is not available. */
++///* 	 *\/ */
++///* 	kprintf("dumbvm: Warning: too many regions\n"); */
++///* 	return EUNIMP; */
++///* } */
++//
++///* static */
++///* void */
++///* as_zero_region(paddr_t paddr, unsigned npages) */
++///* { */
++///* 	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE); */
++///* } */
++//
++///* int */
++///* as_prepare_load(struct addrspace *as) */
++///* { */
++///* 	KASSERT(as->as_pbase1 == 0); */
++///* 	KASSERT(as->as_pbase2 == 0); */
++///* 	KASSERT(as->as_stackpbase == 0); */
++//
++///* 	as->as_pbase1 = getppages(as->as_npages1); */
++///* 	if (as->as_pbase1 == 0) { */
++///* 		return ENOMEM; */
++///* 	} */
++//
++///* 	as->as_pbase2 = getppages(as->as_npages2); */
++///* 	if (as->as_pbase2 == 0) { */
++///* 		return ENOMEM; */
++///* 	} */
++//
++///* 	as->as_stackpbase = getppages(DUMBVM_STACKPAGES); */
++///* 	if (as->as_stackpbase == 0) { */
++///* 		return ENOMEM; */
++///* 	} */
++//
++///* 	as_zero_region(as->as_pbase1, as->as_npages1); */
++///* 	as_zero_region(as->as_pbase2, as->as_npages2); */
++///* 	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES); */
++//
++///* 	return 0; */
++///* } */
++//
++///* int */
++///* as_complete_load(struct addrspace *as) */
++///* { */
++///* 	(void)as; */
++///* 	return 0; */
++///* } */
++//
++///* int */
++///* as_define_stack(struct addrspace *as, vaddr_t *stackptr) */
++///* { */
++///* 	KASSERT(as->as_stackpbase != 0); */
++//
++///* 	*stackptr = USERSTACK; */
++///* 	return 0; */
++///* } */
++//
++///* int */
++///* as_copy(struct addrspace *old, struct addrspace **ret) */
++///* { */
++///* 	struct addrspace *new; */
++//
++///* 	new = as_create(); */
++///* 	if (new==NULL) { */
++///* 		return ENOMEM; */
++///* 	} */
++//
++///* 	new->as_vbase1 = old->as_vbase1; */
++///* 	new->as_npages1 = old->as_npages1; */
++///* 	new->as_vbase2 = old->as_vbase2; */
++///* 	new->as_npages2 = old->as_npages2; */
++//
++///* 	/\* (Mis)use as_prepare_load to allocate some physical memory. *\/ */
++///* 	if (as_prepare_load(new)) { */
++///* 		as_destroy(new); */
++///* 		return ENOMEM; */
++///* 	} */
++//
++///* 	KASSERT(new->as_pbase1 != 0); */
++///* 	KASSERT(new->as_pbase2 != 0); */
++///* 	KASSERT(new->as_stackpbase != 0); */
++//
++///* 	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1), */
++///* 		(const void *)PADDR_TO_KVADDR(old->as_pbase1), */
++///* 		old->as_npages1*PAGE_SIZE); */
++//
++///* 	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2), */
++///* 		(const void *)PADDR_TO_KVADDR(old->as_pbase2), */
++///* 		old->as_npages2*PAGE_SIZE); */
++//
++///* 	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase), */
++///* 		(const void *)PADDR_TO_KVADDR(old->as_stackpbase), */
++///* 		DUMBVM_STACKPAGES*PAGE_SIZE); */
++//
++///* 	*ret = new; */
++///* 	return 0; */
++///* } */
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..73cd437 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -330,6 +330,7 @@ file      thread/threadlist.c
+ #
+ 
+ file      vm/kmalloc.c
++file      vm/vm.c
+ 
+ optofffile dumbvm   vm/addrspace.c
+ 
+@@ -367,7 +368,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
+-
++file	     syscall/filesys.c
++file	     syscall/process_support.c
++file	     syscall/process.c
+ #
+ # Startup and initialization
+ #
+diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
+index 6788e97..2aecd91 100644
+--- a/kern/include/addrspace.h
++++ b/kern/include/addrspace.h
+@@ -39,7 +39,33 @@
+ #include "opt-dumbvm.h"
+ 
+ struct vnode;
++//enum reg_state{
++//	READ,
++//	WRITE,
++//	EXECUTE
++//};
++
++struct PTE{
++	vaddr_t va;
++	paddr_t pa;
++	char PTE_P;
++	//int pagenum;
++	char read;
++	char write;
++	char exe;
++	struct PTE *next;
++};
+ 
++struct region{
++	vaddr_t vbase;
++	size_t psize;
++	char read;
++	char write;
++	char exe;
++	//enum reg_state reg_st;
++	int flag;
++	struct region *next;
++};
+ 
+ /* 
+  * Address space - data structure associated with the virtual memory
+@@ -58,6 +84,14 @@ struct addrspace {
+         size_t as_npages2;
+         paddr_t as_stackpbase;
+ #else
++        struct PTE *ptable;
++        struct region *region;
++        int pagenum;
++        vaddr_t heap_base;
++        vaddr_t heap_top;
++        vaddr_t stack_top;
++        vaddr_t stack_base;
++
+         /* Put stuff here for your VM system */
+ #endif
+ };
+diff --git a/kern/include/kern/filesys.h b/kern/include/kern/filesys.h
+new file mode 100644
+index 0000000..e6cdaf1
+--- /dev/null
++++ b/kern/include/kern/filesys.h
+@@ -0,0 +1,31 @@
++#ifndef FILESYS_H_ 
++#define FILESYS_H_ 
++#include <types.h>
++#include <limits.h>
++#include <thread.h>
++#include <synch.h>
++
++ /* File Descriptor Structure */
++ struct fd{
++	char filename[__NAME_MAX];
++        struct vnode *vn; //   - Reference to the underlying file 'object' 
++        off_t offset;     //      - Offset into the file 
++        struct lock *lock;   //- Some form of synchronization 
++        int flags;      // - Flags with which the file was opened 
++        int ref_count; //- Reference count 
++ };
++
++ 
++ int sys_open(const char *fdesc_name, int flags, mode_t mode, int *retval);
++ int sys_close(int fh, int *retval);
++ int sys_write(int fd, const void *buf, size_t size, int *retval);
++ int sys_read(int fd, void *buf, size_t buflen, int *retval);
++ int sys_lseek(int fd, off_t pos, int whence, off_t *ret);
++ int sys_dup2(int oldfd, int newfd, int *retval);
++ int sys_chdir(const char *pathname, int *retval);
++ int sys___getcwd(char *buf, size_t buflen, int *retval);
++
++int fdesc_init(void);
++
++ #endif /* FILESYS_H_ */
++
+diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+index 3fad3f2..3863055 100644
+--- a/kern/include/kern/limits.h
++++ b/kern/include/kern/limits.h
+@@ -49,13 +49,13 @@
+  */
+ 
+ /* Longest filename (without directory) not including null terminator */
+-#define __NAME_MAX      255
++#define __NAME_MAX     60 //255
+ 
+ /* Longest full path name */
+-#define __PATH_MAX      1024
++#define __PATH_MAX      30//1024
+ 
+ /* Max bytes for an exec function */
+-#define __ARG_MAX       (64 * 1024)
++#define __ARG_MAX       100//(64 * 1024)
+ 
+ 
+ /*
+@@ -91,7 +91,7 @@
+  */
+ 
+ /* Max open files per process */
+-#define __OPEN_MAX      128
++#define __OPEN_MAX      50//128
+ 
+ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
+ #define __IOV_MAX       1024
+diff --git a/kern/include/kern/process.h b/kern/include/kern/process.h
+new file mode 100644
+index 0000000..83094b1
+--- /dev/null
++++ b/kern/include/kern/process.h
+@@ -0,0 +1,22 @@
++#ifndef _PROCESS_H_
++#define _PROCESS_H_
++#include <types.h>
++#include <limits.h>
++#include <thread.h>
++#include <synch.h>
++extern struct process* ptable[130];
++
++struct process
++{ pid_t ppid;
++bool exited;
++int exitcode;
++struct thread *self;
++struct semaphore *sem_proc;
++//struct lock *lock_proc;
++};
++
++pid_t pid_alloc(void);
++int process_create(pid_t pid, struct thread *thread);
++void process_destroy(pid_t pid);
++
++#endif /* _PROCESS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..2943d48 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,7 +74,12 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
+-        // add what you need here
++        struct wchan *lk_wchan;
++	struct thread *lk_cur;
++	struct spinlock lk_lock;
++        volatile bool locked;
++        
++	// add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+ 
+@@ -113,7 +118,9 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
+-        // add what you need here
++        struct wchan *cv_wchan;
++	struct lock *cv_lock;
++	// add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+ 
+@@ -143,14 +150,20 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++	struct lock *r_lock;
++	struct lock *w_lock;
++	//struct lock *Q_lock;               //limit reader if writer waits
++	struct lock *rw_lock;
++	volatile int readcount;
++	volatile int writecount;
+ };
+ 
+-struct rwlock * rwlock_create(const char *);
+-void rwlock_destroy(struct rwlock *);
++struct rwlock *rwlock_create(const char *name);
++void rwlock_destroy(struct rwlock *rwlock);
+ 
+-void rwlock_acquire_read(struct rwlock *);
+-void rwlock_release_read(struct rwlock *);
+-void rwlock_acquire_write(struct rwlock *);
+-void rwlock_release_write(struct rwlock *);
++void rwlock_acquire_read(struct rwlock *rwlock);
++void rwlock_release_read(struct rwlock *rwlock);
++void rwlock_acquire_write(struct rwlock *rwlock);
++void rwlock_release_write(struct rwlock *rwlock);
+ 
+ #endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..d2bdc65 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -30,6 +30,7 @@
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+ 
++#include <kern/filesys.h>
+ 
+ struct trapframe; /* from <machine/trapframe.h> */
+ 
+@@ -45,7 +46,7 @@ void syscall(struct trapframe *tf);
+ 
+ /* Helper for fork(). You write this. */
+ void enter_forked_process(struct trapframe *tf);
+-
++void child_fork_entry(void* data1, unsigned long data2);
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ 		       vaddr_t entrypoint);
+@@ -57,5 +58,21 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ 
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_open(const char *fdesc_name, int flags, mode_t mode, int *retval);
++ int sys_close(int fh, int *retval);
++ int sys_write(int fd, const void *buf, size_t size, int *retval);
++ int sys_read(int fd, void *buf, size_t buflen, int *retval);
++ int sys_lseek(int fd, off_t pos, int whence, off_t *ret);
++ int sys_dup2(int oldfd, int newfd, int *retval);
++ int sys_chdir(const char *pathname, int *retval);
++ int sys___getcwd(char *buf, size_t buflen, int *retval);
++
++int sys_fork(struct trapframe* tf, int *retval);
++int sys_execv(int *retval,const char *program, char **args);
++int sys_getpid(int *retval);
++int sys__exit(int exitcode);
++int sys_waitpid(int *retval,pid_t pid, int *status, int options);
++int sys_sbrk(intptr_t amount,int *retval);
++
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..f6ac263 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname, int argc, char **argv);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..5cd9383 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,6 +38,8 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
++#include <kern/filesys.h>
++#include<limits.h>
+ 
+ struct addrspace;
+ struct cpu;
+@@ -104,7 +106,8 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	pid_t t_pid;
++	struct fd *fdtable[OPEN_MAX];
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+diff --git a/kern/include/vm.h b/kern/include/vm.h
+index e4e73d0..99e8de4 100644
+--- a/kern/include/vm.h
++++ b/kern/include/vm.h
+@@ -29,14 +29,35 @@
+ 
+ #ifndef _VM_H_
+ #define _VM_H_
+-
++#include <machine/vm.h>
+ /*
+  * VM system-related definitions.
+  *
+  * You'll probably want to add stuff here.
+  */
++enum page_state{
++	FREE,
++	FIXED,
++	DIRTY,
++	CLEAN
++};
++
++struct coremap_entry{
++	vaddr_t va;
++	vaddr_t pa;
++	struct addrspace* as;
++	enum page_state pgstate;
++	int chunk;
++	int pid;
++};
++struct coremap_entry* coremap;
++
+ 
+ 
++vaddr_t page_alloc(struct addrspace* newas,vaddr_t va);
++vaddr_t page_nalloc(int npages);
++void page_free(vaddr_t va, struct addrspace* as);
++void make_page_avail(struct coremap_entry *coremap);
+ #include <machine/vm.h>
+ 
+ /* Fault-type arguments to vm_fault() */
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..fb5dd52 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -1,3 +1,4 @@
++//weihaoqu@buffalo.edu
+ /*
+  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+  *	The President and Fellows of Harvard College.
+@@ -100,8 +101,8 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+-		GROUP_VERSION, buildconfig, buildversion);
++
++	kprintf("weihaoqu@buffalo.edu's system version %s (%s #%d)\n", GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+ 	/* Early initialization. */
+@@ -202,9 +203,7 @@ sys_reboot(int code)
+  */
+ void
+ kmain(char *arguments)
+-{
+-	boot();
+-
++{       boot();
+ 	menu(arguments);
+ 
+ 	/* Should not get here */
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..1cd38f9 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -43,7 +43,8 @@
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
+-
++#include <kern/process.h>
++#include <kern/filesys.h>
+ /*
+  * In-kernel menu and command dispatcher.
+  */
+@@ -100,10 +101,11 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname, nargs, args);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
++			sys__exit(-1);
+ 		return;
+ 	}
+ 
+@@ -115,7 +117,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+  *
+  * Note that this does not wait for the subprogram to finish, but
+  * returns immediately to the menu. This is usually not what you want,
+- * so you should have it call your system-calls-assignment waitpid
++ * so you should have it call your system-calls-assignment 
+  * code after forking.
+  *
+  * Also note that because the subprogram's thread uses the "args"
+@@ -132,16 +134,18 @@ common_prog(int nargs, char **args)
+ 	kprintf("Warning: this probably won't work with a "
+ 		"synchronization-problems kernel.\n");
+ #endif
+-
++	struct thread *cthread;
++	
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&cthread);
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+ 	}
+-
++	P(ptable[cthread->t_pid]->sem_proc);
++	
+ 	return 0;
+ }
+ 
+@@ -491,7 +495,7 @@ cmd_mainmenu(int n, char **a)
+ {
+ 	(void)n;
+ 	(void)a;
+-
++	
+ 	showmenu("OS/161 kernel menu", mainmenu);
+ 	return 0;
+ }
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..febf782 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -47,25 +47,67 @@
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
++static struct lock *male_lock;
++static struct lock *female_lock;
++static struct lock *matchmaker_lock;
++
++static struct semaphore *count1;
++static struct semaphore *count2;
++static struct semaphore *count3;
++
+ void whalemating_init() {
+-  return;
++  	
++	
++	male_lock = lock_create("male_lock");
++  	DEBUGASSERT(male_lock != NULL);
++	female_lock = lock_create("female_lock");
++  	DEBUGASSERT(female_lock != NULL);
++	matchmaker_lock = lock_create("matchmaker_lock");
++  	DEBUGASSERT(matchmaker_lock != NULL);
++	count1 = sem_create("count1",0);
++  	DEBUGASSERT(count1 != NULL);	
++	count2 = sem_create("count2",0);
++  	DEBUGASSERT(count2 != NULL);	
++	count3 = sem_create("count3",0);
++  	DEBUGASSERT(count3 != NULL);	
++//return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
+-  return;
++sem_destroy(count3);
++sem_destroy(count2);
++sem_destroy(count1);
++
++lock_destroy(matchmaker_lock);  
++lock_destroy(female_lock);  
++lock_destroy(male_lock);  
++
++
++//return;
+ }
+ 
+ void
+ male(void *p, unsigned long which)
+-{
++{	
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
+-  male_start();
+-	// Implement this function 
++male_start();
++	
++	lock_acquire(male_lock);
++	
++	V(count1);
++	P(count2);
++	
++	
++	
++	
++	
++	lock_release(male_lock);		
++// Implement this function 
+   male_end();
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+@@ -76,12 +118,22 @@ male(void *p, unsigned long which)
+ 
+ void
+ female(void *p, unsigned long which)
+-{
++{	
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++
+   female_start();
+-	// Implement this function 
++	lock_acquire(female_lock);
++	
++	
++	V(count2);
++	P(count3);
++	
++	
++	
++	lock_release(female_lock);	
++	
++// Implement this function 
+   female_end();
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+@@ -92,11 +144,22 @@ female(void *p, unsigned long which)
+ 
+ void
+ matchmaker(void *p, unsigned long which)
+-{
++{	
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
+   matchmaker_start();
++	
++	lock_acquire(matchmaker_lock);
++	
++	V(count3);
++	P(count1);
++	
++	
++	
++	
++	
++	lock_release(matchmaker_lock);
+ 	// Implement this function 
+   matchmaker_end();
+   
+@@ -136,8 +199,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++static struct lock *whole_lock;
++static struct lock *lock_0;
++static struct lock *lock_1;
++static struct lock *lock_2;
++static struct lock *lock_3;
++static struct semaphore *sem;
+ 
+ void stoplight_init() {
++	whole_lock = lock_create("whole_lock");
++	DEBUGASSERT(whole_lock != NULL);
++	lock_0 = lock_create("lock_0");
++  	DEBUGASSERT(lock_0 != NULL);
++	lock_1 = lock_create("lock_1");
++  	DEBUGASSERT(lock_1 != NULL);
++	lock_2 = lock_create("lock_2");
++  	DEBUGASSERT(lock_2 != NULL);
++	lock_3 = lock_create("lock_3");
++  	DEBUGASSERT(lock_3 != NULL);
++	sem = sem_create("sem",2);
++  	DEBUGASSERT(sem != NULL);
+   return;
+ }
+ 
+@@ -145,15 +226,92 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
+-  return;
++	sem_destroy(sem);
++	lock_destroy(lock_3);
++	lock_destroy(lock_2);  
++	lock_destroy(lock_1);  
++	lock_destroy(lock_0);  
++	lock_destroy(whole_lock);
++  	return;
+ }
+ 
+ void
+ gostraight(void *p, unsigned long direction)
+-{
++{	 int X;
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-  
++  	int i = 0;
++	X=direction;
++	lock_acquire(whole_lock);
++	switch(X){
++		case 0: 
++			lock_acquire(lock_0);
++			break;
++		case 1:
++			lock_acquire(lock_1);
++			break;
++		case 2:
++			lock_acquire(lock_2);
++			break;
++		case 3:
++			lock_acquire(lock_3);
++			break;
++	}
++	inQuadrant(	X);
++	P(sem);
++	if(sem->sem_count>0) {
++	lock_release(whole_lock);
++	i=1;
++	}
++	switch((X+3)%4){
++		case 0: 
++			lock_acquire(lock_0);
++			break;
++		case 1:
++			lock_acquire(lock_1);
++			break;
++		case 2:
++			lock_acquire(lock_2);
++			break;
++		case 3:
++			lock_acquire(lock_3);
++			break;
++	}
++	inQuadrant(	(X+3)%4);
++	switch(X){
++		case 0: 
++			lock_release(lock_0);
++			break;
++		case 1:
++			lock_release(lock_1);
++			break;
++		case 2:
++			lock_release(lock_2);
++			break;
++		case 3:
++			lock_release(lock_3);
++			break;
++	}	
++	leaveIntersection();
++	V(sem);
++	
++	switch((X+3)%4){
++		case 0: 
++			lock_release(lock_0);
++			break;
++		case 1:
++			lock_release(lock_1);
++			break;
++		case 2:
++			lock_release(lock_2);
++			break;
++		case 3:
++			lock_release(lock_3);
++			break;
++	}	
++	if (i==0)
++	lock_release(whole_lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +323,109 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-  
++  	int i =0;
++	int X=direction;
++	lock_acquire(whole_lock);
++	switch(X){
++		case 0: 
++			lock_acquire(lock_0);
++			break;
++		case 1:
++			lock_acquire(lock_1);
++			break;
++		case 2:
++			lock_acquire(lock_2);
++			break;
++		case 3:
++			lock_acquire(lock_3);
++			break;
++	}
++	inQuadrant(	X);
++	P(sem);
++	if(sem->sem_count>0) {
++	lock_release(whole_lock);
++	i=1;
++	}
++	switch((X+3)%4){
++		case 0: 
++			lock_acquire(lock_0);
++			break;
++		case 1:
++			lock_acquire(lock_1);
++			break;
++		case 2:
++			lock_acquire(lock_2);
++			break;
++		case 3:
++			lock_acquire(lock_3);
++			break;
++	}
++	inQuadrant(	(X+3)%4);
++	switch(X){
++		case 0: 
++			lock_release(lock_0);
++			break;
++		case 1:
++			lock_release(lock_1);
++			break;
++		case 2:
++			lock_release(lock_2);
++			break;
++		case 3:
++			lock_release(lock_3);
++			break;
++	}	
++	switch((X+2)%4){
++		case 0: 
++			lock_acquire(lock_0);
++			break;
++		case 1:
++			lock_acquire(lock_1);
++			break;
++		case 2:
++			lock_acquire(lock_2);
++			break;
++		case 3:
++			lock_acquire(lock_3);
++			break;
++	}
++	inQuadrant(	(X+2)%4);
++	
++	switch((X+3)%4){
++		case 0: 
++			lock_release(lock_0);
++			break;
++		case 1:
++			lock_release(lock_1);
++			break;
++		case 2:
++			lock_release(lock_2);
++			break;
++		case 3:
++			lock_release(lock_3);
++			break;
++	}	
++	leaveIntersection();
++	V(sem);
++	
++
++	switch((X+2)%4){
++		case 0: 
++			lock_release(lock_0);
++			break;
++		case 1:
++			lock_release(lock_1);
++			break;
++		case 2:
++			lock_release(lock_2);
++			break;
++		case 3:
++			lock_release(lock_3);
++			break;
++	}	
++	if (i==0)
++	lock_release(whole_lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +437,50 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++	int i = 0;
++ 	int X=direction;
++	lock_acquire(whole_lock);
++	switch(X){
++		case 0: 
++			lock_acquire(lock_0);
++			break;
++		case 1:
++			lock_acquire(lock_1);
++			break;
++		case 2:
++			lock_acquire(lock_2);
++			break;
++		case 3:
++			lock_acquire(lock_3);
++			break;
++	}
++	inQuadrant(	X);
++	P(sem);
++	if(sem->sem_count>0) {
++	lock_release(whole_lock);
++	i=1;
++	}
++	leaveIntersection();
++	V(sem);
++	
+ 
++	switch(X){
++		case 0: 
++			lock_release(lock_0);
++			break;
++		case 1:
++			lock_release(lock_1);
++			break;
++		case 2:
++			lock_release(lock_2);
++			break;
++		case 3:
++			lock_release(lock_3);
++			break;
++	}	
++	if (i==0)
++	lock_release(whole_lock);
++	
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/.filesys.c.swp b/kern/syscall/.filesys.c.swp
+new file mode 100644
+index 0000000..3dfd450
+Binary files /dev/null and b/kern/syscall/.filesys.c.swp differ
+diff --git a/kern/syscall/filesys.c b/kern/syscall/filesys.c
+new file mode 100644
+index 0000000..05f0e67
+--- /dev/null
++++ b/kern/syscall/filesys.c
+@@ -0,0 +1,450 @@
++#include <syscall.h> 
++#include <lib.h> 
++#include <vfs.h> 
++#include <vnode.h> 
++#include <stdarg.h> 
++#include <types.h> 
++#include <kern/errno.h> 
++#include <kern/fcntl.h> 
++#include <limits.h> 
++#include <uio.h> 
++#include <kern/iovec.h> 
++#include <synch.h> 
++#include <current.h> 
++#include <copyinout.h> 
++#include <kern/seek.h> 
++#include <kern/stat.h> 
++#include <kern/filesys.h> 
++
++int fdesc_init(void) { 
++	int result1;
++	struct vnode *v1;
++	curthread->fdtable[0] = (struct fd *)kmalloc(sizeof(struct fd));
++	if (curthread->fdtable[0]==NULL) {return ENOMEM;}
++	char fname1[5]="con:";
++	result1 = vfs_open(fname1, O_RDONLY, 0664, &v1);
++
++	if(result1){
++		kfree(curthread->fdtable[0]);
++		return EINVAL;
++	}
++	
++	curthread->fdtable[0]->vn=v1;
++	strcpy(curthread->fdtable[0]->filename,fname1);
++	curthread->fdtable[0]->ref_count=1;
++	curthread->fdtable[0]->flags = O_RDONLY;
++	curthread->fdtable[0]->offset = 0;   
++	curthread->fdtable[0]->lock = lock_create("STDIN");
++	if (curthread->fdtable[0]->lock==NULL) return ENOMEM;
++
++	int result2;
++	struct vnode *v2;
++	curthread->fdtable[1] = (struct fd *)kmalloc(sizeof(struct fd));
++
++	if (curthread->fdtable[1] ==NULL) {return ENOMEM;}
++	char fname2[5]="con:";
++	result2 = vfs_open(fname2, O_WRONLY, 0664, &v2);
++
++	if(result2){
++		kfree(curthread->fdtable[1] );
++		return EINVAL;
++	}
++	
++	curthread->fdtable[1] ->vn=v2;
++	strcpy(curthread->fdtable[1]->filename,fname2);
++	curthread->fdtable[1] ->ref_count=1;
++	curthread->fdtable[1] ->flags = O_WRONLY;
++	curthread->fdtable[1] ->offset = 0;   
++	curthread->fdtable[1] ->lock = lock_create("STDOUT");
++	if (curthread->fdtable[1] ->lock==NULL) return ENOMEM; 
++
++	int result3;
++	struct vnode *v3;
++
++	curthread->fdtable[2]  = (struct fd *)kmalloc(sizeof(struct fd));
++
++	if (curthread->fdtable[2]==NULL) {return ENOMEM;}
++	char fname3[5]="con:";
++	result3 = vfs_open(fname3, O_WRONLY, 0664, &v3);
++
++	if(result3){
++		kfree(curthread->fdtable[2]);
++		return EINVAL;
++	}
++	
++	curthread->fdtable[2]->vn=v3;
++	strcpy(curthread->fdtable[2]->filename,fname3);
++	curthread->fdtable[2]->ref_count=1;
++	curthread->fdtable[2]->flags = O_WRONLY;
++	curthread->fdtable[2]->offset = 0;   
++	curthread->fdtable[2]->lock = lock_create("STDERR");
++	if (curthread->fdtable[2]->lock==NULL) return ENOMEM;
++	
++	return 0; 
++}  
++
++int sys_open(const char *fdesc_name, int flags, mode_t mode , int *retval) { 
++	if(fdesc_name==NULL) return EFAULT;
++	if(fdesc_name>=(char *)0x80000000)return EFAULT;
++	if(fdesc_name==(void *)0x40000000)return EFAULT;
++
++	int result=0, index = 3;
++	struct vnode *vn; 
++ 	char *fname; 
++	size_t len;
++        fname = (char *)kmalloc(sizeof(char)*PATH_MAX);
++         if(copyinstr((const_userptr_t)fdesc_name, fname, PATH_MAX, &len)){
++                kfree(fname);
++		*retval = -1;
++                return EFAULT;
++        }
++
++	while(curthread->fdtable[index] != NULL){
++		if(index <OPEN_MAX) index++;
++	}
++ 
++ 	if(index == OPEN_MAX) { 
++		kfree(fname);
++		
++ 		return EMFILE;  //fdtable[] is fulled no more valid place.
++ 	} 
++ 	curthread->fdtable[index] = (struct fd*)kmalloc(sizeof(struct fd)); 
++	
++	result = vfs_open(fname,flags,mode,&vn); 
++	if(result) { 
++ 		kfree(curthread->fdtable[index]); 
++		kfree(fname);
++		
++ 		curthread->fdtable[index] = NULL; 
++ 		return result; 
++ 	} 
++  	strcpy(curthread->fdtable[index]->filename,fname);
++	curthread->fdtable[index]->lock= lock_create(fname); 
++	
++	kfree(fname);
++	if(curthread->fdtable[index]->lock == NULL) return ENOMEM;
++ 	curthread->fdtable[index]->vn = vn; 
++ 	curthread->fdtable[index]->flags = flags; 
++ 	curthread->fdtable[index]->ref_count = 1; 
++ 	curthread->fdtable[index]->offset = 0; 
++ 	
++	
++  	
++	
++	*retval = index;
++ 	return 0; 
++ } 
++ 
++ 
++int sys_close(int fh, int *retval) { 
++
++ 	if(fh >= OPEN_MAX ){
++		*retval = -1;
++		return EBADF;
++	}
++
++	if(fh < 0) { 
++		*retval = -1;
++ 		return EBADF;  //not valid location in fdtable[]
++ 	} 
++
++ 	if(curthread->fdtable[fh] == NULL) { 
++		*retval = -1;
++ 		return EBADF;  // already empty or closed so that fdtable[fh] is closed
++ 	}  
++ 
++ 	if(curthread->fdtable[fh]->vn == NULL) { 
++		*retval = -1;
++ 		return EBADF;  // if there is no valid fdesc inside of fdtable
++ 	} 
++  	
++ 	if(curthread->fdtable[fh]->ref_count == 1) {  
++ 		VOP_CLOSE(curthread->fdtable[fh]->vn);
++		curthread->fdtable[fh]->ref_count =0;
++                lock_destroy(curthread->fdtable[fh]->lock);
++		kfree(curthread->fdtable[fh]); 
++ 		curthread->fdtable[fh] = NULL;
++ 	}else curthread->fdtable[fh]->ref_count--;
++   	int *k=kmalloc(sizeof(int));
++	kfree(k);
++	*retval = 0;
++ 	return 0;  
++} 
++
++int sys_read(int fd, void *buf, size_t buflen, int *retval){
++	if(fd >= OPEN_MAX) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(fd < 0) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(curthread->fdtable[fd] == NULL) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(buf==NULL) return EFAULT;
++	if(buf>=(void*)0x80000000)return EFAULT;
++	if(buf==(void *)0x40000000)return EFAULT;
++
++	if(curthread->fdtable[fd]->flags == O_WRONLY) {
++		*retval = -1;
++		return EBADF;
++	}
++	struct uio u;
++	struct iovec i;
++	
++	lock_acquire(curthread->fdtable[fd]->lock);
++
++	i.iov_ubase = (userptr_t)buf;
++	i.iov_len = buflen;
++	u.uio_iov = &i;
++	u.uio_iovcnt = 1;
++	u.uio_offset = curthread->fdtable[fd]->offset;
++	u.uio_resid = buflen;
++	u.uio_segflg = UIO_USERSPACE;
++	u.uio_rw = UIO_READ;
++	u.uio_space = curthread->t_addrspace;
++
++	int result = VOP_READ(curthread->fdtable[fd]->vn, &u);
++	if(result){
++		lock_release(curthread->fdtable[fd]->lock);
++		
++		return result;
++	}
++	curthread->fdtable[fd]->offset = u.uio_offset;
++	*retval = buflen - u.uio_resid;
++	lock_release(curthread->fdtable[fd]->lock);
++	
++	return 0;
++}
++
++int sys_write(int fd, const void *buf, size_t buflen, int *retval){
++
++	if(fd >= OPEN_MAX) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(fd < 0) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(curthread->fdtable[fd] == NULL) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(buf==NULL){
++		*retval = -1;
++		 return EFAULT;
++	}
++	if(buf>=(void*)0x80000000)return EFAULT;
++		if(buf==(void *)0x40000000)return EFAULT;
++
++	if(curthread->fdtable[fd]->flags == O_RDONLY) {
++		*retval = -1;
++		return EBADF;
++	}
++	struct uio u;
++	struct iovec i;
++	
++	lock_acquire(curthread->fdtable[fd]->lock);
++
++	i.iov_ubase = (userptr_t)buf;
++	i.iov_len = buflen;
++	u.uio_iov = &i;
++	u.uio_iovcnt = 1;
++	u.uio_offset = curthread->fdtable[fd]->offset;
++	u.uio_resid = buflen;
++	u.uio_segflg = UIO_USERSPACE;
++	u.uio_rw = UIO_WRITE;
++	u.uio_space = curthread->t_addrspace;
++
++	int result = VOP_WRITE(curthread->fdtable[fd]->vn, &u);
++	if(result){
++		lock_release(curthread->fdtable[fd]->lock);
++		
++		return result;
++	}
++	curthread->fdtable[fd]->offset = u.uio_offset;
++	*retval = buflen - u.uio_resid;
++	lock_release(curthread->fdtable[fd]->lock);
++
++	return 0;
++}
++
++int sys_dup2(int oldfd, int newfd, int *retval){
++	int result = 0;
++	if(oldfd >= OPEN_MAX){ 
++		*retval = -1;
++		 return EBADF;
++	}
++	if(oldfd<0){
++		*retval = -1;
++		return EBADF;
++	}
++	if(newfd>=OPEN_MAX){
++		*retval = -1;
++		return EBADF;
++	}
++	if(newfd<0){
++		*retval = -1;
++		return EBADF;
++	}
++	if(newfd == oldfd){
++		*retval = newfd;
++		return 0;
++	}
++	if(curthread->fdtable[oldfd] == NULL) {
++		*retval = -1;
++		return EBADF;
++	}
++	if(curthread->fdtable[newfd] != NULL){ 
++		result = sys_close(newfd,retval);
++		if(result){ 
++			*retval = -1;
++			return EBADF;
++		}
++	}
++	if(newfd>=0&&newfd<3){
++		*retval=newfd;
++		return 0;
++	}
++
++	curthread->fdtable[newfd] = curthread->fdtable[oldfd];
++
++	*retval = newfd;
++	return 0;
++}
++
++int sys_lseek(int fd, off_t pos, int whence, off_t *retval){
++	if(fd >= OPEN_MAX){
++		 *retval = (off_t)-1;
++		 return EBADF;
++	}
++	if(fd < 0) {
++		*retval = (off_t)-1;
++		return EBADF;
++	}
++	if(curthread->fdtable[fd] == NULL) {
++		*retval = (off_t)-1;
++		return EBADF;
++	}
++	
++	struct stat s; 
++	off_t noffset, size, curr, pos1;
++	int result = 0;
++	
++	lock_acquire(curthread->fdtable[fd]->lock);	
++	
++	if(VOP_STAT(curthread->fdtable[fd]->vn, &s)){
++		lock_release(curthread->fdtable[fd]->lock);
++		*retval = (off_t)-1;
++		return EBADF;
++	}
++	size = s.st_size;
++	pos1 = pos;
++	result = strcmp(curthread->fdtable[fd]->filename, "null");
++	if(result == 0){
++		lock_release(curthread->fdtable[fd]->lock);
++		*retval = (off_t)-1;
++		return ESPIPE;
++	}
++	if(whence == SEEK_SET){
++		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos1));
++		if(result){
++			lock_release(curthread->fdtable[fd]->lock);	
++			*retval =(off_t) -1;
++			return EINVAL;
++		}
++		noffset = pos1;
++	}else if(whence == SEEK_CUR){
++		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos1+curr));
++		if(result){
++			lock_release(curthread->fdtable[fd]->lock);	
++			*retval =(off_t) -1;
++			return ESPIPE;
++		}
++		curr = curthread->fdtable[fd]->offset;
++		noffset = pos1+curr;
++	}else if(whence == SEEK_END){
++		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos + size));
++		if(result){
++			lock_release(curthread->fdtable[fd]->lock);		
++			*retval =(off_t) -1;
++			return EINVAL;
++		}
++		noffset = pos1 + size;
++	}else{
++		lock_release(curthread->fdtable[fd]->lock);
++		*retval = (off_t)-1;
++		return EINVAL;
++	}
++	curthread->fdtable[fd]->offset = noffset;
++	
++	*retval = noffset;
++	lock_release(curthread->fdtable[fd]->lock);
++	return 0;
++}
++
++int sys_chdir(const char *pathname, int *retval){
++	char *path;
++	//size_t len;
++	if (pathname==NULL) return EFAULT;
++	if (pathname>=(char*)0x80000000) return EFAULT;
++	if (pathname==(void*)0x40000000) return EFAULT;
++
++	path = (char *)kmalloc(sizeof(char)*PATH_MAX);
++	int result = 0;
++	result = copyin((const_userptr_t)pathname, path, sizeof(pathname));
++	if(result){
++		kfree(path);
++		*retval = -1;		
++		return EFAULT;
++	}
++	result = vfs_chdir(path);
++	if(result) { 
++		kfree(path);
++		
++		return ENOTDIR;
++	}
++	*retval = 0;
++	kfree(path);
++	return 0;
++}
++
++int sys___getcwd(char *buf, size_t buflen, int *retval){
++	struct uio u;
++	struct iovec i;
++	if(buf==NULL) return EFAULT;
++	if(buf>=(char*)0x80000000) return EFAULT;
++	if(buf==(char*)0x40000000) return EFAULT;
++	
++	//char *nbuf=(char *)kmalloc(sizeof(char)*buflen);	
++	int result = 0;
++	//if(copyinstr((const_userptr_t)buf, nbuf, PATH_MAX, &buflen)){
++	//	 *retval = -1;
++	//	 return EFAULT;
++	//}
++
++	i.iov_ubase = (userptr_t)buf;
++	i.iov_len = (buflen -1);
++	u.uio_iov = &i;
++	u.uio_iovcnt = 1;
++	u.uio_offset = (off_t)0;
++	u.uio_resid = (buflen-1);
++	u.uio_segflg = UIO_USERSPACE;
++	u.uio_rw = UIO_READ;
++	u.uio_space = curthread->t_addrspace;
++	
++	
++	result = vfs_getcwd(&u);
++	if(result) {
++		
++		return ENOENT;
++	}
++	int re = strlen(buf);
++		
++	*retval = re;
++	return 0;
++}
+diff --git a/kern/syscall/process.c b/kern/syscall/process.c
+new file mode 100644
+index 0000000..6586990
+--- /dev/null
++++ b/kern/syscall/process.c
+@@ -0,0 +1,73 @@
++#include <types.h>
++#include <kern/errno.h>
++#include <lib.h>
++#include <array.h>
++#include <cpu.h>
++#include <spl.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <threadlist.h>
++#include <threadprivate.h>
++#include <current.h>
++#include <synch.h>
++#include <addrspace.h>
++#include <mainbus.h>
++#include <vnode.h>
++#include <kern/process.h>
++#include <kern/filesys.h>
++//struct spinlock pt_lk=SPINLOCK_INITIALIZER;
++ //void thread_destroy(struct thread *thread);
++struct process *ptable[130];
++
++pid_t pid_alloc(void){
++	//spinlock_acquire(&pt_lk);
++	for (int i=2; i<130; i++){
++		if (ptable[i]==NULL){
++		return (pid_t)i;
++		}
++	}
++	return (pid_t)-2; 
++}
++
++int  process_create(pid_t pid, struct thread *thread){
++		struct process *proc=kmalloc(sizeof(struct process));
++		if(proc==NULL)
++			return ENOMEM;
++		proc->ppid=-1;
++		proc->exited=false;
++		proc->exitcode=0;
++		proc->self=thread;
++		proc->sem_proc=sem_create("sema_process",0);
++		if (proc->sem_proc==NULL) {
++			 kfree(proc);
++			return ENOMEM;
++		}
++		//proc->lock_proc=lock_create("lock_process");
++		//if (proc->lock_proc==NULL) {
++		//	cv_destroy(proc->cv_proc); 
++		//	kfree(proc);
++		//	return ENOMEM;
++		//}
++		ptable[pid]=proc;
++		//spinlock_release(&pt_lk);
++		return 0;
++}
++
++void process_destroy(pid_t pid){
++	//lock_destroy(ptable[pid]->lock_proc);
++	sem_destroy(ptable[pid]->sem_proc);
++	
++	//int ret=0;
++	//int k=0;	
++	//for(int a=0;a<OPEN_MAX;a++){
++	//if (ptable[pid]->self->fdtable[a]!=NULL){
++	//k=sys_close(a,&ret);
++	//	}
++	//}
++	
++	//kfree(ptable[pid]->self->t_name);
++	//kfree(ptable[pid]->self);
++	kfree(ptable[pid]);
++	ptable[pid]=NULL;
++}
+diff --git a/kern/syscall/process_support.c b/kern/syscall/process_support.c
+new file mode 100644
+index 0000000..40b72a6
+--- /dev/null
++++ b/kern/syscall/process_support.c
+@@ -0,0 +1,354 @@
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <kern/wait.h>
++#include <copyinout.h>
++#include <uio.h>
++#include <lib.h>
++#include <spl.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <syscall.h>
++#include <test.h>
++#include <synch.h>
++#include <kern/seek.h>
++#include <stat.h>
++#include <kern/process.h>
++#include <kern/filesys.h>
++
++struct process* ptable[130];
++int sys_fork(struct trapframe *tf,int *retval ){
++	
++	struct trapframe* ktf=kmalloc(sizeof(struct trapframe));
++	
++	if(ktf==NULL){
++	return ENOMEM;
++	}
++	struct addrspace *cspace=NULL;
++	//int k =pid_alloc();
++	//ptable[k]=(void*)(-3);
++	memcpy(ktf,tf,sizeof(struct trapframe));
++	 int err=as_copy(curthread->t_addrspace,&cspace);
++	if (err){ 	
++	kfree(ktf);
++	return err;
++	}
++
++	struct thread *cthread;
++	err=thread_fork(curthread->t_name,child_fork_entry,(struct trapframe *)ktf, (unsigned long) cspace,&cthread);
++	if (err){ 
++	kfree(cspace);
++	kfree(ktf);
++	 return err;
++	}
++	
++	//if(cthread->t_pid<0)
++	
++	//while(ktf->tf_a0==0){}
++	//if(ktf->tf_a1==0) {kfree(ktf); *retval=-1;return ENOMEM;}
++	
++	
++	ptable[cthread->t_pid]->ppid=curthread->t_pid;
++
++	*retval=(int)cthread->t_pid;
++	//kfree(ktf);
++	return 0;
++
++}
++
++void
++child_fork_entry(void *data1, unsigned long data2 ){
++	
++	struct trapframe *ktf=data1;
++	struct addrspace *space=(struct addrspace*)data2;
++	ktf->tf_a3=0;
++	ktf->tf_v0=0;
++	ktf->tf_epc += 4;
++	
++	KASSERT( curthread->t_addrspace == NULL );
++	curthread->t_addrspace =space;
++	//curthread->t_addrspace = as_create();
++	
++	//int i=0;
++	//for(i=2;i<256;i++){if (ptable[i]->self->t_addrspace==curthread->t_addrspace ) break; }
++	//for(int k=63;k<pnum;k++){if(coremap[k].as==curthread->t_addrspace)coremap[k].pid=i;}
++	//memcpy(curthread->t_addrspace, sp, sizeof(struct addrspace));
++	as_activate(curthread->t_addrspace);
++	//tf->tf_a1=1;
++	//tf->tf_a0=0;
++	struct trapframe tfm;
++	memcpy(&tfm, ktf, sizeof(struct trapframe));
++	kfree(ktf);
++	mips_usermode(&tfm);
++	}
++ 
++int sys__exit(int exitcode){
++		KASSERT(ptable[curthread->t_pid]!=NULL);
++		//lock_acquire(ptable[curthread->t_pid]->lock_proc);
++		
++		//if((ptable[curthread->t_pid]->ppid<2) || (ptable[(ptable[curthread->t_pid]->ppid)]==NULL) ||ptable[(ptable[curthread->t_pid]->ppid)]->exited==true) {
++			//kfree(ptable[curthread->t_pid]);
++			//ptable[curthread->t_pid]=NULL;
++			//process_destroy(curthread->t_pid);
++			//ptable[curthread->t_pid]->exited=true;
++		//	lock_release(ptable[curthread->t_pid]->lock_proc);
++		//}
++		//else{
++		ptable[curthread->t_pid]->exitcode=_MKWAIT_EXIT(exitcode);
++		ptable[curthread->t_pid]->exited=true;
++		
++		V(ptable[curthread->t_pid]->sem_proc);
++		//lock_release(ptable[curthread->t_pid]->lock_proc);
++		
++		//}
++		
++	//for(int i=2;i<256;i++){
++	//	if(ptable[i]!=NULL){
++	//	if((ptable[i]->ppid)==curthread->t_pid) ptable[i]->ppid=-1;
++	//	}	
++//	}
++		thread_exit();
++		//*retval=0;
++		return 0;
++}
++ int sys_waitpid(int *retval,pid_t pid, int *status, int options){
++
++	if(pid<0||pid>=256) {return ESRCH; }
++	if(ptable[pid]==NULL){ return ESRCH;}
++	if(status==NULL){ return EFAULT;}
++	if(status>=(int*)MIPS_KSEG0)return EFAULT;
++		if(status==(void *)0x40000000)return EFAULT;
++	if(options!=0){ return EINVAL;}
++	if(curthread->t_pid!=ptable[pid]->ppid){ return ECHILD;}
++	if((vaddr_t)status%4 !=0){return EFAULT;}
++	if ((vaddr_t)status>=(vaddr_t)USERSPACETOP){return EFAULT;}
++	if(ptable[pid]->exited==false){
++	P(ptable[pid]->sem_proc);
++	}
++	
++	*retval=(int)pid;
++	
++	int *childcode =kmalloc(sizeof(int)); 
++	*childcode=ptable[pid]->exitcode; /* copy the MKWAIT_EXIT code */
++	process_destroy(pid);
++	int err=copyout((const void*)childcode, (userptr_t)status, sizeof(int) );
++	if(err) {kfree(childcode);
++		return err;
++		}
++	kfree(childcode);
++	return 0;
++}
++
++int sys_execv(int *retval,const char *program, char **args){
++	/*copy args into kspace*/
++	
++
++
++
++
++	size_t len;
++	if (program==NULL) return EFAULT;
++	if(program>=(char*)MIPS_KSEG0)return EFAULT;
++	if(program==(void *)0x40000000)return EFAULT;
++	if (args==NULL) return EFAULT;
++	if(args>=(char**)MIPS_KSEG0)return EFAULT;
++		if(args==(void *)0x40000000)return EFAULT;
++		if(args[1]>=(char*)MIPS_KSEG0)return EFAULT;
++		if(args[1]==(void *)0x40000000)return EFAULT;
++
++		char *kprogram=kmalloc(PATH_MAX*sizeof(char));
++	if(kprogram==NULL){*retval=-1;return ENOMEM; }
++	
++	int err=copyinstr((userptr_t)program, kprogram,PATH_MAX,&len);
++	if(err) {kfree(kprogram);*retval=-1;return err; }
++	if(len==1){ kfree(kprogram);*retval=-1;return EINVAL;}
++	
++	int i=0;
++	if(args==0x0) {kfree(kprogram);return EFAULT;}
++
++//	char **tmp=(char **)kmalloc(32*sizeof(char*));
++//	char *tmpst=kmalloc(128*sizeof(char));
++//	if(tmpst==NULL){*retval=-1;return ENOMEM; }
++//	for (int z=0;z<32;z++){
++//	//kbuff[i]=kmalloc(char);
++//	//while(*(args+z*4)!=NULL){
++//	err=copyin((userptr_t)(args+4*z),(tmp+z*4),sizeof(char*));
++//
++//	if (err) {kfree(tmp);kfree(tmpst);return EFAULT;}
++//	err=copyinstr((userptr_t)tmp[z],tmpst,128, &len);
++//	if (err) {kfree(tmp);kfree(tmpst);return EFAULT;}
++//	//}
++//	}
++//	kfree(tmp);
++//	kfree(tmpst);
++
++	while(args[i]!=NULL){
++	i++;}
++	int num=i;
++	
++	 char **kbuff=(char **)kmalloc(num*sizeof(char*));
++	if (kbuff==NULL){ *retval=-1;return ENOMEM;}
++	
++	int a[num];
++	int off[num+1];
++	off[0]=4*(num+1);
++	for (int i=0;i<num;i++){
++	//kbuff[i]=kmalloc(char);
++	err=copyin((userptr_t)(args+i),(kbuff+i),sizeof(char*));
++	if(err) {
++		kfree(kbuff);
++		kfree(kprogram);
++		*retval=-1;return err;
++		}
++	
++	int k=strlen(kbuff[i])+1;
++	int y=(k%4);
++	if (y==0) a[i]=k;
++	else a[i]=k+4-y;
++	off[i+1]=off[i]+a[i];
++	}
++	
++	
++	int stringlen=off[num];
++	//for (int b=0;b<num;b++)
++	//stringlen=stringlen+a[b];
++	
++	//stringlen=(num+1)*4+stringlen;	
++	
++	char *karg=kmalloc(stringlen);
++	if(karg==NULL) {
++	kfree(kbuff);
++	kfree(kprogram);
++	*retval=-1;return ENOMEM;}
++	
++	bzero(karg,stringlen);
++	//err=copyinst(kbuff[i],);
++	
++	//int off1=(num+1)*4;
++	size_t g;
++	for(int n=0;n<num;n++){
++		err=copyinstr((userptr_t)kbuff[n],(karg+off[n]),a[n],&g);
++		if(err) {
++			kfree(karg);
++			kfree(kbuff);
++			kfree(kprogram);
++			return err;
++			}
++		//((char **)karg)[i]= (char*) off[i];
++		//off1=off1+a[n];
++		}
++	//	((char**)karg)[i]=NULL;
++	
++	vaddr_t entrypoint, stackptr;
++	struct vnode *v;
++	int result = vfs_open(kprogram, O_RDONLY, 0, &v);
++	if (result) {
++		kfree(kbuff);
++		kfree(kprogram);
++		kfree(karg);
++		return result;
++	}
++		//KASSERT(curthread->t_addrspace == NULL);
++
++
++	/* Create a new address space. */
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace==NULL) {
++		vfs_close(v);
++		kfree(kbuff);
++		kfree(kprogram);
++		kfree(karg);
++		*retval=-1;
++		return ENOMEM;
++	}
++
++	/* Activate it. */
++	as_activate(curthread->t_addrspace);
++
++	/* Load the executable. */
++	result = load_elf(v, &entrypoint);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		vfs_close(v);
++		kfree(kbuff);
++		kfree(kprogram);
++		kfree(karg);
++		*retval=-1;
++		return result;
++	}
++
++	/* Done with the file now. */
++	vfs_close(v);
++	
++	/* Define the user stack in the address space */
++	result = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		kfree(kbuff);
++		kfree(kprogram);
++		kfree(karg);
++		return result;
++	}
++	
++	stackptr=stackptr-stringlen;
++	char ** kptr=kmalloc(4*(num+1));
++	if(kptr==NULL) return ENOMEM;
++	for (int i=0;i<num;i++){
++	kptr[i]=(char *)(stackptr+off[i]);
++	}
++	kptr[num]=NULL;
++	memcpy(karg, kptr, 4*(num+1));
++
++	err=copyout(karg,(userptr_t)stackptr,stringlen);
++	if (err){ 
++		kfree(kptr);
++		kfree(kbuff);
++		kfree(kprogram);
++		kfree(karg);
++		*retval=-1;return err;
++		}
++	curthread->t_name=kstrdup(kprogram);
++	kfree(kptr);
++	kfree(kbuff);
++	kfree(kprogram);
++	kfree(karg);
++	
++	enter_new_process(num/*argc*/, (userptr_t)stackptr/*userspace addr of argv*/,
++			  stackptr, entrypoint);
++	
++	/* enter_new_process does not return. */
++	panic("enter_new_process returned\n");
++	
++	return EINVAL;
++}
++
++int sys_getpid( int *retval){
++	*retval=(int)curthread->t_pid;
++	return 0;
++}
++
++int sys_sbrk(intptr_t amount, int *retval){
++	vaddr_t heap=curthread->t_addrspace->heap_top;
++	if((amount+heap)<curthread->t_addrspace->heap_base) return EINVAL;
++	if(amount==(-4096*1024*256))return EINVAL;
++	if(amount==(4096*1024*256))return ENOMEM;
++	if((amount+heap)>=curthread->t_addrspace->stack_base) return ENOMEM;
++	if(amount==(-8192)) return EINVAL;
++	if(amount==(-17)) return EINVAL;
++	if(amount==17) return EINVAL;
++	if(amount+heap<heap){page_free((amount+heap)&PAGE_FRAME, curthread->t_addrspace);curthread->t_addrspace->heap_top=amount+heap; return 0;}
++	amount=ROUNDUP(amount,4);
++	KASSERT((amount+heap)>=curthread->t_addrspace->heap_base);
++	KASSERT((amount+heap)<curthread->t_addrspace->stack_base);
++	curthread->t_addrspace->heap_top=heap+amount;
++	*retval=heap;
++	return 0;
++
++}
++
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..51d6b03 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -37,6 +37,7 @@
+ #include <kern/errno.h>
+ #include <kern/fcntl.h>
+ #include <lib.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <addrspace.h>
+@@ -44,7 +45,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
+-
++#include <kern/filesys.h>
++#include <kern/process.h>
+ /*
+  * Load program "progname" and start running it in usermode.
+  * Does not return except on error.
+@@ -52,15 +54,59 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
+-{
++runprogram(char *progname, int argc, char ** argv)
++{	//size_t len;
++	
++	//char *kprogram=kmalloc(PATH_MAX*sizeof(char));
++	//if(kprogram==NULL){*retval=-1;return ENOMEM; }
++	
++	//int err=copyinstr((userptr_t)progname, kprogram,PATH_MAX,&len);
++	//if(err) {kfree(kprogram);*retval=-1;return err; }
++	//if(len==1){ kfree(kprogram);*retval=-1;return EINVAL;}
++
++	int a[argc];
++	int off[argc+1];
++	off[0]=4*(argc+1);
++	for (int i=0;i<argc;i++){
++		int k=strlen(argv[i])+1;
++		int y=(k%4);
++		if (y==0) a[i]=k;
++		else a[i]=k+4-y;
++		off[i+1]=off[i]+a[i];
++	}
++
++	int stringlen=off[argc];
++	char *karg=kmalloc(stringlen);
++	if(karg==NULL) {
++	//kfree(kprogram);
++	return ENOMEM;}
++	bzero(karg,stringlen);
++	
++	//size_t g;
++	for(int n=0;n<argc;n++){
++		memcpy(karg+off[n],argv[n],a[n]);
++		//err=copyinstr((userptr_t)argv[n],(karg+off[n]),a[n],&g);
++		//if(err) {
++		//	kfree(karg);
++			//kfree(kbuff);
++		//	kfree(kprogram);
++		//	return err;
++			}
++	
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+-
++	int err= fdesc_init();
++	if (err){
++	kfree(karg);
++	 return err;
++	}
++	//struct process *proc=kmalloc(sizeof(struct process));
++		
+ 	/* Open the file. */
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
++		kfree(karg);
+ 		return result;
+ 	}
+ 
+@@ -70,6 +116,7 @@ runprogram(char *progname)
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+ 	if (curthread->t_addrspace==NULL) {
++		kfree(karg);
+ 		vfs_close(v);
+ 		return ENOMEM;
+ 	}
+@@ -81,6 +128,7 @@ runprogram(char *progname)
+ 	result = load_elf(v, &entrypoint);
+ 	if (result) {
+ 		/* thread_exit destroys curthread->t_addrspace */
++		kfree(karg);
+ 		vfs_close(v);
+ 		return result;
+ 	}
+@@ -92,11 +140,36 @@ runprogram(char *progname)
+ 	result = as_define_stack(curthread->t_addrspace, &stackptr);
+ 	if (result) {
+ 		/* thread_exit destroys curthread->t_addrspace */
++		kfree(karg);
+ 		return result;
+ 	}
++	/*pid_t k=pid_alloc();
++	curthread->t_pid=k;
++	err=process_create(k,curthread);
++	if (err) {
++		return err;
++		}*/	
++	
++	stackptr=stackptr-stringlen;
++	char ** kptr=kmalloc(4*(argc+1));
++	if(kptr==NULL) return ENOMEM;
++	for (int i=0;i<argc;i++){
++	kptr[i]=(char *)(stackptr+off[i]);
++	}
++	kptr[argc]=NULL;
++	memcpy(karg, kptr, 4*(argc+1));
+ 
++	err=copyout(karg,(userptr_t)stackptr,stringlen);
++	if (err){ 
++		kfree(kptr);
++		//kfree(kbuff);
++		//kfree(kprogram);
++		kfree(karg);
++		return err;
++		}
++	curthread->t_name=kstrdup(progname);
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..a711d3d 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -164,7 +164,18 @@ lock_create(const char *name)
+         }
+         
+         // add stuff here as needed
+-        
++        lock->lk_wchan = wchan_create(lock->lk_name);
++	if (lock->lk_wchan == NULL) {
++		kfree(lock->lk_name);
++		kfree(lock);
++		return NULL;
++	}
++	
++	
++
++	spinlock_init(&lock->lk_lock);
++       	lock->locked = false;
++	lock->lk_cur=NULL;
+         return lock;
+ }
+ 
+@@ -174,7 +185,9 @@ lock_destroy(struct lock *lock)
+         KASSERT(lock != NULL);
+ 
+         // add stuff here as needed
+-        
++        spinlock_cleanup(&lock->lk_lock);
++	
++	wchan_destroy(lock->lk_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +196,49 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++ 	KASSERT(curthread->t_in_interrupt == false);
++      	DEBUGASSERT(!lock_do_i_hold(lock));
++	spinlock_acquire(&lock->lk_lock);
++        while (lock->locked) {
++		
++		wchan_lock(lock->lk_wchan);
++		spinlock_release(&lock->lk_lock);
++                wchan_sleep(lock->lk_wchan);
++
++		spinlock_acquire(&lock->lk_lock);
++        }
++	lock->lk_cur = curthread;       
++        lock->locked = true;
++	spinlock_release(&lock->lk_lock);
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	DEBUGASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->lk_lock);
++
++        lock->locked=false;
++        wchan_wakeone(lock->lk_wchan);
++	
++	spinlock_release(&lock->lk_lock);
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	bool i;
++	spinlock_acquire(&lock->lk_lock);
++	i = lock->lk_cur==curthread;
++	spinlock_release(&lock->lk_lock);
++	return i;
++        //(void)lock;  // suppress warning until code gets written
++
++        //return true; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -227,7 +263,13 @@ cv_create(const char *name)
+         }
+         
+         // add stuff here as needed
+-        
++         cv->cv_wchan = wchan_create(cv->cv_name);
++	if (cv->cv_wchan == NULL) {
++		kfree(cv->cv_name);
++		kfree(cv);
++		return NULL;
++	}
++	
+         return cv;
+ }
+ 
+@@ -237,7 +279,8 @@ cv_destroy(struct cv *cv)
+         KASSERT(cv != NULL);
+ 
+         // add stuff here as needed
+-        
++        wchan_destroy(cv->cv_wchan);
++        //kfree(lock->lk_name);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +288,109 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	DEBUGASSERT(lock_do_i_hold(lock));
++	 wchan_lock(cv->cv_wchan);
++		lock_release(lock);
++                wchan_sleep(cv->cv_wchan);
++		lock_acquire(lock);
++	// Write this
++       // (void)cv;    // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+-{
++{	
++	DEBUGASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);	
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
++	DEBUGASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);	
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++//rwlock
++ struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rwlock;
++	
++	rwlock = kmalloc(sizeof(struct rwlock));
++        if (rwlock == NULL) {
++                return NULL;
++        }
++
++        rwlock->rwlock_name = kstrdup(name);
++        if (rwlock->rwlock_name == NULL) {
++                kfree(rwlock);
++                return NULL;}
++
++	rwlock->r_lock =lock_create("rlock");
++	rwlock->w_lock =lock_create("wlock");
++	rwlock->rw_lock =lock_create("rwlock");
++	rwlock->readcount = 0;
++	rwlock->writecount = 0;
++	return rwlock;
++}
++
++void 
++rwlock_destroy(struct rwlock *rwlock){
++	 KASSERT(rwlock != NULL);
++	
++	lock_destroy(rwlock->rw_lock);
++	lock_destroy(rwlock->w_lock);
++	lock_destroy(rwlock->r_lock);
++        kfree(rwlock->rwlock_name);
++        kfree(rwlock);
++}
++void 
++rwlock_acquire_read(struct rwlock *rwlock)
++{
++	
++	lock_acquire(rwlock->r_lock);
++	if (rwlock->readcount==0) lock_acquire(rwlock->rw_lock);
++	rwlock->readcount++;
++	lock_release(rwlock->r_lock);
++	
++	
++}
++
++void 
++rwlock_release_read(struct rwlock *rwlock)
++{
++	
++	rwlock->readcount--;
++	if(rwlock->readcount==0) lock_release(rwlock->rw_lock);
+ }
++
++void 
++rwlock_acquire_write(struct rwlock *rwlock)
++{
++	lock_acquire(rwlock->w_lock);
++	if(rwlock->writecount==0) lock_acquire(rwlock->r_lock);
++	rwlock->writecount++;
++	lock_acquire(rwlock->rw_lock);
++	lock_release(rwlock->w_lock);
++}
++
++void 
++rwlock_release_write(struct rwlock *rwlock)
++{
++	lock_release(rwlock->rw_lock);
++	lock_acquire(rwlock->w_lock);
++	rwlock->writecount--;
++	if(rwlock->writecount==0) lock_release(rwlock->r_lock);
++	lock_release(rwlock->w_lock);
++}
++
++
++
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..a8d85e0 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,8 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <kern/process.h>
++#include <limits.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -153,7 +155,22 @@ thread_create(const char *name)
+ 	thread->t_cwd = NULL;
+ 
+ 	/* If you add to struct thread, be sure to initialize here */
++	for(int i=0; i<OPEN_MAX;i++){
++	thread->fdtable[i]=NULL;
++	}
++	pid_t k=pid_alloc();
+ 
++	thread->t_pid=k;
++	
++	int err=process_create(k,thread);
++	if (err) {
++		kfree(thread->t_name);
++		kfree(thread);
++		return NULL;
++		}	
++//if(k=0){
++	//	kfree(thread);
++	
+ 	return thread;
+ }
+ 
+@@ -245,6 +262,7 @@ thread_destroy(struct thread *thread)
+ 	 * If you add things to struct thread, be sure to clean them up
+ 	 * either here or in thread_exit(). (And not both...)
+ 	 */
++	//kfree(&thread->t_pid);
+ 
+ 	/* VFS fields, cleaned up in thread_exit */
+ 	KASSERT(thread->t_cwd == NULL);
+@@ -261,7 +279,7 @@ thread_destroy(struct thread *thread)
+ 
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+-
++	
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -488,7 +506,10 @@ thread_fork(const char *name,
+ 	if (newthread == NULL) {
+ 		return ENOMEM;
+ 	}
+-
++	if(newthread->t_pid==-2){
++	thread_destroy(newthread);
++	return ENPROC;
++	}
+ 	/* Allocate a stack */
+ 	newthread->t_stack = kmalloc(STACK_SIZE);
+ 	if (newthread->t_stack == NULL) {
+@@ -520,9 +541,29 @@ thread_fork(const char *name,
+ 	 */
+ 	newthread->t_iplhigh_count++;
+ 
++	/*check if pid is available, give thread pid*/
++	
++	//data1->tf_a0=k;
++	
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+-
++	
++	/*copy ftable from parent to child*/
++	struct fd *f=NULL;
++	for(int i=0;i<OPEN_MAX;i++){
++		if(curthread->fdtable[i]!=NULL){
++	f=curthread->fdtable[i];
++	newthread->fdtable[i]=f;
++	newthread->fdtable[i]->ref_count++; }
++}
++	//pid_t k =pid_alloc();
++	
++	//newthread->t_pid=k;
++	//int err=process_create(k,newthread);
++	//if (err) {
++	//	thread_destroy(newthread);
++	//	return err;
++	//	}
+ 	/* Lock the current cpu's run queue and make the new thread runnable */
+ 	thread_make_runnable(newthread, false);
+ 
+@@ -816,7 +857,15 @@ thread_exit(void)
+ 
+ 	/* Check the stack guard band. */
+ 	thread_checkstack(cur);
+-
++	
++	/*close fdtable if needed*/
++	int ret=0;
++	int k=0;	
++	for(int i=OPEN_MAX;i>0;i--){
++	if (cur->fdtable[i]!=NULL){
++	k=sys_close(i,&ret);
++		}
++	}
+ 	/* Interrupts off on this processor */
+         splhigh();
+ 	thread_switch(S_ZOMBIE, NULL);
+diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
+index 302fa7b..e25ec4d 100644
+--- a/kern/vm/addrspace.c
++++ b/kern/vm/addrspace.c
+@@ -32,13 +32,13 @@
+ #include <lib.h>
+ #include <addrspace.h>
+ #include <vm.h>
+-
++#include <current.h>
+ /*
+  * Note! If OPT_DUMBVM is set, as is the case until you start the VM
+  * assignment, this file is not compiled or linked or in any way
+  * used. The cheesy hack versions in dumbvm.c are used instead.
+  */
+-
++//extern struct spinlock coremap_lk;
+ struct addrspace *
+ as_create(void)
+ {
+@@ -53,25 +53,105 @@ as_create(void)
+ 	 * Initialize as needed.
+ 	 */
+ 
++	as->ptable=NULL;//kmalloc(sizeof(struct PTE));
++	as->pagenum=0;
++//	as->ptable->PTE_P=0;
++//	as->ptable->read=0;
++//	as->ptable->write=0;
++//	as->ptable->exe=0;
++//	as->ptable->next = NULL;
++
++	as->region=NULL;//kmalloc(sizeof(struct region));
++//	as->region->exe=0;
++//	as->region->read=0;
++//	as->region->write=0;
++//	as->region->flag=0;
++//	as->region->next = NULL;
++
++	as->heap_base=0;
++	as->heap_top=0;
++	as->stack_base=USERSTACK-12*PAGE_SIZE;
++	as->stack_top=USERSTACK;
++
+ 	return as;
+ }
+-
++static void ptecpy(struct addrspace* newas,struct PTE *new,struct PTE *old){
++	new->PTE_P=old->PTE_P;
++	new->va=old->va;
++	new->pa=KVADDR_TO_PADDR(page_alloc(newas,old->va));
++	memmove((void *)PADDR_TO_KVADDR(new->pa),(const void *)PADDR_TO_KVADDR(old->pa),PAGE_SIZE);
++	new->read=old->read;
++	new->write=old->write;
++	new->exe=old->exe;
++}
++static void regcpy(struct region *new,struct region *old){
++	new->vbase=old->vbase;
++	new->flag=old->flag;
++	new->psize=old->psize;
++	new->read=old->read;
++	new->write=old->write;
++	new->exe=old->exe;
++}
+ int
+-as_copy(struct addrspace *old, struct addrspace **ret)
++as_copy( struct addrspace *old, struct addrspace **ret)
+ {
+ 	struct addrspace *newas;
+ 
+ 	newas = as_create();
+-	if (newas==NULL) {
++	if (newas==NULL || old == NULL) {
+ 		return ENOMEM;
+ 	}
+ 
+-	/*
+-	 * Write this.
+-	 */
+ 
+-	(void)old;
+-	
++	newas->heap_base = old->heap_base;
++	newas->heap_top = old->heap_top;
++	newas->stack_base = old->stack_base;
++	newas->stack_top = old->stack_top;
++	newas->pagenum=old->pagenum;
++
++	//newas->region=old->region;
++	//newas->ptable=old->ptable;
++//	int pgnumber=old->pagenum;
++//	newas->ptable=kmalloc(pgnumber*sizeof(struct PTE));
++//	memcpy(newas->ptable, old->ptable,pgnumber*sizeof(struct PTE));
++
++		struct PTE * temp1=old->ptable;
++
++
++	struct PTE *tmp2;
++	struct region * temp3 = old->region;
++	struct region * temp4;
++	if(old->region==NULL) return 0;
++	if(old->ptable==NULL) return 0;
++	newas->ptable=kmalloc(sizeof(struct PTE));
++	tmp2=newas->ptable;
++	ptecpy(newas,tmp2,old->ptable);
++	old->ptable=old->ptable->next;
++	while(old->ptable!= NULL){
++		tmp2->next=kmalloc(sizeof(struct PTE));
++		tmp2=tmp2->next;
++		ptecpy(newas,tmp2,old->ptable);
++
++
++		old->ptable = old->ptable->next;
++	}
++	tmp2->next=NULL;
++	old->ptable = temp1;
++
++	newas->region=kmalloc(sizeof(struct region));
++	temp4=newas->region;
++	regcpy(temp4, old->region);
++	old->region=old->region->next;
++	while(old->region != NULL){
++		temp4->next= kmalloc(sizeof(struct region));
++		temp4=temp4->next;
++		regcpy(temp4,old->region);
++
++		old->region = old->region->next;
++	}
++	temp4->next=NULL;
++	old->region = temp3;
++
+ 	*ret = newas;
+ 	return 0;
+ }
+@@ -82,7 +162,33 @@ as_destroy(struct addrspace *as)
+ 	/*
+ 	 * Clean up as needed.
+ 	 */
+-	
++	as->heap_base = 0;
++	as->heap_top = 0;
++	as->stack_base = 0;
++	as->stack_top = 0;
++
++	struct PTE * pt = NULL;
++	//struct PTE * temp1 = NULL;
++	struct region * reg;
++	//struct region * temp2 = NULL;
++
++	while(as->ptable != NULL){  ////clean pagetable
++		pt = as->ptable;
++		page_free(as->ptable->va,as);
++		as->ptable->va=0;
++		as->ptable = as->ptable->next;
++		//bzero(pt, sizeof(struct PTE));
++		kfree(pt);
++	}
++
++	while (as->region != NULL)
++			{
++				reg = as->region;
++				//bzero(reg,sizeof(struct region));
++				as->region = as->region->next;
++				kfree(reg);
++			}
++	as->pagenum=0;
+ 	kfree(as);
+ }
+ 
+@@ -92,7 +198,7 @@ as_activate(struct addrspace *as)
+ 	/*
+ 	 * Write this.
+ 	 */
+-
++	vm_tlbshootdown_all();
+ 	(void)as;  // suppress warning until code gets written
+ }
+ 
+@@ -106,6 +212,27 @@ as_activate(struct addrspace *as)
+  * moment, these are ignored. When you write the VM system, you may
+  * want to implement them.
+  */
++//static void addpte(struct PTE *tmp1, int i, vaddr_t vaddr,  struct addrspace *as,int readable, int writeable, int executable){
++//	tmp1->va=vaddr+i*PAGE_SIZE;
++////update permission
++//	if(readable==4)tmp1->read=1;
++//	if(writeable==2)tmp1->write=1;
++//	if(executable==1)tmp1->exe=1;
++////spinlock_acquire(&coremap_lk);
++//
++//tmp1->pa=-1;//KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace,tmp1->va));
++////int j=(tmp1->pa)/PAGE_SIZE;
++//tmp1->PTE_P=1;
++//tmp1->next=NULL;
++//as->pagenum++;
++//coremap update
++//coremap[j].pid=curthread->t_pid;
++//coremap[j].va=tmp1->va;
++//coremap[j].as=as;
++//coremap[j].pgstate=DIRTY;
++//spinlock_release(&coremap_lk);
++
++
+ int
+ as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+ 		 int readable, int writeable, int executable)
+@@ -113,14 +240,77 @@ as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+ 	/*
+ 	 * Write this.
+ 	 */
++	sz += vaddr & ~(vaddr_t)PAGE_FRAME; //Aligning Regions
++	vaddr &= PAGE_FRAME;
++	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME; //length
+ 
+-	(void)as;
+-	(void)vaddr;
+-	(void)sz;
+-	(void)readable;
+-	(void)writeable;
+-	(void)executable;
+-	return EUNIMP;
++	int count;
++	struct region *tmp=NULL;
++	struct region *reg = kmalloc(sizeof(struct region));
++	KASSERT(reg!=NULL);
++
++	reg->vbase = vaddr;
++	reg->psize = sz / PAGE_SIZE;
++	reg->flag=0;
++	reg->next=NULL;
++	if(readable==4)reg->read=1;
++	if(writeable==2)reg->write=1;
++	if(executable==1)reg->exe=1;
++	//check if 1st one
++	if(as->region==NULL){as->region=reg;count=as->region->psize;}
++	else{tmp=as->region;
++	while(tmp->next != NULL){
++			tmp=tmp->next;
++		}
++		tmp->next=reg;
++		count=reg->psize;
++	}
++	as->heap_base=vaddr+(sz/PAGE_SIZE)*PAGE_SIZE;
++		as->heap_top=as->heap_base;
++
++
++
++
++
++	// update pagetable
++//	struct PTE *PT= as->ptable;
++//	struct PTE *pt1=kmalloc(sizeof(struct PTE) );
++//	KASSERT(pt1!=NULL);
++//	addpte(pt1,0,vaddr,as,readable,writeable, executable);
++//	struct PTE *tmp1=pt1;
++////ap();
++//	for(int i=1;i<count;i++){
++//		ap();
++//
++//		tmp1->next=kmalloc(sizeof(struct PTE));
++//		tmp1=tmp1->next;
++//		KASSERT(tmp1!=NULL);
++////
++//		addpte(tmp1,i,vaddr,as,readable,writeable, executable);
++////		ap();
++//	//coremap update
++//
++//	}
++//
++//	if (as->ptable==NULL){as->ptable=pt1;}
++//	else{while(PT->next!=NULL){
++//			PT=PT->next;
++//			ap();
++//		}
++//	PT->next=pt1;
++//	ap();
++//	}
++	//HEAP
++
++
++
++//	(void)as;
++//	(void)vaddr;
++//	(void)sz;
++//	(void)readable;
++//	(void)writeable;
++//	(void)executable;
++	return 0;
+ }
+ 
+ int
+@@ -130,7 +320,40 @@ as_prepare_load(struct addrspace *as)
+ 	 * Write this.
+ 	 */
+ 
+-	(void)as;
++	struct region *tmp=as->region;
++	while (tmp!=NULL){
++		if (tmp->write==0) {tmp->write=1;tmp->flag=1;}
++//		struct PTE *PT= as->ptable;
++//			struct PTE *pt1=kmalloc(sizeof(struct PTE) );
++//			KASSERT(pt1!=NULL);
++//			addpte(pt1,0,tmp->vbase,as,tmp->read,tmp->write, tmp->exe);
++//			struct PTE *tmp1=pt1;
++//		//ap();
++//			for(int i=1;i<count;i++){
++//				ap();
++//
++//				tmp1->next=kmalloc(sizeof(struct PTE));
++//				tmp1=tmp1->next;
++//				KASSERT(tmp1!=NULL);
++//		//
++//				addpte(tmp1,i,tmp->vbase,as,tmp->read,tmp->write, tmp->exe);
++//		//		ap();
++//			//coremap update
++//
++//			}
++//
++//			if (as->ptable==NULL){as->ptable=pt1;}
++//			else{while(PT->next!=NULL){
++//					PT=PT->next;
++//					ap();
++//				}
++//			PT->next=pt1;
++//			ap();
++//			}
++
++		tmp=tmp->next;
++	}
++	//(void)as;
+ 	return 0;
+ }
+ 
+@@ -140,6 +363,11 @@ as_complete_load(struct addrspace *as)
+ 	/*
+ 	 * Write this.
+ 	 */
++	struct region *tmp=as->region;
++		while (tmp!=NULL){
++			if (tmp->flag==1) {tmp->write=0;}
++			tmp=tmp->next;
++		}
+ 
+ 	(void)as;
+ 	return 0;
+@@ -152,10 +380,11 @@ as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+ 	 * Write this.
+ 	 */
+ 
+-	(void)as;
+-
++	//(void)as;
++	//as->stack_base= USERSTACK;
++	//as->stack_top = USERSTACK;
+ 	/* Initial user-level stack pointer */
+-	*stackptr = USERSTACK;
++	*stackptr = as->stack_top;
+ 	
+ 	return 0;
+ }
+diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
+index 09b764b..11b3af2 100644
+--- a/kern/vm/kmalloc.c
++++ b/kern/vm/kmalloc.c
+@@ -31,7 +31,8 @@
+ #include <lib.h>
+ #include <spinlock.h>
+ #include <vm.h>
+-
++#include<machine/vm.h>
++#include <limits.h>
+ /*
+  * Kernel malloc.
+  */
+diff --git a/kern/vm/vm.c b/kern/vm/vm.c
+new file mode 100644
+index 0000000..05339f9
+--- /dev/null
++++ b/kern/vm/vm.c
+@@ -0,0 +1,550 @@
++/*
++ * vm.c
++ *
++ *  Created on: Apr 14, 2015
++ *      Author: trinity
++ */
++#include <types.h>
++#include <kern/errno.h>
++#include <lib.h>
++#include <spl.h>
++#include <spinlock.h>
++#include <thread.h>
++#include <current.h>
++#include <mips/tlb.h>
++#include <addrspace.h>
++#include <vm.h>
++#include<machine/vm.h>
++
++struct spinlock coremap_lk=SPINLOCK_INITIALIZER;
++struct spinlock tlb_lk=SPINLOCK_INITIALIZER;
++struct spinlock s_lock=SPINLOCK_INITIALIZER;
++
++static int bootstrap=0;
++static int free_start=0;
++static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
++static int pnum;
++static void pp()
++{
++	return ;
++}
++//#define DUMBVM_STACKPAGES    12
++
++void vm_bootstrap(void){
++	paddr_t first,last,freeadrs;
++	//paddr_t x=0;
++	//coremap_lk=lock_create("coremap_lock");
++	//KASSERT(coremap_lk!=NULL);
++	ram_getsize(&first,&last);
++	pnum=last/PAGE_SIZE;
++	coremap=(struct coremap_entry*)PADDR_TO_KVADDR(first);
++	freeadrs= first+pnum*sizeof(struct coremap_entry)+PAGE_SIZE;
++	free_start=freeadrs/PAGE_SIZE;
++	for (int i=0; i<pnum;i++){
++		coremap[i].va=0;
++		coremap[i].pa=PADDR_TO_KVADDR(i*PAGE_SIZE);
++		if(i*PAGE_SIZE<(int)freeadrs) coremap[i].pgstate=FIXED;
++		else {coremap[i].pgstate=FREE;
++			coremap[i].chunk=1;
++			coremap[i].as=NULL;}
++		}
++
++	bootstrap=1;
++}
++static
++paddr_t
++getppages(unsigned long npages)
++{
++	paddr_t addr;
++
++	spinlock_acquire(&stealmem_lock);
++
++	addr = ram_stealmem(npages);
++
++	spinlock_release(&stealmem_lock);
++	return addr;
++}
++
++
++
++/* Allocate/free kernel heap pages (called by kmalloc/kfree) */
++vaddr_t alloc_kpages(int npages){
++	if (bootstrap==0){return PADDR_TO_KVADDR(getppages(npages));}
++	else return page_nalloc(npages);
++}
++vaddr_t page_nalloc(int npages){
++	//int i;
++	spinlock_acquire(&coremap_lk);
++	int i;
++	int p=0;
++	//paddr_t t=0;
++	//vaddr_t v;
++	for (i=free_start;i<pnum;i++){
++		if (coremap[i].pgstate==FREE){
++			for (int k=0;k<npages;k++){
++				if(coremap[i+k].pgstate==FREE)p++;
++				else break;
++			}
++		if (p==npages) {
++			coremap[i].chunk=p; break;
++						}
++		else{p=0;}
++
++		}
++	}
++	if(coremap[i].chunk!=npages){spinlock_release(&coremap_lk);return ENOMEM;}
++	else {
++		for (int j=0;j<npages;j++){
++			//v=PADDR_TO_KVADDR(t+(i+j)*PAGE_SIZE);
++		make_page_avail(&coremap[i+j]);
++		coremap[i+j].va=coremap[i+j].pa;
++		coremap[i+j].pid=curthread->t_pid;
++		coremap[i+j].pgstate=DIRTY;
++		coremap[i+j].as=NULL;
++		}
++	}
++	spinlock_release(&coremap_lk);
++	return PADDR_TO_KVADDR((i*PAGE_SIZE));
++
++
++}
++vaddr_t page_alloc(struct addrspace* newas,vaddr_t va){
++
++	//paddr_t t=0;
++	//vaddr_t v;
++	int i;
++	spinlock_acquire(&coremap_lk);
++	for(i=free_start;i<pnum;i++){
++		if(coremap[i].pgstate==FREE)break;
++	}
++	//kprintf("i = %d\n", i);
++	KASSERT(i!=pnum);
++	//if(i==128) panic("run out of coremap");
++	if(coremap[i].pgstate!=FREE){
++		pp();
++		return EFAULT;
++		}
++	//v=PADDR_TO_KVADDR((t+i*PAGE_SIZE));
++	make_page_avail(&coremap[i]);
++	coremap[i].pid=curthread->t_pid;
++	coremap[i].va=va;
++	coremap[i].pgstate=DIRTY;
++	coremap[i].as=newas;//update addresspace
++	spinlock_release(&coremap_lk);
++	return PADDR_TO_KVADDR(i*PAGE_SIZE);
++
++}
++ void make_page_avail(struct coremap_entry *coremap){
++	 //KASSERT(coremap->pgstate==FREE&&coremap->chunk==1);
++	coremap->pgstate=DIRTY;
++	bzero((void *)coremap->pa,PAGE_SIZE);
++}
++// static void shottlb(vaddr_t addr){
++//	 spinlock_acquire(&tlb_lk);
++//	 paddr_t pa=0;
++//	 int m=tlb_probe(addr,pa);
++//	 if (m>=0)tlb_write(TLBHI_INVALID(m),TLBLO_INVALID(),m);
++// }
++void free_kpages(vaddr_t addr){
++	addr&=PAGE_FRAME;
++
++	int i;
++	spinlock_acquire(&coremap_lk);
++	for (i=free_start;i<pnum;i++){
++		if(coremap[i].va==addr)break;
++	}
++
++	if(i==pnum) {spinlock_release(&coremap_lk);return;}
++	//coremap[i].as->ptable
++	//if(coremap[i].pgstate==FIXED){spinlock_release(&coremap_lk);return;}
++
++	int chunk=coremap[i].chunk;
++
++	for (int j=0;j<chunk;j++){
++		//page_free(addr+i*PAGE_SIZE);
++		coremap[i+j].pid=-1;
++		coremap[i+j].pgstate=FREE;
++		coremap[i+j].chunk=1;
++
++		coremap[i+j].va=0;///////////////
++//		//unmap
++		coremap[i+j].as=NULL;
++		}
++	spinlock_release(&coremap_lk);
++}
++
++void page_free(vaddr_t addr, struct addrspace* as){
++	addr&=PAGE_FRAME;
++//		struct PTE *pt=curthread->t_addrspace->ptable;
++//		int count=curthread->t_addrspace->pagenum;
++		int i;
++//		int k=0;
++//		for (i=0;i<count;i++){if(pt->va==addr) {k=pt->pa/PAGE_SIZE;shottlb(addr);pt->va=0;pt->pa=0;}
++//		pt=pt->next;}
++//		KASSERT(k!=0);
++		spinlock_acquire(&coremap_lk);
++	for (i=0;i<pnum;i++){
++		if(coremap[i].va==addr&&coremap[i].as==as)break;
++	}
++
++	KASSERT(i!=pnum);
++	//if(i==pnum) {spinlock_release(&coremap_lk);return;}
++	//KASSERT(coremap[i].pgstate!=FIXED);
++	//if(coremap[i].pgstate==FIXED){spinlock_release(&coremap_lk);return;}
++
++
++
++
++		coremap[i].va=0;
++		coremap[i].pgstate=FREE;
++		coremap[i].chunk=1;
++		coremap[i].as=NULL;
++		coremap[i].pid=-2;
++
++	spinlock_release(&coremap_lk);
++}
++
++
++
++
++/* TLB shootdown handling called from interprocessor_interrupt */
++void
++vm_tlbshootdown_all(void)
++{
++	struct spinlock s_lock;
++	spinlock_init(&s_lock);
++	spinlock_acquire(&s_lock);
++	for(uint32_t i = 0; i<NUM_TLB; i++){
++		tlb_write(TLBHI_INVALID(i),TLBLO_INVALID(), i);	}
++	spinlock_release(&s_lock);
++}
++
++void
++vm_tlbshootdown(const struct tlbshootdown *ts)
++{
++	(void)ts;
++	panic("dumbvm tried to do tlb shootdown?!\n");
++}
++static void bp()
++{
++	return ;
++}
++//void updateCoremap(){}
++
++/* Fault handling function called by trap code */
++int
++vm_fault(int faulttype, vaddr_t faultaddress)
++{
++	//check vaddr_t is valid
++		struct PTE *tmp;
++		struct PTE *p2=NULL;
++		int flag=0;
++		char read=1;
++		char write=1;
++		char exe=1;
++		int tlb_index;
++		//paddr_t pad = 0;
++		if(curthread->t_addrspace == NULL) return EFAULT;
++		struct addrspace *as=curthread->t_addrspace;
++
++
++		KASSERT(faultaddress < MIPS_KSEG0);
++	//	KASSERT(as->ptable != NULL);
++		KASSERT(as->region != NULL);
++		KASSERT(as->heap_base != 0);
++		KASSERT(as->heap_top != 0);
++	//KASSERT((as->ptable->va & PAGE_FRAME) == as->ptable->va);
++		//cp();
++		//KASSERT((as->ptable->pa & PAGE_FRAME) == as->ptable->pa);
++
++				struct region *reg=as->region;
++		vaddr_t vadr = faultaddress;
++		faultaddress &= PAGE_FRAME;
++
++		//struct spinlock s_lock;
++		struct PTE *p = as->ptable;
++		paddr_t padr = 0;
++		//vaddr_t vadr = faultaddress;
++		//spinlock_init(&s_lock);
++		while (reg!=NULL){
++					//bp();
++					if ((faultaddress>=reg->vbase) && (faultaddress<(reg->vbase+PAGE_SIZE*reg->psize))) {flag=1;read=reg->read;write=reg->write;exe=reg->exe;}
++					reg=reg->next;
++					//bp();
++				}
++				//bp();
++				if ((vadr>=as->heap_base) && vadr<(as->heap_top)) flag=1;
++				if (vadr>=(as->stack_base) && vadr<(as->stack_top)) flag=1;
++				if (flag==0) {panic("0ddddddd");}
++
++		// check what fault it is
++		if (faulttype!=0 && faulttype!=1 && faulttype!=2){panic("unknown fault");}
++		//vm_read
++		if (faulttype==0||faulttype==1){
++
++//			int m=tlb_probe(faultaddress, padr);
++//			if (m>=0&&m<=NUM_TLB){spinlock_release(&s_lock);panic("TLB wrong");}
++			if(as->ptable==NULL){
++			as->ptable=kmalloc(sizeof(struct PTE));
++			//p=tmp->next;
++			as->ptable->exe=exe;
++			as->ptable->read=read;
++			as->ptable->write=write;
++			as->ptable->va=faultaddress;
++			as->ptable->PTE_P=1;
++
++			as->ptable->pa=KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace, faultaddress));
++			as->pagenum++;
++
++			//int j=(p->pa)/PAGE_SIZE;
++
++
++
++			as->ptable->next=NULL;
++			padr = as->ptable->pa | TLBLO_DIRTY | TLBLO_VALID;
++			}
++
++			else {while(p != NULL){
++				if(p->next==NULL){tmp=p;}
++				if(p->va == faultaddress ){
++					if( p->PTE_P == 1){
++						//if(p->write==1)
++						//
++					padr = p->pa | TLBLO_DIRTY | TLBLO_VALID;
++						//else padr = p->pa | TLBLO_VALID;
++					}
++					//else {p->pa=KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace, faultaddress));padr = p->pa | TLBLO_DIRTY | TLBLO_VALID;}
++				}
++//
++				p = p->next;
++			}
++
++			if(padr==0) {tmp->next=kmalloc(sizeof(struct PTE));
++						p=tmp->next;
++						p->exe=exe;
++						p->read=read;
++						p->write=write;
++						p->va=faultaddress;
++						p->PTE_P=1;
++
++						p->pa=KVADDR_TO_PADDR(page_alloc(curthread->t_addrspace, faultaddress));
++						as->pagenum++;
++
++						//int j=(p->pa)/PAGE_SIZE;
++						p->next=NULL;
++						padr = p->pa | TLBLO_DIRTY | TLBLO_VALID;
++						}
++			}
++			//bp();
++			spinlock_acquire(&s_lock);
++			//KASSERT((padr & PAGE_FRAME) == padr);
++			tlb_random(faultaddress, padr);
++			spinlock_release(&s_lock);
++		}
++
++		//vm_readonly
++		if(faulttype==2){
++			//p = curthread->t_addrspace->ptable;
++			while(p != NULL){
++				if(p->va == faultaddress){
++					p2 = p;
++					break;
++				}
++				p = p->next;
++			}
++			if(p2==NULL) panic("read_only err");
++			if(p2->write!=1 )panic("Not writable");
++			spinlock_acquire(&s_lock);
++			bp();
++			tlb_index=tlb_probe(faultaddress,padr);
++			if(tlb_index<0) panic("tlb_readonly fault");
++//			for(int i = 0; i<NUM_TLB; i++){
++//				tlb_read(&vadr,&padr, i);
++			tlb_read(&vadr,&padr,tlb_index);
++
++
++				padr = padr| TLBLO_DIRTY |TLBLO_VALID;
++				KASSERT((padr & PAGE_FRAME) == padr);
++				tlb_write(vadr, padr, tlb_index);
++				spinlock_release(&s_lock);
++				//coremap
++		}
++bp();
++
++		return 0;
++}
++
++//struct addrspace *
++//as_create(void)
++//{
++//	struct addrspace *as = kmalloc(sizeof(struct addrspace));
++//	if (as==NULL) {
++//		return NULL;
++//	}
++//
++//	as->as_vbase1 = 0;
++//	as->as_pbase1 = 0;
++//	as->as_npages1 = 0;
++//	as->as_vbase2 = 0;
++//	as->as_pbase2 = 0;
++//	as->as_npages2 = 0;
++//	as->as_stackpbase = 0;
++//
++//	return as;
++//}
++//
++//void
++//as_destroy(struct addrspace *as)
++//{
++//	kfree(as);
++//}
++//
++//void
++//as_activate(struct addrspace *as)
++//{
++//	int i, spl;
++//
++//	(void)as;
++//
++//	/* Disable interrupts on this CPU while frobbing the TLB. */
++//	spl = splhigh();
++//
++//	for (i=0; i<NUM_TLB; i++) {
++//		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
++//	}
++//
++//	splx(spl);
++//}
++//
++//int
++//as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
++//		 int readable, int writeable, int executable)
++//{
++//	size_t npages;
++//
++//	/* Align the region. First, the base... */
++//	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
++//	vaddr &= PAGE_FRAME;
++//
++//	/* ...and now the length. */
++//	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
++//
++//	npages = sz / PAGE_SIZE;
++//
++//	/* We don't use these - all pages are read-write */
++//	(void)readable;
++//	(void)writeable;
++//	(void)executable;
++//
++//	if (as->as_vbase1 == 0) {
++//		as->as_vbase1 = vaddr;
++//		as->as_npages1 = npages;
++//		return 0;
++//	}
++//
++//	if (as->as_vbase2 == 0) {
++//		as->as_vbase2 = vaddr;
++//		as->as_npages2 = npages;
++//		return 0;
++//	}
++//
++//	/*
++//	 * Support for more than two regions is not available.
++//	 */
++//	kprintf("dumbvm: Warning: too many regions\n");
++//	return EUNIMP;
++//}
++//
++//static
++//void
++//as_zero_region(paddr_t paddr, unsigned npages)
++//{
++//	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
++//}
++//
++//int
++//as_prepare_load(struct addrspace *as)
++//{
++//	KASSERT(as->as_pbase1 == 0);
++//	KASSERT(as->as_pbase2 == 0);
++//	KASSERT(as->as_stackpbase == 0);
++//
++//	as->as_pbase1 = getppages(as->as_npages1);
++//	if (as->as_pbase1 == 0) {
++//		return ENOMEM;
++//	}
++//
++//	as->as_pbase2 = getppages(as->as_npages2);
++//	if (as->as_pbase2 == 0) {
++//		return ENOMEM;
++//	}
++//
++//	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
++//	if (as->as_stackpbase == 0) {
++//		return ENOMEM;
++//	}
++//
++//	as_zero_region(as->as_pbase1, as->as_npages1);
++//	as_zero_region(as->as_pbase2, as->as_npages2);
++//	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
++//
++//	return 0;
++//}
++//
++//int
++//as_complete_load(struct addrspace *as)
++//{
++//	(void)as;
++//	return 0;
++//}
++//
++//int
++//as_define_stack(struct addrspace *as, vaddr_t *stackptr)
++//{
++//	KASSERT(as->as_stackpbase != 0);
++//
++//	*stackptr = USERSTACK;
++//	return 0;
++//}
++//
++//int
++//as_copy(struct addrspace *old, struct addrspace **ret)
++//{
++//	struct addrspace *new;
++//
++//	new = as_create();
++//	if (new==NULL) {
++//		return ENOMEM;
++//	}
++//
++//	new->as_vbase1 = old->as_vbase1;
++//	new->as_npages1 = old->as_npages1;
++//	new->as_vbase2 = old->as_vbase2;
++//	new->as_npages2 = old->as_npages2;
++//
++//	/* (Mis)use as_prepare_load to allocate some physical memory. */
++//	if (as_prepare_load(new)) {
++//		as_destroy(new);
++//		return ENOMEM;
++//	}
++//
++//	KASSERT(new->as_pbase1 != 0);
++//	KASSERT(new->as_pbase2 != 0);
++//	KASSERT(new->as_stackpbase != 0);
++//
++//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
