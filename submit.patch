diff --git a/.gitignore b/.gitignore
index ccea0c4..fa313dd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,5 @@
-.depend
-.settings
-.project
-.cproject
-/kern/compile/
-defs.mk
 build
-/user/testbin/randcall/calls.c
-*.swp
+.depend
+/defs.mk
+kern/compile/
+user/testbin/randcall/calls.c
diff --git a/kern/arch/mips/conf/conf.arch b/kern/arch/mips/conf/conf.arch
index 39ddbc3..947dcca 100644
--- a/kern/arch/mips/conf/conf.arch
+++ b/kern/arch/mips/conf/conf.arch
@@ -66,6 +66,7 @@ machine mips file    arch/mips/vm/ram.c		# Physical memory accounting
 # it may not be suitable for all architectures.
 machine mips file    vm/copyinout.c		# copyin/out et al.
 
+
 # For the early assignments, we supply a very stupid MIPS-only skeleton
 # of a VM system. It is just barely capable of running a single userlevel
 # program as long as that program's not very large.
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..c11a9f1 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -111,7 +111,7 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 	/*
 	 * You will probably want to change this.
 	 */
-
+	sys__exit(-1);
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
 	panic("I don't know how to handle this\n");
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..6e1ad26 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,6 +35,8 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include <kern/filesys.h>
+#include <copyinout.h>
 
 
 /*
@@ -81,7 +83,10 @@ syscall(struct trapframe *tf)
 	int callno;
 	int32_t retval;
 	int err;
-
+	off_t sys_pos=0;
+	off_t ret;
+	int whence;
+	
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
 	KASSERT(curthread->t_iplhigh_count == 0);
@@ -108,9 +113,57 @@ syscall(struct trapframe *tf)
 		err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
 		break;
-
+	    
 	    /* Add stuff here */
- 
+ 	    case SYS_fork:
+		err = sys_fork(tf,&retval);
+		break;
+	    case SYS_execv:
+		err=sys_execv(&retval, (const char*)tf->tf_a0,(char**)tf->tf_a1);
+		break;
+	    case SYS_waitpid:
+		err=sys_waitpid(&retval, (pid_t)tf->tf_a0, (int*)tf->tf_a1,tf->tf_a2);
+		break;
+	   case SYS__exit:
+		err=sys__exit( (int)tf->tf_a0);
+		break;
+	   case SYS_getpid:
+		err = sys_getpid(&retval);
+		break;
+	case SYS_read:
+		err = sys_read(tf->tf_a0, (void *) tf->tf_a1, (size_t) tf->tf_a2, &retval);
+		break;
+	case SYS_write:
+		err = sys_write(tf->tf_a0, (void *) tf->tf_a1, (size_t) tf->tf_a2, &retval);
+		break;
+	case SYS_open:
+		err = sys_open((const char *)tf->tf_a0, tf->tf_a1, (mode_t)tf->tf_a2, &retval);
+		break;
+	case SYS_close:
+		err = sys_close(tf->tf_a0, &retval);
+		break;
+	case SYS_lseek:
+		sys_pos = ((off_t)tf->tf_a2) << 32 | (off_t)tf->tf_a3;
+		err = copyin((const_userptr_t)tf->tf_sp+16, &whence, sizeof(int));
+		if(err) {
+			break;
+		}
+		err = sys_lseek(tf->tf_a0, sys_pos, (int)whence, &ret);
+		if(!err){
+			tf->tf_v1 = ret;
+			retval = ret >> 32;
+		}
+		break;
+	case SYS_dup2:
+		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+		break;
+	case SYS_chdir:
+		err = sys_chdir((const char *)tf->tf_a0, &retval);
+		break;
+	case SYS___getcwd:
+		err = sys___getcwd((char *)tf->tf_a0, (size_t)tf->tf_a1, &retval);
+		break;
+
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
index ca9992a..89a746c 100644
--- a/kern/arch/mips/vm/dumbvm.c
+++ b/kern/arch/mips/vm/dumbvm.c
@@ -1,374 +1,374 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <types.h>
-#include <kern/errno.h>
-#include <lib.h>
-#include <spl.h>
-#include <spinlock.h>
-#include <thread.h>
-#include <current.h>
-#include <mips/tlb.h>
-#include <addrspace.h>
-#include <vm.h>
-
-/*
- * Dumb MIPS-only "VM system" that is intended to only be just barely
- * enough to struggle off the ground. You should replace all of this
- * code while doing the VM assignment. In fact, starting in that
- * assignment, this file is not included in your kernel!
- */
-
-/* under dumbvm, always have 48k of user stack */
-#define DUMBVM_STACKPAGES    12
-
-/*
- * Wrap rma_stealmem in a spinlock.
- */
-static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
-
-void
-vm_bootstrap(void)
-{
-	/* Do nothing. */
-}
-
-static
-paddr_t
-getppages(unsigned long npages)
-{
-	paddr_t addr;
-
-	spinlock_acquire(&stealmem_lock);
-
-	addr = ram_stealmem(npages);
-	
-	spinlock_release(&stealmem_lock);
-	return addr;
-}
-
-/* Allocate/free some kernel-space virtual pages */
-vaddr_t 
-alloc_kpages(int npages)
-{
-	paddr_t pa;
-	pa = getppages(npages);
-	if (pa==0) {
-		return 0;
-	}
-	return PADDR_TO_KVADDR(pa);
-}
-
-void 
-free_kpages(vaddr_t addr)
-{
-	/* nothing - leak the memory. */
-
-	(void)addr;
-}
-
-void
-vm_tlbshootdown_all(void)
-{
-	panic("dumbvm tried to do tlb shootdown?!\n");
-}
-
-void
-vm_tlbshootdown(const struct tlbshootdown *ts)
-{
-	(void)ts;
-	panic("dumbvm tried to do tlb shootdown?!\n");
-}
-
-int
-vm_fault(int faulttype, vaddr_t faultaddress)
-{
-	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
-	paddr_t paddr;
-	int i;
-	uint32_t ehi, elo;
-	struct addrspace *as;
-	int spl;
-
-	faultaddress &= PAGE_FRAME;
-
-	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
-
-	switch (faulttype) {
-	    case VM_FAULT_READONLY:
-		/* We always create pages read-write, so we can't get this */
-		panic("dumbvm: got VM_FAULT_READONLY\n");
-	    case VM_FAULT_READ:
-	    case VM_FAULT_WRITE:
-		break;
-	    default:
-		return EINVAL;
-	}
-
-	as = curthread->t_addrspace;
-	if (as == NULL) {
-		/*
-		 * No address space set up. This is probably a kernel
-		 * fault early in boot. Return EFAULT so as to panic
-		 * instead of getting into an infinite faulting loop.
-		 */
-		return EFAULT;
-	}
-
-	/* Assert that the address space has been set up properly. */
-	KASSERT(as->as_vbase1 != 0);
-	KASSERT(as->as_pbase1 != 0);
-	KASSERT(as->as_npages1 != 0);
-	KASSERT(as->as_vbase2 != 0);
-	KASSERT(as->as_pbase2 != 0);
-	KASSERT(as->as_npages2 != 0);
-	KASSERT(as->as_stackpbase != 0);
-	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
-	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
-	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
-	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
-	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
-
-	vbase1 = as->as_vbase1;
-	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
-	vbase2 = as->as_vbase2;
-	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
-	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
-	stacktop = USERSTACK;
-
-	if (faultaddress >= vbase1 && faultaddress < vtop1) {
-		paddr = (faultaddress - vbase1) + as->as_pbase1;
-	}
-	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
-		paddr = (faultaddress - vbase2) + as->as_pbase2;
-	}
-	else if (faultaddress >= stackbase && faultaddress < stacktop) {
-		paddr = (faultaddress - stackbase) + as->as_stackpbase;
-	}
-	else {
-		return EFAULT;
-	}
-
-	/* make sure it's page-aligned */
-	KASSERT((paddr & PAGE_FRAME) == paddr);
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_read(&ehi, &elo, i);
-		if (elo & TLBLO_VALID) {
-			continue;
-		}
-		ehi = faultaddress;
-		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
-		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
-		tlb_write(ehi, elo, i);
-		splx(spl);
-		return 0;
-	}
-
-	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
-	splx(spl);
-	return EFAULT;
-}
-
-struct addrspace *
-as_create(void)
-{
-	struct addrspace *as = kmalloc(sizeof(struct addrspace));
-	if (as==NULL) {
-		return NULL;
-	}
-
-	as->as_vbase1 = 0;
-	as->as_pbase1 = 0;
-	as->as_npages1 = 0;
-	as->as_vbase2 = 0;
-	as->as_pbase2 = 0;
-	as->as_npages2 = 0;
-	as->as_stackpbase = 0;
-
-	return as;
-}
-
-void
-as_destroy(struct addrspace *as)
-{
-	kfree(as);
-}
-
-void
-as_activate(struct addrspace *as)
-{
-	int i, spl;
-
-	(void)as;
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
-	}
-
-	splx(spl);
-}
-
-int
-as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
-		 int readable, int writeable, int executable)
-{
-	size_t npages; 
-
-	/* Align the region. First, the base... */
-	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
-	vaddr &= PAGE_FRAME;
-
-	/* ...and now the length. */
-	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
-
-	npages = sz / PAGE_SIZE;
-
-	/* We don't use these - all pages are read-write */
-	(void)readable;
-	(void)writeable;
-	(void)executable;
-
-	if (as->as_vbase1 == 0) {
-		as->as_vbase1 = vaddr;
-		as->as_npages1 = npages;
-		return 0;
-	}
-
-	if (as->as_vbase2 == 0) {
-		as->as_vbase2 = vaddr;
-		as->as_npages2 = npages;
-		return 0;
-	}
-
-	/*
-	 * Support for more than two regions is not available.
-	 */
-	kprintf("dumbvm: Warning: too many regions\n");
-	return EUNIMP;
-}
-
-static
-void
-as_zero_region(paddr_t paddr, unsigned npages)
-{
-	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
-}
-
-int
-as_prepare_load(struct addrspace *as)
-{
-	KASSERT(as->as_pbase1 == 0);
-	KASSERT(as->as_pbase2 == 0);
-	KASSERT(as->as_stackpbase == 0);
-
-	as->as_pbase1 = getppages(as->as_npages1);
-	if (as->as_pbase1 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_pbase2 = getppages(as->as_npages2);
-	if (as->as_pbase2 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
-	if (as->as_stackpbase == 0) {
-		return ENOMEM;
-	}
-	
-	as_zero_region(as->as_pbase1, as->as_npages1);
-	as_zero_region(as->as_pbase2, as->as_npages2);
-	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
-
-	return 0;
-}
-
-int
-as_complete_load(struct addrspace *as)
-{
-	(void)as;
-	return 0;
-}
-
-int
-as_define_stack(struct addrspace *as, vaddr_t *stackptr)
-{
-	KASSERT(as->as_stackpbase != 0);
-
-	*stackptr = USERSTACK;
-	return 0;
-}
-
-int
-as_copy(struct addrspace *old, struct addrspace **ret)
-{
-	struct addrspace *new;
-
-	new = as_create();
-	if (new==NULL) {
-		return ENOMEM;
-	}
-
-	new->as_vbase1 = old->as_vbase1;
-	new->as_npages1 = old->as_npages1;
-	new->as_vbase2 = old->as_vbase2;
-	new->as_npages2 = old->as_npages2;
-
-	/* (Mis)use as_prepare_load to allocate some physical memory. */
-	if (as_prepare_load(new)) {
-		as_destroy(new);
-		return ENOMEM;
-	}
-
-	KASSERT(new->as_pbase1 != 0);
-	KASSERT(new->as_pbase2 != 0);
-	KASSERT(new->as_stackpbase != 0);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
-		old->as_npages1*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
-		old->as_npages2*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
-		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
-		DUMBVM_STACKPAGES*PAGE_SIZE);
-	
-	*ret = new;
-	return 0;
-}
+///*
+// * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+// *	The President and Fellows of Harvard College.
+// *
+// * Redistribution and use in source and binary forms, with or without
+// * modification, are permitted provided that the following conditions
+// * are met:
+// * 1. Redistributions of source code must retain the above copyright
+// *    notice, this list of conditions and the following disclaimer.
+// * 2. Redistributions in binary form must reproduce the above copyright
+// *    notice, this list of conditions and the following disclaimer in the
+// *    documentation and/or other materials provided with the distribution.
+// * 3. Neither the name of the University nor the names of its contributors
+// *    may be used to endorse or promote products derived from this software
+// *    without specific prior written permission.
+// *
+// * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+// * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+// * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+// * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+// * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+// * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+// * SUCH DAMAGE.
+// */
+//
+//#include <types.h>
+//#include <kern/errno.h>
+//#include <lib.h>
+//#include <spl.h>
+//#include <spinlock.h>
+//#include <thread.h>
+//#include <current.h>
+//#include <mips/tlb.h>
+//#include <addrspace.h>
+//#include <vm.h>
+//
+///*
+// * Dumb MIPS-only "VM system" that is intended to only be just barely
+// * enough to struggle off the ground. You should replace all of this
+// * code while doing the VM assignment. In fact, starting in that
+// * assignment, this file is not included in your kernel!
+// */
+//
+///* under dumbvm, always have 48k of user stack */
+//#define DUMBVM_STACKPAGES    12
+//
+///*
+// * Wrap rma_stealmem in a spinlock.
+// */
+//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+//
+//void
+//vm_bootstrap(void)
+//{
+//	/* Do nothing. */
+//}
+//
+//static
+//paddr_t
+//getppages(unsigned long npages)
+//{
+//	paddr_t addr;
+//
+//	spinlock_acquire(&stealmem_lock);
+//
+//	addr = ram_stealmem(npages);
+//
+//	spinlock_release(&stealmem_lock);
+//	return addr;
+//}
+//
+///* Allocate/free some kernel-space virtual pages */
+//vaddr_t
+//alloc_kpages(int npages)
+//{
+//	paddr_t pa;
+//	pa = getppages(npages);
+//	if (pa==0) {
+//		return 0;
+//	}
+//	return PADDR_TO_KVADDR(pa);
+//}
+//
+//void
+//free_kpages(vaddr_t addr)
+//{
+//	/* nothing - leak the memory. */
+//
+//	(void)addr;
+//}
+//
+//void
+//vm_tlbshootdown_all(void)
+//{
+//	panic("dumbvm tried to do tlb shootdown?!\n");
+//}
+//
+//void
+//vm_tlbshootdown(const struct tlbshootdown *ts)
+//{
+//	(void)ts;
+//	panic("dumbvm tried to do tlb shootdown?!\n");
+//}
+//
+//int
+//vm_fault(int faulttype, vaddr_t faultaddress)
+//{
+//	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+//	paddr_t paddr;
+//	int i;
+//	uint32_t ehi, elo;
+//	struct addrspace *as;
+//	int spl;
+//
+//	faultaddress &= PAGE_FRAME;
+//
+//	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+//
+//	switch (faulttype) {
+//	    case VM_FAULT_READONLY:
+//		/* We always create pages read-write, so we can't get this */
+//		panic("dumbvm: got VM_FAULT_READONLY\n");
+//	    case VM_FAULT_READ:
+//	    case VM_FAULT_WRITE:
+//		break;
+//	    default:
+//		return EINVAL;
+//	}
+//
+//	as = curthread->t_addrspace;
+//	if (as == NULL) {
+//		/*
+//		 * No address space set up. This is probably a kernel
+//		 * fault early in boot. Return EFAULT so as to panic
+//		 * instead of getting into an infinite faulting loop.
+//		 */
+//		return EFAULT;
+//	}
+//
+//	/* Assert that the address space has been set up properly. */
+//	KASSERT(as->as_vbase1 != 0);
+//	KASSERT(as->as_pbase1 != 0);
+//	KASSERT(as->as_npages1 != 0);
+//	KASSERT(as->as_vbase2 != 0);
+//	KASSERT(as->as_pbase2 != 0);
+//	KASSERT(as->as_npages2 != 0);
+//	KASSERT(as->as_stackpbase != 0);
+//	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+//	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+//	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+//	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+//	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+//
+//	vbase1 = as->as_vbase1;
+//	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+//	vbase2 = as->as_vbase2;
+//	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+//	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+//	stacktop = USERSTACK;
+//
+//	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+//		paddr = (faultaddress - vbase1) + as->as_pbase1;
+//	}
+//	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+//		paddr = (faultaddress - vbase2) + as->as_pbase2;
+//	}
+//	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+//		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+//	}
+//	else {
+//		return EFAULT;
+//	}
+//
+//	/* make sure it's page-aligned */
+//	KASSERT((paddr & PAGE_FRAME) == paddr);
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_read(&ehi, &elo, i);
+//		if (elo & TLBLO_VALID) {
+//			continue;
+//		}
+//		ehi = faultaddress;
+//		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+//		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+//		tlb_write(ehi, elo, i);
+//		splx(spl);
+//		return 0;
+//	}
+//
+//	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+//	splx(spl);
+//	return EFAULT;
+//}
+//
+//struct addrspace *
+//as_create(void)
+//{
+//	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+//	if (as==NULL) {
+//		return NULL;
+//	}
+//
+//	as->as_vbase1 = 0;
+//	as->as_pbase1 = 0;
+//	as->as_npages1 = 0;
+//	as->as_vbase2 = 0;
+//	as->as_pbase2 = 0;
+//	as->as_npages2 = 0;
+//	as->as_stackpbase = 0;
+//
+//	return as;
+//}
+//
+//void
+//as_destroy(struct addrspace *as)
+//{
+//	kfree(as);
+//}
+//
+//void
+//as_activate(struct addrspace *as)
+//{
+//	int i, spl;
+//
+//	(void)as;
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+//	}
+//
+//	splx(spl);
+//}
+//
+//int
+//as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+//		 int readable, int writeable, int executable)
+//{
+//	size_t npages;
+//
+//	/* Align the region. First, the base... */
+//	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+//	vaddr &= PAGE_FRAME;
+//
+//	/* ...and now the length. */
+//	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+//
+//	npages = sz / PAGE_SIZE;
+//
+//	/* We don't use these - all pages are read-write */
+//	(void)readable;
+//	(void)writeable;
+//	(void)executable;
+//
+//	if (as->as_vbase1 == 0) {
+//		as->as_vbase1 = vaddr;
+//		as->as_npages1 = npages;
+//		return 0;
+//	}
+//
+//	if (as->as_vbase2 == 0) {
+//		as->as_vbase2 = vaddr;
+//		as->as_npages2 = npages;
+//		return 0;
+//	}
+//
+//	/*
+//	 * Support for more than two regions is not available.
+//	 */
+//	kprintf("dumbvm: Warning: too many regions\n");
+//	return EUNIMP;
+//}
+//
+//static
+//void
+//as_zero_region(paddr_t paddr, unsigned npages)
+//{
+//	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+//}
+//
+//int
+//as_prepare_load(struct addrspace *as)
+//{
+//	KASSERT(as->as_pbase1 == 0);
+//	KASSERT(as->as_pbase2 == 0);
+//	KASSERT(as->as_stackpbase == 0);
+//
+//	as->as_pbase1 = getppages(as->as_npages1);
+//	if (as->as_pbase1 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_pbase2 = getppages(as->as_npages2);
+//	if (as->as_pbase2 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+//	if (as->as_stackpbase == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as_zero_region(as->as_pbase1, as->as_npages1);
+//	as_zero_region(as->as_pbase2, as->as_npages2);
+//	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+//
+//	return 0;
+//}
+//
+//int
+//as_complete_load(struct addrspace *as)
+//{
+//	(void)as;
+//	return 0;
+//}
+//
+//int
+//as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+//{
+//	KASSERT(as->as_stackpbase != 0);
+//
+//	*stackptr = USERSTACK;
+//	return 0;
+//}
+//
+//int
+//as_copy(struct addrspace *old, struct addrspace **ret)
+//{
+//	struct addrspace *new;
+//
+//	new = as_create();
+//	if (new==NULL) {
+//		return ENOMEM;
+//	}
+//
+//	new->as_vbase1 = old->as_vbase1;
+//	new->as_npages1 = old->as_npages1;
+//	new->as_vbase2 = old->as_vbase2;
+//	new->as_npages2 = old->as_npages2;
+//
+//	/* (Mis)use as_prepare_load to allocate some physical memory. */
+//	if (as_prepare_load(new)) {
+//		as_destroy(new);
+//		return ENOMEM;
+//	}
+//
+//	KASSERT(new->as_pbase1 != 0);
+//	KASSERT(new->as_pbase2 != 0);
+//	KASSERT(new->as_stackpbase != 0);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+//		old->as_npages1*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+//		old->as_npages2*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+//		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+//		DUMBVM_STACKPAGES*PAGE_SIZE);
+//
+//	*ret = new;
+//	return 0;
+//}
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..73cd437 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -330,6 +330,7 @@ file      thread/threadlist.c
 #
 
 file      vm/kmalloc.c
+file      vm/vm.c
 
 optofffile dumbvm   vm/addrspace.c
 
@@ -367,7 +368,9 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
-
+file	     syscall/filesys.c
+file	     syscall/process_support.c
+file	     syscall/process.c
 #
 # Startup and initialization
 #
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..036d7fc 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -58,6 +58,13 @@ struct addrspace {
         size_t as_npages2;
         paddr_t as_stackpbase;
 #else
+	vaddr_t as_vbase1;
+        paddr_t as_pbase1;
+        size_t as_npages1;
+        vaddr_t as_vbase2;
+        paddr_t as_pbase2;
+        size_t as_npages2;
+        paddr_t as_stackpbase;
         /* Put stuff here for your VM system */
 #endif
 };
diff --git a/kern/include/kern/filesys.h b/kern/include/kern/filesys.h
new file mode 100644
index 0000000..e6cdaf1
--- /dev/null
+++ b/kern/include/kern/filesys.h
@@ -0,0 +1,31 @@
+#ifndef FILESYS_H_ 
+#define FILESYS_H_ 
+#include <types.h>
+#include <limits.h>
+#include <thread.h>
+#include <synch.h>
+
+ /* File Descriptor Structure */
+ struct fd{
+	char filename[__NAME_MAX];
+        struct vnode *vn; //   - Reference to the underlying file 'object' 
+        off_t offset;     //      - Offset into the file 
+        struct lock *lock;   //- Some form of synchronization 
+        int flags;      // - Flags with which the file was opened 
+        int ref_count; //- Reference count 
+ };
+
+ 
+ int sys_open(const char *fdesc_name, int flags, mode_t mode, int *retval);
+ int sys_close(int fh, int *retval);
+ int sys_write(int fd, const void *buf, size_t size, int *retval);
+ int sys_read(int fd, void *buf, size_t buflen, int *retval);
+ int sys_lseek(int fd, off_t pos, int whence, off_t *ret);
+ int sys_dup2(int oldfd, int newfd, int *retval);
+ int sys_chdir(const char *pathname, int *retval);
+ int sys___getcwd(char *buf, size_t buflen, int *retval);
+
+int fdesc_init(void);
+
+ #endif /* FILESYS_H_ */
+
diff --git a/kern/include/kern/process.h b/kern/include/kern/process.h
new file mode 100644
index 0000000..6b14c98
--- /dev/null
+++ b/kern/include/kern/process.h
@@ -0,0 +1,22 @@
+#ifndef _PROCESS_H_
+#define _PROCESS_H_
+#include <types.h>
+#include <limits.h>
+#include <thread.h>
+#include <synch.h>
+extern struct process* ptable[256];
+
+struct process
+{ pid_t ppid;
+bool exited;
+int exitcode;
+struct thread *self;
+struct semaphore *sem_proc;
+//struct lock *lock_proc;
+};
+
+pid_t pid_alloc(void);
+int process_create(pid_t pid, struct thread *thread);
+void process_destroy(pid_t pid);
+
+#endif /* _PROCESS_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..2943d48 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,7 +74,12 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
-        // add what you need here
+        struct wchan *lk_wchan;
+	struct thread *lk_cur;
+	struct spinlock lk_lock;
+        volatile bool locked;
+        
+	// add what you need here
         // (don't forget to mark things volatile as needed)
 };
 
@@ -113,7 +118,9 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
-        // add what you need here
+        struct wchan *cv_wchan;
+	struct lock *cv_lock;
+	// add what you need here
         // (don't forget to mark things volatile as needed)
 };
 
@@ -143,14 +150,20 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+	struct lock *r_lock;
+	struct lock *w_lock;
+	//struct lock *Q_lock;               //limit reader if writer waits
+	struct lock *rw_lock;
+	volatile int readcount;
+	volatile int writecount;
 };
 
-struct rwlock * rwlock_create(const char *);
-void rwlock_destroy(struct rwlock *);
+struct rwlock *rwlock_create(const char *name);
+void rwlock_destroy(struct rwlock *rwlock);
 
-void rwlock_acquire_read(struct rwlock *);
-void rwlock_release_read(struct rwlock *);
-void rwlock_acquire_write(struct rwlock *);
-void rwlock_release_write(struct rwlock *);
+void rwlock_acquire_read(struct rwlock *rwlock);
+void rwlock_release_read(struct rwlock *rwlock);
+void rwlock_acquire_write(struct rwlock *rwlock);
+void rwlock_release_write(struct rwlock *rwlock);
 
 #endif /* _SYNCH_H_ */
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..acf28e4 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -30,6 +30,7 @@
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
+#include <kern/filesys.h>
 
 struct trapframe; /* from <machine/trapframe.h> */
 
@@ -45,7 +46,7 @@ void syscall(struct trapframe *tf);
 
 /* Helper for fork(). You write this. */
 void enter_forked_process(struct trapframe *tf);
-
+void child_fork_entry(void* data1, unsigned long data2);
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 		       vaddr_t entrypoint);
@@ -57,5 +58,21 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+int sys_open(const char *fdesc_name, int flags, mode_t mode, int *retval);
+ int sys_close(int fh, int *retval);
+ int sys_write(int fd, const void *buf, size_t size, int *retval);
+ int sys_read(int fd, void *buf, size_t buflen, int *retval);
+ int sys_lseek(int fd, off_t pos, int whence, off_t *ret);
+ int sys_dup2(int oldfd, int newfd, int *retval);
+ int sys_chdir(const char *pathname, int *retval);
+ int sys___getcwd(char *buf, size_t buflen, int *retval);
+
+int sys_fork(struct trapframe* tf, int *retval);
+int sys_execv(int *retval,const char *program, char **args);
+int sys_getpid(int *retval);
+int sys__exit(int exitcode);
+int sys_waitpid(int *retval,pid_t pid, int *status, int options);
+
+
 
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..f6ac263 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -105,7 +105,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname, int argc, char **argv);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..5cd9383 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,8 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <kern/filesys.h>
+#include<limits.h>
 
 struct addrspace;
 struct cpu;
@@ -104,7 +106,8 @@ struct thread {
 	/*
 	 * Public fields
 	 */
-
+	pid_t t_pid;
+	struct fd *fdtable[OPEN_MAX];
 	/* VM */
 	struct addrspace *t_addrspace;	/* virtual address space */
 
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..dbb5eee 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -35,8 +35,28 @@
  *
  * You'll probably want to add stuff here.
  */
+enum page_state{
+	FREE,
+	FIXED,
+	DIRTY,
+	CLEAN
+};
 
+struct coremap_entry{
+	vaddr_t va;
+	struct addrspace* as;
+	enum page_state pgstate;
+	int chunk;
+	int pid;
+};
+struct coremap_entry* coremap;
 
+
+
+vaddr_t page_alloc(void);
+vaddr_t page_nalloc(int npages);
+void page_free(void);
+void make_page_avail(struct coremap_entry* coremap);
 #include <machine/vm.h>
 
 /* Fault-type arguments to vm_fault() */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..fb5dd52 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+//weihaoqu@buffalo.edu
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
@@ -100,8 +101,8 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
-		GROUP_VERSION, buildconfig, buildversion);
+
+	kprintf("weihaoqu@buffalo.edu's system version %s (%s #%d)\n", GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
 	/* Early initialization. */
@@ -202,9 +203,7 @@ sys_reboot(int code)
  */
 void
 kmain(char *arguments)
-{
-	boot();
-
+{       boot();
 	menu(arguments);
 
 	/* Should not get here */
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..4097173 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -43,7 +43,8 @@
 #include "opt-synchprobs.h"
 #include "opt-sfs.h"
 #include "opt-net.h"
-
+#include <kern/process.h>
+#include <kern/filesys.h>
 /*
  * In-kernel menu and command dispatcher.
  */
@@ -100,10 +101,11 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname, nargs, args);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
+		sys__exit(-1);
 		return;
 	}
 
@@ -132,16 +134,18 @@ common_prog(int nargs, char **args)
 	kprintf("Warning: this probably won't work with a "
 		"synchronization-problems kernel.\n");
 #endif
-
+	struct thread *cthread;
+	
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&cthread);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
 	}
-
+	P(ptable[cthread->t_pid]->sem_proc);
+	
 	return 0;
 }
 
@@ -491,7 +495,7 @@ cmd_mainmenu(int n, char **a)
 {
 	(void)n;
 	(void)a;
-
+	
 	showmenu("OS/161 kernel menu", mainmenu);
 	return 0;
 }
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..febf782 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,25 +47,67 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+static struct lock *male_lock;
+static struct lock *female_lock;
+static struct lock *matchmaker_lock;
+
+static struct semaphore *count1;
+static struct semaphore *count2;
+static struct semaphore *count3;
+
 void whalemating_init() {
-  return;
+  	
+	
+	male_lock = lock_create("male_lock");
+  	DEBUGASSERT(male_lock != NULL);
+	female_lock = lock_create("female_lock");
+  	DEBUGASSERT(female_lock != NULL);
+	matchmaker_lock = lock_create("matchmaker_lock");
+  	DEBUGASSERT(matchmaker_lock != NULL);
+	count1 = sem_create("count1",0);
+  	DEBUGASSERT(count1 != NULL);	
+	count2 = sem_create("count2",0);
+  	DEBUGASSERT(count2 != NULL);	
+	count3 = sem_create("count3",0);
+  	DEBUGASSERT(count3 != NULL);	
+//return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
-  return;
+sem_destroy(count3);
+sem_destroy(count2);
+sem_destroy(count1);
+
+lock_destroy(matchmaker_lock);  
+lock_destroy(female_lock);  
+lock_destroy(male_lock);  
+
+
+//return;
 }
 
 void
 male(void *p, unsigned long which)
-{
+{	
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  male_start();
-	// Implement this function 
+male_start();
+	
+	lock_acquire(male_lock);
+	
+	V(count1);
+	P(count2);
+	
+	
+	
+	
+	
+	lock_release(male_lock);		
+// Implement this function 
   male_end();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -76,12 +118,22 @@ male(void *p, unsigned long which)
 
 void
 female(void *p, unsigned long which)
-{
+{	
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+
   female_start();
-	// Implement this function 
+	lock_acquire(female_lock);
+	
+	
+	V(count2);
+	P(count3);
+	
+	
+	
+	lock_release(female_lock);	
+	
+// Implement this function 
   female_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -92,11 +144,22 @@ female(void *p, unsigned long which)
 
 void
 matchmaker(void *p, unsigned long which)
-{
+{	
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
   matchmaker_start();
+	
+	lock_acquire(matchmaker_lock);
+	
+	V(count3);
+	P(count1);
+	
+	
+	
+	
+	
+	lock_release(matchmaker_lock);
 	// Implement this function 
   matchmaker_end();
   
@@ -136,8 +199,26 @@ matchmaker(void *p, unsigned long which)
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+static struct lock *whole_lock;
+static struct lock *lock_0;
+static struct lock *lock_1;
+static struct lock *lock_2;
+static struct lock *lock_3;
+static struct semaphore *sem;
 
 void stoplight_init() {
+	whole_lock = lock_create("whole_lock");
+	DEBUGASSERT(whole_lock != NULL);
+	lock_0 = lock_create("lock_0");
+  	DEBUGASSERT(lock_0 != NULL);
+	lock_1 = lock_create("lock_1");
+  	DEBUGASSERT(lock_1 != NULL);
+	lock_2 = lock_create("lock_2");
+  	DEBUGASSERT(lock_2 != NULL);
+	lock_3 = lock_create("lock_3");
+  	DEBUGASSERT(lock_3 != NULL);
+	sem = sem_create("sem",2);
+  	DEBUGASSERT(sem != NULL);
   return;
 }
 
@@ -145,15 +226,92 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+	sem_destroy(sem);
+	lock_destroy(lock_3);
+	lock_destroy(lock_2);  
+	lock_destroy(lock_1);  
+	lock_destroy(lock_0);  
+	lock_destroy(whole_lock);
+  	return;
 }
 
 void
 gostraight(void *p, unsigned long direction)
-{
+{	 int X;
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
-  
+  	int i = 0;
+	X=direction;
+	lock_acquire(whole_lock);
+	switch(X){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	X);
+	P(sem);
+	if(sem->sem_count>0) {
+	lock_release(whole_lock);
+	i=1;
+	}
+	switch((X+3)%4){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	(X+3)%4);
+	switch(X){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	leaveIntersection();
+	V(sem);
+	
+	switch((X+3)%4){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	if (i==0)
+	lock_release(whole_lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -165,7 +323,109 @@ turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
-  
+  	int i =0;
+	int X=direction;
+	lock_acquire(whole_lock);
+	switch(X){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	X);
+	P(sem);
+	if(sem->sem_count>0) {
+	lock_release(whole_lock);
+	i=1;
+	}
+	switch((X+3)%4){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	(X+3)%4);
+	switch(X){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	switch((X+2)%4){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	(X+2)%4);
+	
+	switch((X+3)%4){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	leaveIntersection();
+	V(sem);
+	
+
+	switch((X+2)%4){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	if (i==0)
+	lock_release(whole_lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -177,7 +437,50 @@ turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+	int i = 0;
+ 	int X=direction;
+	lock_acquire(whole_lock);
+	switch(X){
+		case 0: 
+			lock_acquire(lock_0);
+			break;
+		case 1:
+			lock_acquire(lock_1);
+			break;
+		case 2:
+			lock_acquire(lock_2);
+			break;
+		case 3:
+			lock_acquire(lock_3);
+			break;
+	}
+	inQuadrant(	X);
+	P(sem);
+	if(sem->sem_count>0) {
+	lock_release(whole_lock);
+	i=1;
+	}
+	leaveIntersection();
+	V(sem);
+	
 
+	switch(X){
+		case 0: 
+			lock_release(lock_0);
+			break;
+		case 1:
+			lock_release(lock_1);
+			break;
+		case 2:
+			lock_release(lock_2);
+			break;
+		case 3:
+			lock_release(lock_3);
+			break;
+	}	
+	if (i==0)
+	lock_release(whole_lock);
+	
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
diff --git a/kern/syscall/filesys.c b/kern/syscall/filesys.c
new file mode 100644
index 0000000..afb1be5
--- /dev/null
+++ b/kern/syscall/filesys.c
@@ -0,0 +1,431 @@
+#include <syscall.h> 
+#include <lib.h> 
+#include <vfs.h> 
+#include <vnode.h> 
+#include <stdarg.h> 
+#include <types.h> 
+#include <kern/errno.h> 
+#include <kern/fcntl.h> 
+#include <limits.h> 
+#include <uio.h> 
+#include <kern/iovec.h> 
+#include <synch.h> 
+#include <current.h> 
+#include <copyinout.h> 
+#include <kern/seek.h> 
+#include <kern/stat.h> 
+#include <kern/filesys.h> 
+
+int fdesc_init(void) { 
+	int result1;
+	struct vnode *v1;
+	curthread->fdtable[0] = (struct fd *)kmalloc(sizeof(struct fd));
+	if (curthread->fdtable[0]==NULL) {return ENOMEM;}
+	char fname1[5]="con:";
+	result1 = vfs_open(fname1, O_RDONLY, 0664, &v1);
+
+	if(result1){
+		kfree(curthread->fdtable[0]);
+		return EINVAL;
+	}
+	
+	curthread->fdtable[0]->vn=v1;
+	strcpy(curthread->fdtable[0]->filename,fname1);
+	curthread->fdtable[0]->ref_count=1;
+	curthread->fdtable[0]->flags = O_RDONLY;
+	curthread->fdtable[0]->offset = 0;   
+	curthread->fdtable[0]->lock = lock_create("STDIN");
+	if (curthread->fdtable[0]->lock==NULL) return ENOMEM;
+
+	int result2;
+	struct vnode *v2;
+	curthread->fdtable[1] = (struct fd *)kmalloc(sizeof(struct fd));
+
+	if (curthread->fdtable[1] ==NULL) {return ENOMEM;}
+	char fname2[5]="con:";
+	result2 = vfs_open(fname2, O_WRONLY, 0664, &v2);
+
+	if(result2){
+		kfree(curthread->fdtable[1] );
+		return EINVAL;
+	}
+	
+	curthread->fdtable[1] ->vn=v2;
+	strcpy(curthread->fdtable[1]->filename,fname2);
+	curthread->fdtable[1] ->ref_count=1;
+	curthread->fdtable[1] ->flags = O_WRONLY;
+	curthread->fdtable[1] ->offset = 0;   
+	curthread->fdtable[1] ->lock = lock_create("STDOUT");
+	if (curthread->fdtable[1] ->lock==NULL) return ENOMEM; 
+
+	int result3;
+	struct vnode *v3;
+
+	curthread->fdtable[2]  = (struct fd *)kmalloc(sizeof(struct fd));
+
+	if (curthread->fdtable[2]==NULL) {return ENOMEM;}
+	char fname3[5]="con:";
+	result3 = vfs_open(fname3, O_WRONLY, 0664, &v3);
+
+	if(result3){
+		kfree(curthread->fdtable[2]);
+		return EINVAL;
+	}
+	
+	curthread->fdtable[2]->vn=v3;
+	strcpy(curthread->fdtable[2]->filename,fname3);
+	curthread->fdtable[2]->ref_count=1;
+	curthread->fdtable[2]->flags = O_WRONLY;
+	curthread->fdtable[2]->offset = 0;   
+	curthread->fdtable[2]->lock = lock_create("STDERR");
+	if (curthread->fdtable[2]->lock==NULL) return ENOMEM;
+	
+	return 0; 
+}  
+
+int sys_open(const char *fdesc_name, int flags, mode_t mode , int *retval) { 
+
+ 	int result=0, index = 3; 
+	struct vnode *vn; 
+ 	char *fname; 
+	size_t len;
+        fname = (char *)kmalloc(sizeof(char)*PATH_MAX);
+         if(copyinstr((const_userptr_t)fdesc_name, fname, PATH_MAX, &len)){
+                kfree(fname);
+		*retval = -1;
+                return EFAULT;
+        }
+
+	while(curthread->fdtable[index] != NULL){
+		if(index <OPEN_MAX) index++;
+	}
+ 
+ 	if(index == OPEN_MAX) { 
+		kfree(fname);
+		
+ 		return EMFILE;  //fdtable[] is fulled no more valid place.
+ 	} 
+ 	curthread->fdtable[index] = (struct fd*)kmalloc(sizeof(struct fd)); 
+	
+	result = vfs_open(fname,flags,mode,&vn); 
+	if(result) { 
+ 		kfree(curthread->fdtable[index]); 
+		kfree(fname);
+		
+ 		curthread->fdtable[index] = NULL; 
+ 		return result; 
+ 	} 
+  	strcpy(curthread->fdtable[index]->filename,fname);
+	curthread->fdtable[index]->lock= lock_create(fname); 
+	
+	kfree(fname);
+	if(curthread->fdtable[index]->lock == NULL) return ENOMEM;
+ 	curthread->fdtable[index]->vn = vn; 
+ 	curthread->fdtable[index]->flags = flags; 
+ 	curthread->fdtable[index]->ref_count = 1; 
+ 	curthread->fdtable[index]->offset = 0; 
+ 	
+	
+  	
+	
+	*retval = index;
+ 	return 0; 
+ } 
+ 
+ 
+int sys_close(int fh, int *retval) { 
+
+ 	if(fh >= OPEN_MAX ){
+		*retval = -1;
+		return EBADF;
+	}
+
+	if(fh < 0) { 
+		*retval = -1;
+ 		return EBADF;  //not valid location in fdtable[]
+ 	} 
+
+ 	if(curthread->fdtable[fh] == NULL) { 
+		*retval = -1;
+ 		return EBADF;  // already empty or closed so that fdtable[fh] is closed
+ 	}  
+ 
+ 	if(curthread->fdtable[fh]->vn == NULL) { 
+		*retval = -1;
+ 		return EBADF;  // if there is no valid fdesc inside of fdtable
+ 	} 
+  	
+ 	if(curthread->fdtable[fh]->ref_count == 1) {  
+ 		vfs_close(curthread->fdtable[fh]->vn);
+		curthread->fdtable[fh]->ref_count =0;
+                lock_destroy(curthread->fdtable[fh]->lock);
+		kfree(curthread->fdtable[fh]); 
+ 		curthread->fdtable[fh] = NULL;
+ 	}else curthread->fdtable[fh]->ref_count--;
+   	int *k=kmalloc(sizeof(int));
+	kfree(k);
+	*retval = 0;
+ 	return 0;  
+} 
+
+int sys_read(int fd, void *buf, size_t buflen, int *retval){
+	if(fd >= OPEN_MAX) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(fd < 0) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd] == NULL) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd]->flags == O_WRONLY) {
+		*retval = -1;
+		return EBADF;
+	}
+	struct uio u;
+	struct iovec i;
+	
+	lock_acquire(curthread->fdtable[fd]->lock);
+
+	i.iov_ubase = (userptr_t)buf;
+	i.iov_len = buflen;
+	u.uio_iov = &i;
+	u.uio_iovcnt = 1;
+	u.uio_offset = curthread->fdtable[fd]->offset;
+	u.uio_resid = buflen;
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_READ;
+	u.uio_space = curthread->t_addrspace;
+
+	int result = VOP_READ(curthread->fdtable[fd]->vn, &u);
+	if(result){
+		lock_release(curthread->fdtable[fd]->lock);
+		
+		return result;
+	}
+	curthread->fdtable[fd]->offset = u.uio_offset;
+	*retval = buflen - u.uio_resid;
+	lock_release(curthread->fdtable[fd]->lock);
+	
+	return 0;
+}
+
+int sys_write(int fd, const void *buf, size_t buflen, int *retval){
+
+	if(fd >= OPEN_MAX) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(fd < 0) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd] == NULL) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(!buf){
+		*retval = -1;
+		 return EFAULT;
+	}
+
+	if(curthread->fdtable[fd]->flags == O_RDONLY) {
+		*retval = -1;
+		return EBADF;
+	}
+	struct uio u;
+	struct iovec i;
+	
+	lock_acquire(curthread->fdtable[fd]->lock);
+
+	i.iov_ubase = (userptr_t)buf;
+	i.iov_len = buflen;
+	u.uio_iov = &i;
+	u.uio_iovcnt = 1;
+	u.uio_offset = curthread->fdtable[fd]->offset;
+	u.uio_resid = buflen;
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_WRITE;
+	u.uio_space = curthread->t_addrspace;
+
+	int result = VOP_WRITE(curthread->fdtable[fd]->vn, &u);
+	if(result){
+		lock_release(curthread->fdtable[fd]->lock);
+		
+		return result;
+	}
+	curthread->fdtable[fd]->offset = u.uio_offset;
+	*retval = buflen - u.uio_resid;
+	lock_release(curthread->fdtable[fd]->lock);
+
+	return 0;
+}
+
+int sys_dup2(int oldfd, int newfd, int *retval){
+	int result = 0;
+	if(oldfd >= OPEN_MAX){ 
+		*retval = -1;
+		 return EBADF;
+	}
+	if(oldfd<0){
+		*retval = -1;
+		return EBADF;
+	}
+	if(newfd>=OPEN_MAX){
+		*retval = -1;
+		return EBADF;
+	}
+	if(newfd<0){
+		*retval = -1;
+		return EBADF;
+	}
+	if(newfd == oldfd){
+		*retval = newfd;
+		return 0;
+	}
+	if(curthread->fdtable[oldfd] == NULL) {
+		*retval = -1;
+		return EBADF;
+	}
+	if(curthread->fdtable[newfd] != NULL){ 
+		result = sys_close(newfd,retval);
+		if(result){ 
+			*retval = -1;
+			return EBADF;
+		}
+	}
+
+	curthread->fdtable[newfd] = curthread->fdtable[oldfd];
+
+	*retval = newfd;
+	return 0;
+}
+
+int sys_lseek(int fd, off_t pos, int whence, off_t *retval){
+	if(fd >= OPEN_MAX){
+		 *retval = (off_t)-1;
+		 return EBADF;
+	}
+	if(fd < 0) {
+		*retval = (off_t)-1;
+		return EBADF;
+	}
+	if(curthread->fdtable[fd] == NULL) {
+		*retval = (off_t)-1;
+		return EBADF;
+	}
+	
+	struct stat s; 
+	off_t noffset, size, curr, pos1;
+	int result = 0;
+	
+	lock_acquire(curthread->fdtable[fd]->lock);	
+	
+	if(VOP_STAT(curthread->fdtable[fd]->vn, &s)){
+		lock_release(curthread->fdtable[fd]->lock);
+		*retval = (off_t)-1;
+		return EBADF;
+	}
+	size = s.st_size;
+	pos1 = pos;
+	result = strcmp(curthread->fdtable[fd]->filename, "null");
+	if(result == 0){
+		lock_release(curthread->fdtable[fd]->lock);
+		*retval = (off_t)-1;
+		return ESPIPE;
+	}
+	if(whence == SEEK_SET){
+		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos1));
+		if(result){
+			lock_release(curthread->fdtable[fd]->lock);	
+			*retval =(off_t) -1;
+			return EINVAL;
+		}
+		noffset = pos1;
+	}else if(whence == SEEK_CUR){
+		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos1+curr));
+		if(result){
+			lock_release(curthread->fdtable[fd]->lock);	
+			*retval =(off_t) -1;
+			return ESPIPE;
+		}
+		curr = curthread->fdtable[fd]->offset;
+		noffset = pos1+curr;
+	}else if(whence == SEEK_END){
+		result = VOP_TRYSEEK(curthread->fdtable[fd]->vn, (pos + size));
+		if(result){
+			lock_release(curthread->fdtable[fd]->lock);		
+			*retval =(off_t) -1;
+			return EINVAL;
+		}
+		noffset = pos1 + size;
+	}else{
+		lock_release(curthread->fdtable[fd]->lock);
+		*retval = (off_t)-1;
+		return EINVAL;
+	}
+	curthread->fdtable[fd]->offset = noffset;
+	
+	*retval = noffset;
+	lock_release(curthread->fdtable[fd]->lock);
+	return 0;
+}
+
+int sys_chdir(const char *pathname, int *retval){
+	char *path;
+	size_t len;
+	path = (char *)kmalloc(sizeof(char)*PATH_MAX);
+	int result = 0;
+	result = copyinstr((const_userptr_t)pathname, path, PATH_MAX, &len);
+	if(result){
+		kfree(path);
+		*retval = -1;		
+		return EFAULT;
+	}
+	result = vfs_chdir(path);
+	if(result) { 
+		kfree(path);
+		
+		return ENOTDIR;
+	}
+	*retval = 0;
+	kfree(path);
+	return 0;
+}
+
+int sys___getcwd(char *buf, size_t buflen, int *retval){
+	struct uio u;
+	struct iovec i;
+	if(buf==NULL) return EFAULT;
+	
+	//char *nbuf=(char *)kmalloc(sizeof(char)*buflen);	
+	int result = 0;
+	//if(copyinstr((const_userptr_t)buf, nbuf, PATH_MAX, &buflen)){
+	//	 *retval = -1;
+	//	 return EFAULT;
+	//}
+
+	i.iov_ubase = (userptr_t)buf;
+	i.iov_len = (buflen -1);
+	u.uio_iov = &i;
+	u.uio_iovcnt = 1;
+	u.uio_offset = (off_t)0;
+	u.uio_resid = (buflen-1);
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_READ;
+	u.uio_space = curthread->t_addrspace;
+	
+	
+	result = vfs_getcwd(&u);
+	if(result) {
+		
+		return ENOENT;
+	}
+	int re = strlen(buf);
+		
+	*retval = re;
+	return 0;
+}
diff --git a/kern/syscall/process.c b/kern/syscall/process.c
new file mode 100644
index 0000000..d03f7b3
--- /dev/null
+++ b/kern/syscall/process.c
@@ -0,0 +1,72 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <array.h>
+#include <cpu.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <wchan.h>
+#include <thread.h>
+#include <threadlist.h>
+#include <threadprivate.h>
+#include <current.h>
+#include <synch.h>
+#include <addrspace.h>
+#include <mainbus.h>
+#include <vnode.h>
+#include <kern/process.h>
+#include <kern/filesys.h>
+
+ //void thread_destroy(struct thread *thread);
+struct process *ptable[256];
+
+pid_t pid_alloc(void){
+	
+	for (int i=2; i<256; i++){
+		if (ptable[i]==NULL){
+		return (pid_t)i;
+		}
+	}
+	return (pid_t)-2; 
+}
+
+int  process_create(pid_t pid, struct thread *thread){
+		struct process *proc=kmalloc(sizeof(struct process));
+		if(proc==NULL)
+			return ENOMEM;
+		proc->ppid=-1;
+		proc->exited=false;
+		proc->exitcode=0;
+		proc->self=thread;
+		proc->sem_proc=sem_create("sema_process",0);
+		if (proc->sem_proc==NULL) {
+			 kfree(proc);
+			return ENOMEM;
+		}
+		//proc->lock_proc=lock_create("lock_process");
+		//if (proc->lock_proc==NULL) {
+		//	cv_destroy(proc->cv_proc); 
+		//	kfree(proc);
+		//	return ENOMEM;
+		//}
+		ptable[pid]=proc;
+		return 0;
+}
+
+void process_destroy(pid_t pid){
+	//lock_destroy(ptable[pid]->lock_proc);
+	sem_destroy(ptable[pid]->sem_proc);
+	
+	//int ret=0;
+	//int k=0;	
+	//for(int a=0;a<OPEN_MAX;a++){
+	//if (ptable[pid]->self->fdtable[a]!=NULL){
+	//k=sys_close(a,&ret);
+	//	}
+	//}
+	
+	//kfree(ptable[pid]->self->t_name);
+	//kfree(ptable[pid]->self);
+	kfree(ptable[pid]);
+	ptable[pid]=NULL;
+}
diff --git a/kern/syscall/process_support.c b/kern/syscall/process_support.c
new file mode 100644
index 0000000..24e64b6
--- /dev/null
+++ b/kern/syscall/process_support.c
@@ -0,0 +1,316 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <kern/wait.h>
+#include <copyinout.h>
+#include <uio.h>
+#include <lib.h>
+#include <spl.h>
+#include <mips/trapframe.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <syscall.h>
+#include <test.h>
+#include <synch.h>
+#include <kern/seek.h>
+#include <stat.h>
+#include <kern/process.h>
+#include <kern/filesys.h>
+
+struct process* ptable[256];
+int sys_fork(struct trapframe *tf,int *retval ){
+	
+	struct trapframe* ktf=kmalloc(sizeof(struct trapframe));
+	
+	if(ktf==NULL){
+	return ENOMEM;
+	}
+	struct addrspace *cspace=NULL;
+	
+	memcpy(ktf,tf,sizeof(struct trapframe));
+	 int err=as_copy(curthread->t_addrspace,&cspace);
+	if (err){ 	
+	kfree(ktf);
+	return err;
+	}
+
+	struct thread *cthread;
+	err=thread_fork(curthread->t_name,child_fork_entry,(struct trapframe *)ktf, (unsigned long) cspace,&cthread);
+	if (err){ 
+	kfree(cspace);
+	kfree(ktf);
+	 return err;
+	}
+	
+	//if(cthread->t_pid<0)
+	
+	//while(ktf->tf_a0==0){}
+	//if(ktf->tf_a1==0) {kfree(ktf); *retval=-1;return ENOMEM;}
+	
+	
+	ptable[cthread->t_pid]->ppid=curthread->t_pid;
+	*retval=(int)cthread->t_pid;
+	//kfree(ktf);
+	return 0;
+
+}
+
+void
+child_fork_entry(void *data1, unsigned long data2 ){
+	
+	struct trapframe *ktf=data1;
+	struct addrspace *space=(struct addrspace*)data2;
+	ktf->tf_a3=0;
+	ktf->tf_v0=0;
+	ktf->tf_epc += 4;
+	
+	KASSERT( curthread->t_addrspace == NULL );
+	curthread->t_addrspace =space;
+	//curthread->t_addrspace = as_create();
+	
+	//memcpy(curthread->t_addrspace, sp, sizeof(struct addrspace));
+	as_activate(curthread->t_addrspace);
+	//tf->tf_a1=1;
+	//tf->tf_a0=0;
+	struct trapframe tfm;
+	memcpy(&tfm, ktf, sizeof(struct trapframe));
+	kfree(ktf);
+	mips_usermode(&tfm);
+	}
+ 
+int sys__exit(int exitcode){
+		KASSERT(ptable[curthread->t_pid]!=NULL);
+		//lock_acquire(ptable[curthread->t_pid]->lock_proc);
+		
+		//if((ptable[curthread->t_pid]->ppid<2) || (ptable[(ptable[curthread->t_pid]->ppid)]==NULL) ||ptable[(ptable[curthread->t_pid]->ppid)]->exited==true) {
+			//kfree(ptable[curthread->t_pid]);
+			//ptable[curthread->t_pid]=NULL;
+			//process_destroy(curthread->t_pid);
+			//ptable[curthread->t_pid]->exited=true;
+		//	lock_release(ptable[curthread->t_pid]->lock_proc);
+		//}
+		//else{
+		ptable[curthread->t_pid]->exitcode=_MKWAIT_EXIT(exitcode);
+		ptable[curthread->t_pid]->exited=true;
+		
+		V(ptable[curthread->t_pid]->sem_proc);
+		//lock_release(ptable[curthread->t_pid]->lock_proc);
+		
+		//}
+		
+	//for(int i=2;i<256;i++){
+	//	if(ptable[i]!=NULL){
+	//	if((ptable[i]->ppid)==curthread->t_pid) ptable[i]->ppid=-1;
+	//	}	
+//	}
+		thread_exit();
+		//*retval=0;
+		return 0;
+}
+ int sys_waitpid(int *retval,pid_t pid, int *status, int options){
+
+	if(pid<0||pid>=256) {return ESRCH; }
+	if(ptable[pid]==NULL){ return ESRCH;}
+	if(status==NULL){ return EFAULT;}
+	if(options!=0){ return EINVAL;}
+	if(curthread->t_pid!=ptable[pid]->ppid){ return ECHILD;}
+	if((vaddr_t)status%4 !=0){return EFAULT;}
+	if ((vaddr_t)status>=(vaddr_t)USERSPACETOP){return EFAULT;}
+	if(ptable[pid]->exited==false){
+	P(ptable[pid]->sem_proc);
+	}
+	
+	*retval=(int)pid;
+	
+	int *childcode =kmalloc(sizeof(int)); 
+	*childcode=ptable[pid]->exitcode; /* copy the MKWAIT_EXIT code */
+	process_destroy(pid);
+	int err=copyout((const void*)childcode, (userptr_t)status, sizeof(int) );
+	if(err) {kfree(childcode);
+		return err;
+		}
+	kfree(childcode);
+	return 0;
+}
+
+int sys_execv(int *retval,const char *program, char **args){
+	/*copy args into kspace*/
+	
+	
+
+
+
+
+	size_t len;
+	//if (args==NULL) return EFAULT;
+	char *kprogram=kmalloc(PATH_MAX*sizeof(char));
+	if(kprogram==NULL){*retval=-1;return ENOMEM; }
+	
+	int err=copyinstr((userptr_t)program, kprogram,PATH_MAX,&len);
+	if(err) {kfree(kprogram);*retval=-1;return err; }
+	if(len==1){ kfree(kprogram);*retval=-1;return EINVAL;}
+	
+	int i=0;
+	if(args==0x0) {kfree(kprogram);return EFAULT;}
+	char **tmp=(char **)kmalloc(32*sizeof(char*));
+	char *tmpst=kmalloc(128*sizeof(char));
+	if(tmpst==NULL){*retval=-1;return ENOMEM; }
+	for (int z=0;z<32;z++){
+	//kbuff[i]=kmalloc(char);
+	//while(*(args+z*4)!=NULL){
+	err=copyin((userptr_t)(args+4*z),(tmp+z*4),sizeof(char*));
+	
+	if (err) {kfree(tmp);kfree(tmpst);return EFAULT;}
+	err=copyinstr((userptr_t)tmp[z],tmpst,128, &len);
+	if (err) {kfree(tmp);kfree(tmpst);return EFAULT;}
+	//}
+	}
+	kfree(tmp);
+	kfree(tmpst);
+	while(args[i]!=NULL){
+	i++;}
+	int num=i;
+	
+	 char **kbuff=(char **)kmalloc(num*sizeof(char*));
+	if (kbuff==NULL){ *retval=-1;return ENOMEM;}
+	
+	int a[num];
+	int off[num+1];
+	off[0]=4*(num+1);
+	for (int i=0;i<num;i++){
+	//kbuff[i]=kmalloc(char);
+	err=copyin((userptr_t)(args+i*4),(kbuff+i*4),sizeof(char*));
+	if(err) {
+		kfree(kbuff);
+		kfree(kprogram);
+		*retval=-1;return err;
+		}
+	
+	int k=strlen(kbuff[i])+1;
+	int y=(k%4);
+	if (y==0) a[i]=k;
+	else a[i]=k+4-y;
+	off[i+1]=off[i]+a[i];
+	}
+	
+	
+	int stringlen=off[num];
+	//for (int b=0;b<num;b++)
+	//stringlen=stringlen+a[b];
+	
+	//stringlen=(num+1)*4+stringlen;	
+	
+	char *karg=kmalloc(stringlen);
+	if(karg==NULL) {
+	kfree(kbuff);
+	kfree(kprogram);
+	*retval=-1;return ENOMEM;}
+	
+	bzero(karg,stringlen);
+	//err=copyinst(kbuff[i],);
+	
+	//int off1=(num+1)*4;
+	size_t g;
+	for(int n=0;n<num;n++){
+		err=copyinstr((userptr_t)kbuff[n],(karg+off[n]),a[n],&g);
+		if(err) {
+			kfree(karg);
+			kfree(kbuff);
+			kfree(kprogram);
+			return err;
+			}
+		//((char **)karg)[i]= (char*) off[i];
+		//off1=off1+a[n];
+		}
+	//	((char**)karg)[i]=NULL;
+	
+	vaddr_t entrypoint, stackptr;
+	struct vnode *v;
+	int result = vfs_open(kprogram, O_RDONLY, 0, &v);
+	if (result) {
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		return result;
+	}
+		//KASSERT(curthread->t_addrspace == NULL);
+
+	/* Create a new address space. */
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(v);
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		*retval=-1;
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		*retval=-1;
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+	
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		return result;
+	}
+	
+	stackptr=stackptr-stringlen;
+	char ** kptr=kmalloc(4*(num+1));
+	if(kptr==NULL) return ENOMEM;
+	for (int i=0;i<num;i++){
+	kptr[i]=(char *)(stackptr+off[i]);
+	}
+	kptr[num]=NULL;
+	memcpy(karg, kptr, 4*(num+1));
+
+	err=copyout(karg,(userptr_t)stackptr,stringlen);
+	if (err){ 
+		kfree(kptr);
+		kfree(kbuff);
+		kfree(kprogram);
+		kfree(karg);
+		*retval=-1;return err;
+		}
+	curthread->t_name=kstrdup(kprogram);
+	kfree(kptr);
+	kfree(kbuff);
+	kfree(kprogram);
+	kfree(karg);
+	
+	enter_new_process(num/*argc*/, (userptr_t)stackptr/*userspace addr of argv*/,
+			  stackptr, entrypoint);
+	
+	/* enter_new_process does not return. */
+	panic("enter_new_process returned\n");
+	
+	return EINVAL;
+}
+
+int sys_getpid( int *retval){
+	*retval=(int)curthread->t_pid;
+	return 0;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..51d6b03 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -37,6 +37,7 @@
 #include <kern/errno.h>
 #include <kern/fcntl.h>
 #include <lib.h>
+#include <copyinout.h>
 #include <thread.h>
 #include <current.h>
 #include <addrspace.h>
@@ -44,7 +45,8 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <kern/filesys.h>
+#include <kern/process.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -52,15 +54,59 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
-{
+runprogram(char *progname, int argc, char ** argv)
+{	//size_t len;
+	
+	//char *kprogram=kmalloc(PATH_MAX*sizeof(char));
+	//if(kprogram==NULL){*retval=-1;return ENOMEM; }
+	
+	//int err=copyinstr((userptr_t)progname, kprogram,PATH_MAX,&len);
+	//if(err) {kfree(kprogram);*retval=-1;return err; }
+	//if(len==1){ kfree(kprogram);*retval=-1;return EINVAL;}
+
+	int a[argc];
+	int off[argc+1];
+	off[0]=4*(argc+1);
+	for (int i=0;i<argc;i++){
+		int k=strlen(argv[i])+1;
+		int y=(k%4);
+		if (y==0) a[i]=k;
+		else a[i]=k+4-y;
+		off[i+1]=off[i]+a[i];
+	}
+
+	int stringlen=off[argc];
+	char *karg=kmalloc(stringlen);
+	if(karg==NULL) {
+	//kfree(kprogram);
+	return ENOMEM;}
+	bzero(karg,stringlen);
+	
+	//size_t g;
+	for(int n=0;n<argc;n++){
+		memcpy(karg+off[n],argv[n],a[n]);
+		//err=copyinstr((userptr_t)argv[n],(karg+off[n]),a[n],&g);
+		//if(err) {
+		//	kfree(karg);
+			//kfree(kbuff);
+		//	kfree(kprogram);
+		//	return err;
+			}
+	
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
-
+	int err= fdesc_init();
+	if (err){
+	kfree(karg);
+	 return err;
+	}
+	//struct process *proc=kmalloc(sizeof(struct process));
+		
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
+		kfree(karg);
 		return result;
 	}
 
@@ -70,6 +116,7 @@ runprogram(char *progname)
 	/* Create a new address space. */
 	curthread->t_addrspace = as_create();
 	if (curthread->t_addrspace==NULL) {
+		kfree(karg);
 		vfs_close(v);
 		return ENOMEM;
 	}
@@ -81,6 +128,7 @@ runprogram(char *progname)
 	result = load_elf(v, &entrypoint);
 	if (result) {
 		/* thread_exit destroys curthread->t_addrspace */
+		kfree(karg);
 		vfs_close(v);
 		return result;
 	}
@@ -92,11 +140,36 @@ runprogram(char *progname)
 	result = as_define_stack(curthread->t_addrspace, &stackptr);
 	if (result) {
 		/* thread_exit destroys curthread->t_addrspace */
+		kfree(karg);
 		return result;
 	}
+	/*pid_t k=pid_alloc();
+	curthread->t_pid=k;
+	err=process_create(k,curthread);
+	if (err) {
+		return err;
+		}*/	
+	
+	stackptr=stackptr-stringlen;
+	char ** kptr=kmalloc(4*(argc+1));
+	if(kptr==NULL) return ENOMEM;
+	for (int i=0;i<argc;i++){
+	kptr[i]=(char *)(stackptr+off[i]);
+	}
+	kptr[argc]=NULL;
+	memcpy(karg, kptr, 4*(argc+1));
 
+	err=copyout(karg,(userptr_t)stackptr,stringlen);
+	if (err){ 
+		kfree(kptr);
+		//kfree(kbuff);
+		//kfree(kprogram);
+		kfree(karg);
+		return err;
+		}
+	curthread->t_name=kstrdup(progname);
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+	enter_new_process(argc, (userptr_t)stackptr,
 			  stackptr, entrypoint);
 	
 	/* enter_new_process does not return. */
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..a711d3d 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -164,7 +164,18 @@ lock_create(const char *name)
         }
         
         // add stuff here as needed
-        
+        lock->lk_wchan = wchan_create(lock->lk_name);
+	if (lock->lk_wchan == NULL) {
+		kfree(lock->lk_name);
+		kfree(lock);
+		return NULL;
+	}
+	
+	
+
+	spinlock_init(&lock->lk_lock);
+       	lock->locked = false;
+	lock->lk_cur=NULL;
         return lock;
 }
 
@@ -174,7 +185,9 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+        spinlock_cleanup(&lock->lk_lock);
+	
+	wchan_destroy(lock->lk_wchan);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +196,49 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+ 	KASSERT(curthread->t_in_interrupt == false);
+      	DEBUGASSERT(!lock_do_i_hold(lock));
+	spinlock_acquire(&lock->lk_lock);
+        while (lock->locked) {
+		
+		wchan_lock(lock->lk_wchan);
+		spinlock_release(&lock->lk_lock);
+                wchan_sleep(lock->lk_wchan);
+
+		spinlock_acquire(&lock->lk_lock);
+        }
+	lock->lk_cur = curthread;       
+        lock->locked = true;
+	spinlock_release(&lock->lk_lock);
+       // (void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	DEBUGASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->lk_lock);
+
+        lock->locked=false;
+        wchan_wakeone(lock->lk_wchan);
+	
+	spinlock_release(&lock->lk_lock);
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	bool i;
+	spinlock_acquire(&lock->lk_lock);
+	i = lock->lk_cur==curthread;
+	spinlock_release(&lock->lk_lock);
+	return i;
+        //(void)lock;  // suppress warning until code gets written
+
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -227,7 +263,13 @@ cv_create(const char *name)
         }
         
         // add stuff here as needed
-        
+         cv->cv_wchan = wchan_create(cv->cv_name);
+	if (cv->cv_wchan == NULL) {
+		kfree(cv->cv_name);
+		kfree(cv);
+		return NULL;
+	}
+	
         return cv;
 }
 
@@ -237,7 +279,8 @@ cv_destroy(struct cv *cv)
         KASSERT(cv != NULL);
 
         // add stuff here as needed
-        
+        wchan_destroy(cv->cv_wchan);
+        //kfree(lock->lk_name);
         kfree(cv->cv_name);
         kfree(cv);
 }
@@ -245,23 +288,109 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+	DEBUGASSERT(lock_do_i_hold(lock));
+	 wchan_lock(cv->cv_wchan);
+		lock_release(lock);
+                wchan_sleep(cv->cv_wchan);
+		lock_acquire(lock);
+	// Write this
+       // (void)cv;    // suppress warning until code gets written
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
-{
+{	
+	DEBUGASSERT(lock_do_i_hold(lock));
+	wchan_wakeone(cv->cv_wchan);	
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
+	DEBUGASSERT(lock_do_i_hold(lock));
+	wchan_wakeall(cv->cv_wchan);	
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
+}
+
+//rwlock
+ struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rwlock;
+	
+	rwlock = kmalloc(sizeof(struct rwlock));
+        if (rwlock == NULL) {
+                return NULL;
+        }
+
+        rwlock->rwlock_name = kstrdup(name);
+        if (rwlock->rwlock_name == NULL) {
+                kfree(rwlock);
+                return NULL;}
+
+	rwlock->r_lock =lock_create("rlock");
+	rwlock->w_lock =lock_create("wlock");
+	rwlock->rw_lock =lock_create("rwlock");
+	rwlock->readcount = 0;
+	rwlock->writecount = 0;
+	return rwlock;
+}
+
+void 
+rwlock_destroy(struct rwlock *rwlock){
+	 KASSERT(rwlock != NULL);
+	
+	lock_destroy(rwlock->rw_lock);
+	lock_destroy(rwlock->w_lock);
+	lock_destroy(rwlock->r_lock);
+        kfree(rwlock->rwlock_name);
+        kfree(rwlock);
+}
+void 
+rwlock_acquire_read(struct rwlock *rwlock)
+{
+	
+	lock_acquire(rwlock->r_lock);
+	if (rwlock->readcount==0) lock_acquire(rwlock->rw_lock);
+	rwlock->readcount++;
+	lock_release(rwlock->r_lock);
+	
+	
+}
+
+void 
+rwlock_release_read(struct rwlock *rwlock)
+{
+	
+	rwlock->readcount--;
+	if(rwlock->readcount==0) lock_release(rwlock->rw_lock);
 }
+
+void 
+rwlock_acquire_write(struct rwlock *rwlock)
+{
+	lock_acquire(rwlock->w_lock);
+	if(rwlock->writecount==0) lock_acquire(rwlock->r_lock);
+	rwlock->writecount++;
+	lock_acquire(rwlock->rw_lock);
+	lock_release(rwlock->w_lock);
+}
+
+void 
+rwlock_release_write(struct rwlock *rwlock)
+{
+	lock_release(rwlock->rw_lock);
+	lock_acquire(rwlock->w_lock);
+	rwlock->writecount--;
+	if(rwlock->writecount==0) lock_release(rwlock->r_lock);
+	lock_release(rwlock->w_lock);
+}
+
+
+
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..76f1500 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,8 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <kern/process.h>
+#include <limits.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -153,7 +155,21 @@ thread_create(const char *name)
 	thread->t_cwd = NULL;
 
 	/* If you add to struct thread, be sure to initialize here */
-
+	for(int i=0; i<OPEN_MAX;i++){
+	thread->fdtable[i]=NULL;
+	}
+	pid_t k=pid_alloc();
+	thread->t_pid=k;
+	
+	int err=process_create(k,thread);
+	if (err) {
+		kfree(thread->t_name);
+		kfree(thread);
+		return NULL;
+		}	
+//if(k=0){
+	//	kfree(thread);
+	
 	return thread;
 }
 
@@ -245,6 +261,7 @@ thread_destroy(struct thread *thread)
 	 * If you add things to struct thread, be sure to clean them up
 	 * either here or in thread_exit(). (And not both...)
 	 */
+	//kfree(&thread->t_pid);
 
 	/* VFS fields, cleaned up in thread_exit */
 	KASSERT(thread->t_cwd == NULL);
@@ -261,7 +278,7 @@ thread_destroy(struct thread *thread)
 
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
-
+	
 	kfree(thread->t_name);
 	kfree(thread);
 }
@@ -488,7 +505,10 @@ thread_fork(const char *name,
 	if (newthread == NULL) {
 		return ENOMEM;
 	}
-
+	if(newthread->t_pid==-2){
+	thread_destroy(newthread);
+	return ENPROC;
+	}
 	/* Allocate a stack */
 	newthread->t_stack = kmalloc(STACK_SIZE);
 	if (newthread->t_stack == NULL) {
@@ -520,9 +540,29 @@ thread_fork(const char *name,
 	 */
 	newthread->t_iplhigh_count++;
 
+	/*check if pid is available, give thread pid*/
+	
+	//data1->tf_a0=k;
+	
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
-
+	
+	/*copy ftable from parent to child*/
+	struct fd *f=NULL;
+	for(int i=0;i<OPEN_MAX;i++){
+		if(curthread->fdtable[i]!=NULL){
+	f=curthread->fdtable[i];
+	newthread->fdtable[i]=f;
+	newthread->fdtable[i]->ref_count++; }
+}
+	//pid_t k =pid_alloc();
+	
+	//newthread->t_pid=k;
+	//int err=process_create(k,newthread);
+	//if (err) {
+	//	thread_destroy(newthread);
+	//	return err;
+	//	}
 	/* Lock the current cpu's run queue and make the new thread runnable */
 	thread_make_runnable(newthread, false);
 
@@ -816,7 +856,15 @@ thread_exit(void)
 
 	/* Check the stack guard band. */
 	thread_checkstack(cur);
-
+	
+	/*close fdtable if needed*/
+	int ret=0;
+	int k=0;	
+	for(int i=0;i<OPEN_MAX;i++){
+	if (cur->fdtable[i]!=NULL){
+	k=sys_close(i,&ret);
+		}
+	}
 	/* Interrupts off on this processor */
         splhigh();
 	thread_switch(S_ZOMBIE, NULL);
diff --git a/kern/vm/vm.c b/kern/vm/vm.c
new file mode 100644
index 0000000..d964a99
--- /dev/null
+++ b/kern/vm/vm.c
@@ -0,0 +1,318 @@
+/*
+ * vm.c
+ *
+ *  Created on: Apr 14, 2015
+ *      Author: trinity
+ */
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+#include<machine/vm.h>
+
+struct lock* coremap_lk;
+static int bootstrap=0;
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+static int pnum;
+//#define DUMBVM_STACKPAGES    12
+
+void vm_bootstrap(void){
+	paddr_t first,last,freeadrs;
+	paddr_t x=0;
+	coremap_lk=lock_create("coremap_lock");
+	ram_getsize(&first,&last);
+	pnum=last/PAGE_SIZE;
+	coremap=(struct coremap_entry*)PADDR_TO_KVADDR(first);
+	freeadrs= first+pnum*sizeof(struct coremap_entry);
+	for (int i=0; i<pnum;i++){
+		coremap[i].va=PADDR_TO_KVADDR(x+i*PAGE_SIZE);
+		if(x+i*PAGE_SIZE<freeadrs) coremap[i].pgstate=FIXED;
+		else {coremap[i].pgstate=FREE;
+			coremap[i].chunk=1;}
+		}
+
+	bootstrap=1;
+}
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+
+	spinlock_acquire(&stealmem_lock);
+
+	addr = ram_stealmem(npages);
+
+	spinlock_release(&stealmem_lock);
+	return addr;
+}
+
+
+
+/* Allocate/free kernel heap pages (called by kmalloc/kfree) */
+vaddr_t alloc_kpages(int npages){
+	if (bootstrap==0){return PADDR_TO_KVADDR(getppages(npages));}
+	else return page_nalloc(npages);
+}
+vaddr_t page_nalloc(int npages){
+	lock_acquire(coremap_lk);
+	int i;
+	for (i=0;i<pnum;i++){
+		if (coremap[i].pgstate==FREE){
+			for (int k=1;k<npages;k++){
+				if(coremap[i+k].pgstate==FREE)coremap[i].chunk++;
+				else break;
+			}
+		if (coremap[i].chunk==npages) {
+			break;
+						}
+
+		}
+	}
+	if(coremap[i].chunk!=npages){lock_release(coremap_lk);return EFAULT;}
+	else {
+		for (int j=0;j<npages;j++){
+		make_page_avail((struct coremap_entry*)&coremap[i+j]);
+		coremap[i+j].pgstate=DIRTY;}
+	}
+	lock_release(coremap_lk);
+	return coremap[i].va;
+
+
+}
+vaddr_t page_alloc(void){
+	lock_acquire(coremap_lk);
+	int i;
+	for(i=0;i<pnum;i++){
+		if(coremap[i].pgstate==FREE)break;
+	}
+	if(coremap[i].pgstate!=FREE){
+		return EFAULT;
+		}
+	make_page_avail(&coremap[i]);
+	lock_release(coremap_lk);
+	return coremap[i].va;
+
+}
+ void make_page_avail(struct coremap_entry* coremap){
+	coremap->pgstate=DIRTY;
+	bzero((void *)coremap->va,PAGE_SIZE);
+}
+void free_kpages(vaddr_t addr){
+	int i;
+	for (i=0;i<pnum;i++){
+		if(coremap[i].va==addr)break;
+	}
+	if(coremap[i].va!=addr) return;
+	if(coremap[i].pgstate==FIXED)return;
+	int chunk=coremap[i].chunk;
+	for (int j=0;j<chunk;j++){
+		coremap[i+j].pgstate=FREE;
+		coremap[i+j].chunk=1;
+		}
+}
+
+
+
+/* TLB shootdown handling called from interprocessor_interrupt */
+void
+vm_tlbshootdown_all(void)
+{
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+	(void)ts;
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+/* Fault handling function called by trap code */
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{	(void) faultaddress;
+	(void)faulttype;
+	return 0;
+}
+
+//struct addrspace *
+//as_create(void)
+//{
+//	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+//	if (as==NULL) {
+//		return NULL;
+//	}
+//
+//	as->as_vbase1 = 0;
+//	as->as_pbase1 = 0;
+//	as->as_npages1 = 0;
+//	as->as_vbase2 = 0;
+//	as->as_pbase2 = 0;
+//	as->as_npages2 = 0;
+//	as->as_stackpbase = 0;
+//
+//	return as;
+//}
+//
+//void
+//as_destroy(struct addrspace *as)
+//{
+//	kfree(as);
+//}
+//
+//void
+//as_activate(struct addrspace *as)
+//{
+//	int i, spl;
+//
+//	(void)as;
+//
+//	/* Disable interrupts on this CPU while frobbing the TLB. */
+//	spl = splhigh();
+//
+//	for (i=0; i<NUM_TLB; i++) {
+//		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+//	}
+//
+//	splx(spl);
+//}
+//
+//int
+//as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+//		 int readable, int writeable, int executable)
+//{
+//	size_t npages;
+//
+//	/* Align the region. First, the base... */
+//	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+//	vaddr &= PAGE_FRAME;
+//
+//	/* ...and now the length. */
+//	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+//
+//	npages = sz / PAGE_SIZE;
+//
+//	/* We don't use these - all pages are read-write */
+//	(void)readable;
+//	(void)writeable;
+//	(void)executable;
+//
+//	if (as->as_vbase1 == 0) {
+//		as->as_vbase1 = vaddr;
+//		as->as_npages1 = npages;
+//		return 0;
+//	}
+//
+//	if (as->as_vbase2 == 0) {
+//		as->as_vbase2 = vaddr;
+//		as->as_npages2 = npages;
+//		return 0;
+//	}
+//
+//	/*
+//	 * Support for more than two regions is not available.
+//	 */
+//	kprintf("dumbvm: Warning: too many regions\n");
+//	return EUNIMP;
+//}
+//
+//static
+//void
+//as_zero_region(paddr_t paddr, unsigned npages)
+//{
+//	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+//}
+//
+//int
+//as_prepare_load(struct addrspace *as)
+//{
+//	KASSERT(as->as_pbase1 == 0);
+//	KASSERT(as->as_pbase2 == 0);
+//	KASSERT(as->as_stackpbase == 0);
+//
+//	as->as_pbase1 = getppages(as->as_npages1);
+//	if (as->as_pbase1 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_pbase2 = getppages(as->as_npages2);
+//	if (as->as_pbase2 == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+//	if (as->as_stackpbase == 0) {
+//		return ENOMEM;
+//	}
+//
+//	as_zero_region(as->as_pbase1, as->as_npages1);
+//	as_zero_region(as->as_pbase2, as->as_npages2);
+//	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+//
+//	return 0;
+//}
+//
+//int
+//as_complete_load(struct addrspace *as)
+//{
+//	(void)as;
+//	return 0;
+//}
+//
+//int
+//as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+//{
+//	KASSERT(as->as_stackpbase != 0);
+//
+//	*stackptr = USERSTACK;
+//	return 0;
+//}
+//
+//int
+//as_copy(struct addrspace *old, struct addrspace **ret)
+//{
+//	struct addrspace *new;
+//
+//	new = as_create();
+//	if (new==NULL) {
+//		return ENOMEM;
+//	}
+//
+//	new->as_vbase1 = old->as_vbase1;
+//	new->as_npages1 = old->as_npages1;
+//	new->as_vbase2 = old->as_vbase2;
+//	new->as_npages2 = old->as_npages2;
+//
+//	/* (Mis)use as_prepare_load to allocate some physical memory. */
+//	if (as_prepare_load(new)) {
+//		as_destroy(new);
+//		return ENOMEM;
+//	}
+//
+//	KASSERT(new->as_pbase1 != 0);
+//	KASSERT(new->as_pbase2 != 0);
+//	KASSERT(new->as_stackpbase != 0);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+//		old->as_npages1*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+//		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+//		old->as_npages2*PAGE_SIZE);
+//
+//	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+//		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+//		DUMBVM_STACKPAGES*PAGE_SIZE);
+//
+//	*ret = new;
+//	return 0;
+//}
+//
